<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#1e1e1e">
    <link rel="icon" href="./icon-192.png">
    <link rel="apple-touch-icon" href="./icon-192.png">

    <script>
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("./service-worker.js");
        navigator.serviceWorker.addEventListener("controllerchange", () => {
          window.location.reload();
        });
      }
    </script>

    <title>Obsidian Map Tool v55 (Mobile & Visual Update)</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', 'Apple SD Gothic Neo', sans-serif;
            background-color: #1e1e1e;
            color: #e0e0e0;
            margin: 0; padding: 0;
            width: 100vw; height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: row; /* ê¸°ë³¸ì€ ê°€ë¡œ ë°°ì¹˜ (PC) */
        }

        /* --- ë ˆì´ì•„ì›ƒ ê³µí†µ --- */
        .main-area {
            flex: 1; display: flex; flex-direction: column; 
            height: 100%; position: relative; overflow: hidden;
        }

        .ui-header {
            background-color: #252525; padding: 10px; border-bottom: 1px solid #333;
            display: flex; justify-content: center; align-items: center;
            flex-shrink: 0; z-index: 20; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .controls { 
            display: flex; gap: 8px; flex-wrap: nowrap; overflow-x: auto; 
            align-items: center; padding-bottom: 2px; -webkit-overflow-scrolling: touch;
            width: 100%; max-width: 100%;
        }
        .controls::-webkit-scrollbar { display: none; }

        #grid-wrapper {
            flex: 1; overflow: auto; position: relative; background: #121212;
            display: flex; justify-content: center; align-items: center;
            /* ê·¸ë¦¬ë“œ ë°°ê²½ íŒ¨í„´ ì¶”ê°€ */
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        #grid-container {
            display: grid; gap: 2px; /* ê°„ê²© ì‚´ì§ ë„“í˜ */
            background-color: #333; border: 4px solid #444;
            padding: 4px; border-radius: 4px;
            touch-action: none; transform-origin: center top;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .tile {
            width: 42px; height: 42px; background-color: #eee;
            display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr);
            position: relative; border-radius: 2px;
        }

        .bottom-ui {
            background-color: #1e1e1e; border-top: 1px solid #333; padding: 10px;
            display: flex; flex-direction: row; align-items: center; justify-content: space-between;
            gap: 10px; flex-shrink: 0; height: auto; min-height: 90px; z-index: 20;
        }

        /* --- ì •ë³´ íŒ¨ë„ ë””ìì¸ ê°œì„  --- */
        #info-panel {
            flex: 1; background: #262626; padding: 8px 15px; border-radius: 8px; 
            border: 1px solid #444; height: 100%; display: flex; flex-direction: column; 
            justify-content: center; font-size: 0.9em; position: relative; transition: all 0.3s;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
        }
        #info-panel.edit-mode { border: 1px solid #009688; background: linear-gradient(135deg, #262626, #004d40); }
        #info-panel.sim-mode { border: 1px solid #9c27b0; background: linear-gradient(135deg, #262626, #4a148c); }
        #info-panel.range-mode { border: 1px solid #ff9800; background: linear-gradient(135deg, #262626, #331a00); }

        #range-text { font-size: 1.3em; font-weight: 800; color: #4fc3f7; margin-bottom: 2px; text-shadow: 0 0 5px rgba(79, 195, 247, 0.3); }
        #status-text { font-size: 0.85em; color: #aaa; margin-top: 2px;}

        .legend-box { display: flex; gap: 10px; justify-content: center; margin-top: 5px; font-size: 0.75em; color: #ccc; }
        .legend-item { display: flex; align-items: center; gap: 4px; }
        .legend-color { width: 10px; height: 10px; border-radius: 2px; box-shadow: 0 0 2px rgba(0,0,0,0.5); }

        /* --- ì»¨íŠ¸ë¡¤ ë²„íŠ¼ --- */
        #sim-controls {
            display: none; align-items: center; gap: 8px; background: #333; padding: 5px 12px;
            border-radius: 30px; border: 1px solid #555; height: 100%; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #sim-controls.visible { display: flex; }

        button {
            padding: 8px 14px; background: #3a3a3a; color: white;
            border: 1px solid #555; border-radius: 6px; font-weight: 600; font-size: 0.85em;
            white-space: nowrap; transition: 0.2s;
        }
        button:active { transform: scale(0.95); }
        button.active { background-color: #2e7d32; border-color: #4caf50; box-shadow: 0 0 8px rgba(76, 175, 80, 0.4); }
        .tick-btn { width: 40px; height: 40px; border-radius: 50%; font-size: 1.5em; padding:0; display:flex; align-items:center; justify-content:center; background:#444;}
        
        #btn-range { background-color: #ff9800; color: black; border-color: #f57c00; }
        #btn-range.active { background-color: #e65100; color: white; }

        /* --- ì—ë””í„° íŒ¨ë„ --- */
        #editor-panel {
            position: absolute; top: 0; right: 0; bottom: 0; width: 280px; background: #222;
            border-left: 1px solid #444; padding: 15px; display: flex; flex-direction: column; overflow-y: auto;
            transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
            z-index: 100; box-shadow: -5px 0 15px rgba(0,0,0,0.5);
        }
        #editor-panel.visible { transform: translateX(0); }

        /* --- íƒ€ì¼ ë¹„ì£¼ì–¼ ì—…ê·¸ë ˆì´ë“œ (ê°€ì‹œì„± ê°œì„ ) --- */
        /* 1. ì‹œì‘ì  (Start): ì„ ëª…í•œ ì²­ë¡ìƒ‰ í…Œë‘ë¦¬ + ë‚´ë¶€ ê´‘ì› */
        .tile.start::after { 
            content: ''; position: absolute; inset: -2px; 
            border: 3px solid #00e5ff; border-radius: 4px;
            background-color: rgba(0, 229, 255, 0.2);
            box-shadow: 0 0 10px #00e5ff, inset 0 0 10px #00e5ff;
            z-index: 10; pointer-events: none; animation: pulse-cyan 2s infinite;
        }

        /* 2. ëª©í‘œì  (Target): ê°•ë ¬í•œ ë¶‰ì€ìƒ‰/ì£¼í™©ìƒ‰ + ê¹œë¹¡ì„ */
        .tile.target::before { 
            content: ''; position: absolute; inset: -2px; 
            border: 3px solid #ff3d00; border-radius: 4px;
            background-color: rgba(255, 61, 0, 0.2);
            box-shadow: 0 0 10px #ff3d00, inset 0 0 10px #ff3d00;
            z-index: 11; pointer-events: none; animation: pulse-red 1s infinite alternate;
        }

        /* 3. ì´ë™ ê²½ë¡œ (Path): ë…¸ë€ìƒ‰ ì±„ì›€ + ì‹¤ì„  (ì ì„ X) */
        .tile.path::before { 
            content: ''; position: absolute; inset: 0; 
            background-color: rgba(255, 215, 0, 0.4); /* ë°˜íˆ¬ëª… ë…¸ë€ìƒ‰ ì±„ì›€ */
            border: 2px solid #ffd700; /* ì‹¤ì„  í…Œë‘ë¦¬ */
            border-radius: 2px; z-index: 5; pointer-events: none;
        }

        /* ì• ë‹ˆë©”ì´ì…˜ í‚¤í”„ë ˆì„ */
        @keyframes pulse-cyan { 0% { box-shadow: 0 0 5px #00e5ff; } 50% { box-shadow: 0 0 15px #00e5ff; } 100% { box-shadow: 0 0 5px #00e5ff; } }
        @keyframes pulse-red { 0% { opacity: 0.7; transform: scale(0.98); } 100% { opacity: 1; transform: scale(1.02); } }

        /* íƒ€ì¼ ë‚´ë¶€ ìš”ì†Œ */
        .subcell { border: 0.5px solid rgba(0,0,0,0.08); }
        .subcell.obs-full { background-color: #111; box-shadow: inset 0 0 5px #000; } 
        .subcell.obs-partial { background: repeating-linear-gradient(45deg, #555, #555 5px, #777 5px, #777 10px); }
        .subcell.obs-weak { background-color: #009688; border: 1px solid #00796b; }

        /* ì‹œì•¼/ì‚¬ê±°ë¦¬ ì˜¤ë²„ë ˆì´ (ìƒ‰ê° ì¡°ì •) */
        .l-green { background-color: rgba(76, 175, 80, 0.9); }
        .l-yellow { background-color: rgba(255, 235, 59, 0.6); border: 1px solid #fff; }
        .l-blue { background-color: rgba(33, 150, 243, 0.9); }

        .subcell.sub-visible { background-color: rgba(76, 175, 80, 0.5) !important; }
        .subcell.in-range { background-color: rgba(255, 235, 59, 0.3); box-shadow: inset 0 0 0 1px rgba(255, 235, 59, 0.6); }
        .subcell.sub-visible.in-range { background-color: rgba(33, 150, 243, 0.6) !important; box-shadow: inset 0 0 0 1px #fff; }

        /* --- ğŸ“± ëª¨ë°”ì¼ ì„¸ë¡œ ëª¨ë“œ ëŒ€ì‘ (ë¯¸ë””ì–´ ì¿¼ë¦¬) --- */
        @media screen and (max-width: 768px) {
            body { flex-direction: column; } /* ì„¸ë¡œ ë°°ì¹˜ */
            
            .main-area { width: 100%; margin-right: 0; }
            
            .ui-header { padding: 8px 5px; }
            .controls { justify-content: flex-start; } /* ìŠ¤í¬ë¡¤ ê°€ëŠ¥í•˜ê²Œ */
            
            .bottom-ui { 
                flex-direction: column; gap: 10px; padding-bottom: 20px;
                background: rgba(30,30,30,0.95); backdrop-filter: blur(5px);
            }
            #sim-controls { width: 100%; justify-content: center; }
            #info-panel { width: 100%; }

            /* ì—ë””í„° íŒ¨ë„ì„ ì•„ë˜ì—ì„œ ì˜¬ë¼ì˜¤ê²Œ ë³€ê²½ (Bottom Sheet) */
            #editor-panel {
                top: auto; bottom: 0; left: 0; right: 0;
                width: 100%; height: 60vh; /* í™”ë©´ ì ˆë°˜ ì •ë„ */
                border-left: none; border-top: 2px solid #444;
                transform: translateY(100%); /* ì•„ë˜ë¡œ ìˆ¨ê¹€ */
            }
            #editor-panel.visible { transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="main-area">
        <div class="ui-header">
            <div class="controls">
                <select id="map-selector" onchange="handleMapSelect()">
                    <option value="" disabled selected>ë§µ ì„ íƒ</option>
                    <option value="__NEW__">ìƒˆ ë§µ</option>
                </select>
                <div style="width:1px; height:20px; background:#555; margin:0 5px;"></div>
                <button id="btn-editor" onclick="toggleEditor()">ğŸ›  í¸ì§‘</button>
                <button id="btn-area1" onclick="toggleArea1()">A1</button>
                <button id="btn-area2" onclick="toggleArea2()">A2</button>
                <button id="btn-sim" onclick="toggleSimulator()">ğŸ² ì´ë™</button>
                <button id="btn-los" onclick="toggleLOS()">ğŸ‘ LOS</button>
                <button id="btn-range" onclick="toggleRangeMode()">ğŸ“ ì‚¬ê±°ë¦¬</button>
            </div>
        </div>

        <div id="grid-wrapper"><div id="grid-container"></div></div>

        <div class="bottom-ui">
            <div id="sim-controls">
                <button class="tick-btn" onclick="changeVal(-1)">-</button>
                <span id="tick-display" style="font-weight:bold; color: #fff; font-size:1.2em;">3</span>
                <button class="tick-btn" onclick="changeVal(1)">+</button>
            </div>
            <div id="info-panel">
                <div id="range-text">ì¤€ë¹„ ì™„ë£Œ</div>
                <div id="detail-text">ì¼ë°˜ ëª¨ë“œ</div>
                <div id="status-text">ì‹œì‘ ì§€ì ì„ í„°ì¹˜í•˜ì„¸ìš”</div>
                <div class="legend-box">
                    <div class="legend-item"><div class="legend-color l-green"></div>ì‹œì•¼</div>
                    <div class="legend-item"><div class="legend-color l-yellow"></div>ì‚¬ê±°ë¦¬</div>
                    <div class="legend-item"><div class="legend-color l-blue"></div>ê³µê²©ê°€ëŠ¥</div>
                </div>
            </div>
        </div>
    </div>

    <div id="editor-panel">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <span style="font-weight:bold; color:white;">ë§µ ì—ë””í„°</span>
            <button onclick="toggleEditor()" style="background:#444; padding:5px 10px;">âŒ ë‹«ê¸°</button>
        </div>
        
        <div class="editor-section">
            <div class="editor-title">ê¸°ë³¸ ë„êµ¬</div>
            <button class="tool-btn selected" onclick="selectTool('ERASER')">â¬œ ì§€ìš°ê°œ</button>
            <button class="tool-btn" onclick="selectTool('CUSTOM_DRAW')">âœï¸ ì§ì ‘ ê·¸ë¦¬ê¸°</button>
            <button class="tool-btn" onclick="selectTool('FULL')">â¬› 3x3 ë°•ìŠ¤</button>
        </div>
        <div class="editor-section">
            <div class="editor-title">ğŸ”„ ëŒ€ì¹­ ë³µì‚¬</div>
            <div class="preset-group">
                <button onclick="applySymmetry('T2B')">â¬†â¡â¬‡</button>
                <button onclick="applySymmetry('B2T')">â¬‡â¡â¬†</button>
                <button onclick="applySymmetry('L2R')">â¬…â¡â¡</button>
                <button onclick="applySymmetry('R2L')">â¡â¡â¬…</button>
            </div>
        </div>
        <div class="editor-section">
            <div class="editor-title">ë§µ ê´€ë¦¬</div>
            <button class="tool-btn" onclick="saveMapAs()">ğŸ’¾ ì €ì¥</button>
            <button class="tool-btn" onclick="deleteCurrentMap()" style="background:#c62828;">ğŸ—‘ ì‚­ì œ</button>
            <button class="tool-btn" onclick="clearMapData()" style="background:#d32f2f;">âš¡ ì´ˆê¸°í™”</button>
        </div>
    </div>

    <script>
        // 1. ì„œë¹„ìŠ¤ ì›Œì»¤ ë“±ë¡
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(() => console.log('Service Worker Registered'))
                    .catch((err) => console.log('SW Failed', err));
            });
        }

        const container = document.getElementById('grid-container');
        const infoPanel = document.getElementById('info-panel');
        const rangeText = document.getElementById('range-text');
        const detailText = document.getElementById('detail-text');
        const statusText = document.getElementById('status-text');
        const editorPanel = document.getElementById('editor-panel');
        const simControls = document.getElementById('sim-controls');
        const tickDisplay = document.getElementById('tick-display');
        const mapSelector = document.getElementById('map-selector');
        
        let tiles = []; let isEditorMode = false; let isSimMode = false; let isRangeMode = false; 
        let isArea1Active = false; let isArea2Active = false; let isLOSActive = false; let isMouseDown = false;
        let currentTool = 'ERASER'; let currentGridWidth = 12; let currentGridHeight = 12;
        let startPoint = null; let isLocked = false; let maxTicks = 3; let rangeValue = 4; 
        let simSegments = []; let lockedAxis = null; let currentEditingMapName = null; let savedMaps = {};
        let isDragging = false;
        
        container.addEventListener('touchmove', handleTouchMove, { passive: false });
        container.addEventListener('touchstart', (e) => { isDragging = true; }, { passive: true });
        container.addEventListener('touchend', (e) => { isDragging = false; }, { passive: true });

        function handleTouchMove(e) {
            e.preventDefault(); 
            if (!isDragging) return;
            const touch = e.touches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            if (target) {
                const tile = target.closest('.tile');
                if (tile) {
                    const x = parseInt(tile.dataset.x);
                    const y = parseInt(tile.dataset.y);
                    if (isEditorMode) renderTileObject(tile, {t: currentTool});
                    else if ((isSimMode || !isEditorMode) && startPoint) handleMeasureHover(x, y);
                }
            }
        }

        const defaultMaps = {
            hotspot: [{x:9, y:1, t:'CONTAINER', idx:[8]}, {x:7, y:2, t:'FULL'}, {x:8, y:2, t:'CONTAINER', idx:[2]}, {x:10, y:2, t:'BLK_B'},{x:2, y:3, t:'GRY_R'}, {x:7, y:3, t:'FULL'}, {x:2, y:4, t:'BLK_T'}, {x:5, y:4, t:'BLK_T'}, {x:6, y:4, t:'CONTAINER', idx:[2,5]},{x:8, y:4, t:'FULL'}, {x:9, y:4, t:'CONTAINER', idx:[7,8]}, {x:10, y:4, t:'CONTAINER', idx:[3,6]}, {x:4, y:5, t:'CONTAINER', idx:[2]},{x:8, y:5, t:'GRY_R'}, {x:3, y:6, t:'GRY_L'}, {x:7, y:6, t:'CONTAINER', idx:[6]}, {x:1, y:7, t:'CONTAINER', idx:[2,5]},{x:2, y:7, t:'CONTAINER', idx:[0,1]}, {x:3, y:7, t:'FULL'}, {x:5, y:7, t:'CONTAINER', idx:[3,6]}, {x:6, y:7, t:'BLK_B'},{x:9, y:7, t:'BLK_B'}, {x:4, y:8, t:'FULL'}, {x:9, y:8, t:'GRY_L'}, {x:1, y:9, t:'BLK_T'}, {x:3, y:9, t:'CONTAINER', idx:[0]},{x:4, y:9, t:'FULL'}, {x:2, y:10, t:'CONTAINER', idx:[0]}],
            crossroads: [{x:8, y:2, t:'BLK_L'}, {x:4, y:3, t:'GRY_R'}, {x:8, y:3, t:'FULL'}, {x:9, y:3, t:'GRY_T'}, {x:0, y:4, t:'CONTAINER', idx:[7,8]},{x:1, y:4, t:'BLK_B'}, {x:2, y:4, t:'BLK_B'}, {x:3, y:4, t:'FULL'}, {x:4, y:4, t:'FULL'}, {x:5, y:4, t:'CONTAINER', idx:[7,8]},{x:6, y:4, t:'CONTAINER', idx:[5,8]}, {x:8, y:4, t:'GRY_R'}, {x:4, y:5, t:'CONTAINER', idx:[8]}, {x:7, y:6, t:'CONTAINER', idx:[0]},{x:3, y:7, t:'GRY_L'}, {x:5, y:7, t:'CONTAINER', idx:[0,3]}, {x:6, y:7, t:'CONTAINER', idx:[0,1]}, {x:7, y:7, t:'FULL'},{x:8, y:7, t:'FULL'}, {x:9, y:7, t:'BLK_T'}, {x:10, y:7, t:'BLK_T'}, {x:11, y:7, t:'CONTAINER', idx:[0,1]}, {x:2, y:8, t:'GRY_B'},{x:3, y:8, t:'FULL'}, {x:7, y:8, t:'GRY_L'}, {x:3, y:9, t:'BLK_R'}],
            alley: [{x:5, y:2, t:'BLK_B'}, {x:10, y:2, t:'GRY_L'}, {x:3, y:3, t:'GRY_L'}, {x:4, y:3, t:'CONTAINER', idx:[5,8]}, {x:6, y:3, t:'CONTAINER', idx:[8]},{x:0, y:4, t:'BLK_T'}, {x:2, y:4, t:'CONTAINER', idx:[6,7]}, {x:4, y:4, t:'BLK_T'}, {x:6, y:4, t:'FULL'}, {x:8, y:4, t:'FULL'},{x:9, y:4, t:'GRY_T'}, {x:10, y:4, t:'CONTAINER', idx:[8]}, {x:3, y:5, t:'CONTAINER', idx:[5,8]}, {x:7, y:5, t:'FULL'},{x:11, y:5, t:'CONTAINER', idx:[0]}, {x:0, y:6, t:'CONTAINER', idx:[8]}, {x:4, y:6, t:'FULL'}, {x:8, y:6, t:'CONTAINER', idx:[0,3]},{x:1, y:7, t:'CONTAINER', idx:[0]}, {x:2, y:7, t:'GRY_B'}, {x:3, y:7, t:'FULL'}, {x:5, y:7, t:'FULL'}, {x:7, y:7, t:'BLK_B'},{x:9, y:7, t:'CONTAINER', idx:[1,2]}, {x:11, y:7, t:'BLK_B'}, {x:5, y:8, t:'CONTAINER', idx:[0]}, {x:7, y:8, t:'CONTAINER', idx:[0,3]},{x:8, y:8, t:'GRY_R'}, {x:1, y:9, t:'GRY_R'}, {x:6, y:9, t:'BLK_T'}]
        };

        function initMapStorage() {
            const stored = localStorage.getItem('obsidian_saved_maps_v2');
            if (stored) { try { savedMaps = JSON.parse(stored); } catch(e) { console.error(e); savedMaps = {}; } }
            refreshMapDropdown();
        }

        function refreshMapDropdown() {
            const options = mapSelector.querySelectorAll('option');
            mapSelector.innerHTML = ''; mapSelector.appendChild(options[0]); mapSelector.appendChild(options[1]);
            Object.keys(savedMaps).sort().forEach(name => {
                const opt = document.createElement('option'); opt.value = name; opt.textContent = name; mapSelector.appendChild(opt);
            });
        }

        function updateLOS() {
            document.querySelectorAll('.subcell').forEach(s => s.classList.remove('sub-visible', 'in-range'));
            let origin = null;
            if (simSegments.length > 0) origin = simSegments[simSegments.length - 1].end;
            else if (startPoint) origin = startPoint;

            if (isRangeMode && origin) { calculateRangeArea(origin); calculateLOS(origin); } 
            else if (isLOSActive && origin) { calculateLOS(origin); }
        }

        function calculateRangeArea(origin) {
            for(let y=0; y<currentGridHeight; y++) {
                for(let x=0; x<currentGridWidth; x++) {
                    const dist = Math.abs(x - origin.x) + Math.abs(y - origin.y);
                    if (dist <= rangeValue) {
                        const idx = y * currentGridWidth + x; const tile = tiles[idx];
                        for(let i=0; i<9; i++) tile.children[i+1].classList.add('in-range');
                    }
                }
            }
        }

        function calculateLOS(origin) {
            const tileX = origin.x * 3; const tileY = origin.y * 3; const inset = 0.01;
            const originPoints = [ {x: tileX + 1.5, y: tileY + 1.5}, {x: tileX + inset, y: tileY + inset}, {x: tileX + 3 - inset, y: tileY + inset}, {x: tileX + inset, y: tileY + 3 - inset}, {x: tileX + 3 - inset, y: tileY + 3 - inset} ];
            const blockers = [];
            for(let y=0; y<currentGridHeight; y++) {
                for(let x=0; x<currentGridWidth; x++) {
                    const idx = y * currentGridWidth + x; const tile = tiles[idx];
                    for(let i=0; i<9; i++) {
                        if(tile.children[i+1].classList.contains('obs-full')) {
                            blockers.push({ x: x * 3 + (i % 3), y: y * 3 + Math.floor(i / 3), w: 1, h: 1, tx: x, ty: y });
                        }
                    }
                }
            }
            const validOrigins = [];
            for (let op of originPoints) {
                let insideWall = false;
                for (let b of blockers) { if (op.x >= b.x && op.x <= b.x + 1 && op.y >= b.y && op.y <= b.y + 1) { insideWall = true; break; } }
                if (!insideWall) validOrigins.push(op);
            }
            if (validOrigins.length === 0) return;

            const gridW = currentGridWidth * 3; const gridH = currentGridHeight * 3;
            for (let gy = 0; gy < gridH; gy++) {
                for (let gx = 0; gx < gridW; gx++) {
                    const tx = Math.floor(gx / 3); const ty = Math.floor(gy / 3); const tileIdx = ty * currentGridWidth + tx; const tile = tiles[tileIdx]; const subIdx = (gy % 3) * 3 + (gx % 3);
                    if (!tile || tile.children[subIdx + 1].classList.contains('obs-full')) continue;
                    const tInset = 0.1;
                    const targetPoints = [ {x: gx + 0.5, y: gy + 0.5}, {x: gx + tInset, y: gy + tInset}, {x: gx + 1-tInset, y: gy + tInset}, {x: gx + tInset, y: gy + 1-tInset}, {x: gx + 1-tInset, y: gy + 1-tInset} ];
                    let isVisible = false;
                    outerCheck:
                    for (let op of validOrigins) {
                        for (let tp of targetPoints) {
                            if (!isRayBlocked(op.x, op.y, tp.x, tp.y, blockers)) { isVisible = true; break outerCheck; }
                        }
                    }
                    if (isVisible) tile.children[subIdx + 1].classList.add('sub-visible');
                }
            }
        }

        function isRayBlocked(x0, y0, x1, y1, blockers) {
            const tSubX = Math.floor(x1); const tSubY = Math.floor(y1);
            for (let b of blockers) {
                if(b.x === tSubX && b.y === tSubY) continue;
                if(lineIntersectsBox(x0, y0, x1, y1, b.x, b.y, 1, 1)) return true;
            }
            return false;
        }

        function lineIntersectsBox(x1, y1, x2, y2, bx, by, bw, bh) {
            const minX = bx, minY = by, maxX = bx + bw, maxY = by + bh;
            const dx = x2 - x1, dy = y2 - y1;
            let t0 = 0.0, t1 = 1.0;
            const p = [-dx, dx, -dy, dy]; const q = [x1 - minX, maxX - x1, y1 - minY, maxY - y1];
            for(let i=0; i<4; i++) {
                if(p[i] === 0) { if(q[i] < 0) return false; } 
                else {
                    const t = q[i] / p[i];
                    if(p[i] < 0) { if(t > t1) return false; if(t > t0) t0 = t; } 
                    else { if(t < t0) return false; if(t < t1) t1 = t; }
                }
            }
            return t0 <= t1;
        }

        function createGrid() {
            container.style.gridTemplateColumns = `repeat(${currentGridWidth}, 40px)`;
            container.style.gridTemplateRows = `repeat(${currentGridHeight}, 40px)`;
            container.innerHTML = ''; tiles = [];
            for (let y = 0; y < currentGridHeight; y++) {
                for (let x = 0; x < currentGridWidth; x++) {
                    const tile = document.createElement('div'); tile.classList.add('tile'); tile.dataset.x = x; tile.dataset.y = y;
                    const label = document.createElement('span'); label.classList.add('coord-label'); label.textContent = `${x},${y}`; tile.appendChild(label);
                    for (let i = 0; i < 9; i++) { const sub = document.createElement('div'); sub.classList.add('subcell'); sub.dataset.idx = i; tile.appendChild(sub); }
                    tile.addEventListener('click', (e) => { if (isEditorMode) handleEditorClick(e, x, y); else if (isSimMode) handleSimClick(x, y); else handleMeasureClick(x, y); });
                    tile.addEventListener('mouseenter', (e) => { if (isEditorMode && e.buttons === 1) handleEditorClick(e, x, y); else if (!isEditorMode) handleSimHover(x, y); });
                    container.appendChild(tile); tiles.push(tile);
                }
            }
            updateAreaOverlay(); updateLOS();
        }

        function toggleEditor() {
            isEditorMode = !isEditorMode; const panel = document.getElementById('editor-panel'); const btn = document.getElementById('btn-editor');
            if (isEditorMode) { panel.classList.add('visible'); btn.classList.add('active'); infoPanel.classList.add('edit-mode'); resetMeasureState(); rangeText.textContent = "ì—ë””í„° ëª¨ë“œ"; rangeText.style.color = "#4fc3f7"; } 
            else { panel.classList.remove('visible'); btn.classList.remove('active'); infoPanel.classList.remove('edit-mode'); rangeText.textContent = "ì¼ë°˜ ëª¨ë“œ"; }
        }
        function selectTool(tool) { currentTool = tool; document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('selected')); event.target.classList.add('selected'); }
        function handleEditorClick(e, x, y) { const tile = tiles[y * currentGridWidth + x]; if(currentTool === 'ERASER') renderTileObject(tile, {t:null}); else renderTileObject(tile, {t:currentTool}); }
        function renderTileObject(tile, data) {
            const subcells = tile.querySelectorAll('.subcell'); subcells.forEach(c => c.className = 'subcell');
            const type = data.t; if(!type) return;
            if(type === 'FULL') subcells.forEach(c => c.classList.add('obs-full'));
            else if(type === 'BLK_T') [0,1,2].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'BLK_B') [6,7,8].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'BLK_L') [0,3,6].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'BLK_R') [2,5,8].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'BLK_M_H') [3,4,5].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'BLK_M_V') [1,4,7].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'GRY_T') [0,1,2].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if(type === 'GRY_B') [6,7,8].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if(type === 'GRY_L') [0,3,6].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if(type === 'GRY_R') [2,5,8].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if(type === 'GRY_M_H') [3,4,5].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if(type === 'GRY_M_V') [1,4,7].forEach(i=>subcells[i].classList.add('obs-partial'));
        }
        
        function applySymmetry(mode) {
             const W = currentGridWidth; const H = currentGridHeight; const halfH = Math.ceil(H/2); const halfW = Math.ceil(W/2);
             let startX=0, endX=W, startY=0, endY=H;
             if(mode==='T2B') endY=halfH; else if(mode==='B2T') startY=Math.floor(H/2); else if(mode==='L2R') endX=halfW; else if(mode==='R2L') startX=Math.floor(W/2);
             const updates = [];
             for(let y=startY; y<endY; y++) {
                 for(let x=startX; x<endX; x++) {
                     const srcIdx = y*W+x; const srcTile=tiles[srcIdx]; const tx=(W-1)-x; const ty=(H-1)-y; const cellData=[];
                     srcTile.querySelectorAll('.subcell').forEach(c=>{ if(c.classList.contains('obs-full')) cellData.push('obs-full'); else if(c.classList.contains('obs-partial')) cellData.push('obs-partial'); else cellData.push(null); });
                     updates.push({tx,ty,cellData});
                 }
             }
             updates.forEach(u=>{ const t=tiles[u.ty*W+u.tx]; if(!t) return; for(let i=0;i<9;i++) { t.children[i+1].className='subcell'; if(u.cellData[i]) t.children[(8-i)+1].classList.add(u.cellData[i]); } });
             updateLOS();
        }

        function toggleSimulator() {
            isSimMode = !isSimMode; isRangeMode = false; document.getElementById('btn-range').classList.remove('active'); const btn = document.getElementById('btn-sim');
            if(isSimMode) { btn.classList.add('active'); simControls.classList.add('visible'); infoPanel.classList.add('sim-mode'); infoPanel.classList.remove('range-mode'); resetSimState(); rangeText.textContent = "ì‹œë®¬ë ˆì´í„° ëŒ€ê¸°"; rangeText.style.color = "#4fc3f7"; } 
            else { btn.classList.remove('active'); simControls.classList.remove('visible'); infoPanel.classList.remove('sim-mode'); resetMeasureState(); }
        }
        
        function toggleRangeMode() {
            isRangeMode = !isRangeMode; isSimMode = false; document.getElementById('btn-sim').classList.remove('active'); const btn = document.getElementById('btn-range');
            if(isRangeMode) { btn.classList.add('active'); simControls.classList.add('visible'); infoPanel.classList.add('range-mode'); infoPanel.classList.remove('sim-mode'); rangeText.textContent = "ì‚¬ê±°ë¦¬ í™•ì¸"; resetMeasureState(); } 
            else { btn.classList.remove('active'); simControls.classList.remove('visible'); infoPanel.classList.remove('range-mode'); resetMeasureState(); rangeText.textContent = "ìœ„ì¹˜ ì„ íƒ"; rangeText.style.color = "#4fc3f7"; }
            updateLOS();
        }

        function changeVal(delta) {
            if(isSimMode) { maxTicks+=delta; if(maxTicks<1) maxTicks=1; document.getElementById('tick-display').textContent = maxTicks; resetSimState(); } 
            else if(isRangeMode) { rangeValue+=delta; if(rangeValue<1) rangeValue=1; document.getElementById('tick-display').textContent = rangeValue; updateLOS(); }
        }

        function resetMeasureState() { startPoint = null; isLocked = false; lockedAxis = null; tiles.forEach(t => t.classList.remove('start', 'path', 'target', 'locked')); updateLOS(); }

        function handleMeasureClick(x, y) {
            if (!startPoint) { startPoint = { x, y }; tiles[y * currentGridWidth + x].classList.add('start'); handleSimHover(x, y); updateLOS(); return; }
            if (isRangeMode) { resetMeasureState(); startPoint = {x, y}; tiles[y * currentGridWidth + x].classList.add('start'); updateLOS(); return; }
            if (!isLocked) { isLocked = true; return; }
            resetMeasureState();
        }

        function handleSimHover(tx, ty) {
            if (isRangeMode) return;
            if (isLocked || !startPoint) return;
            tiles.forEach(t => t.classList.remove('path', 'target'));
            tiles[ty * currentGridWidth + tx].classList.add('target');
            
            const sx = startPoint.x; const sy = startPoint.y;
            if (lockedAxis === null && (tx !== sx || ty !== sy)) {
                if (Math.abs(tx - sx) > Math.abs(ty - sy)) lockedAxis = 'x'; else lockedAxis = 'y';
            }
            if (tx === sx && ty === sy) lockedAxis = null;
            
            let cx, cy;
            if (lockedAxis === 'y') { cx = sx; cy = ty; } else { cx = tx; cy = sy; }

            const cells = [];
            let xDir = cx > sx ? 1 : -1; let yDir = cy > sy ? 1 : -1;
            
            for(let i=1; i<=Math.abs(cx-sx); i++) cells.push({x:sx+i*xDir, y:sy});
            for(let i=1; i<=Math.abs(cy-sy); i++) cells.push({x:cx, y:sy+i*yDir});
            xDir = tx > cx ? 1 : -1; yDir = ty > cy ? 1 : -1;
            for(let i=1; i<=Math.abs(tx-cx); i++) cells.push({x:cx+i*xDir, y:cy});
            for(let i=1; i<=Math.abs(ty-cy); i++) cells.push({x:cx, y:cy+i*yDir});

            cells.forEach(c => { const idx = c.y * currentGridWidth + c.x; if(tiles[idx]) tiles[idx].classList.add('path'); });
            const distX = Math.abs(tx - sx); const distY = Math.abs(ty - sy);
            rangeText.innerHTML = `ê±°ë¦¬: ${distX + distY} (ê°€ë¡œ${distX}+ì„¸ë¡œ${distY})`;
            rangeText.style.color = "#4fc3f7";
        }
        
        function toggleArea1() { isArea1Active=!isArea1Active; updateAreaOverlay(); document.getElementById('btn-area1').classList.toggle('active'); }
        function toggleArea2() { isArea2Active=!isArea2Active; updateAreaOverlay(); document.getElementById('btn-area2').classList.toggle('active'); }

        createGrid();
        initMapStorage();
        loadMap('hotspot');
    </script>
</body>
</html>
