<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, orientation=landscape">
    
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#1e1e1e">
    <link rel="apple-touch-icon" href="icon-192.png">

    <title>Obsidian Protocol Map Tool v54 (Final Fixed)</title>
    <style>
        /* Ïä§ÌÉÄÏùºÏùÄ Í∏∞Ï°¥ v54ÏôÄ ÎèôÏùº (Îã§ÌÅ¨ ÌÖåÎßà + ÏãúÏïº Î≤ÑÍ∑∏ ÏàòÏ†ï Ïä§ÌÉÄÏùº) */
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #1e1e1e;
            color: #e0e0e0;
            margin: 0; padding: 0;
            width: 100vw; height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: row;
        }

        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
            position: relative;
        }

        .ui-header {
            background-color: #252525;
            padding: 8px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: center;
            flex-shrink: 0;
            z-index: 10;
        }

        .controls { 
            display: flex; gap: 6px; 
            flex-wrap: nowrap; overflow-x: auto; 
            align-items: center; padding-bottom: 2px;
            -webkit-overflow-scrolling: touch;
        }
        .controls::-webkit-scrollbar { display: none; }

        #grid-wrapper {
            flex: 1;
            overflow: auto;
            position: relative;
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #grid-container {
            display: grid; gap: 1px;
            background-color: #444; border: 2px solid #555;
            padding: 1px;
            touch-action: none;
            transform-origin: center top;
        }

        .tile {
            width: 40px; height: 40px; background-color: #fff;
            display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr);
            position: relative;
        }

        .bottom-ui {
            background-color: #1e1e1e;
            border-top: 1px solid #333;
            padding: 10px;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            flex-shrink: 0;
            height: 90px;
        }

        #info-panel {
            flex: 1;
            background: #2d2d2d;
            padding: 5px 15px;
            border-radius: 8px;
            border: 2px solid #444;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            font-size: 0.9em;
            position: relative;
            transition: all 0.3s;
        }
        #info-panel.edit-mode { border-color: #009688; background-color: #004d40; }
        #info-panel.sim-mode { border-color: #9c27b0; background-color: #4a148c; }
        
        #info-panel.range-mode { 
            border-color: #ff9800; 
            background-color: #111; 
            box-shadow: inset 0 0 20px rgba(255, 152, 0, 0.1);
        }
        #info-panel.range-mode #range-text { color: #ffb74d; }
        #info-panel.range-mode #detail-text { color: #ffe0b2; }

        #range-text { font-size: 1.2em; font-weight: bold; color: #4fc3f7; margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #status-text { font-size: 0.8em; color: #888; }

        .legend-box {
            position: absolute; right: 10px; top: 50%; transform: translateY(-50%);
            display: flex; gap: 8px; font-size: 0.7em; color: #ccc;
        }
        .legend-item { display: flex; align-items: center; gap: 3px; }
        .legend-color { width: 10px; height: 10px; border-radius: 2px; }

        #sim-controls {
            display: none; align-items: center; gap: 8px;
            background: #333; padding: 5px 10px;
            border-radius: 20px; border: 1px solid #555;
            height: 100%;
        }
        #sim-controls.visible { display: flex; }

        button {
            padding: 8px 12px;
            background: #3a3a3a; color: white;
            border: 1px solid #555; border-radius: 4px;
            font-weight: 600; white-space: nowrap; font-size: 0.85em;
        }
        button.active { background-color: #2e7d32; border-color: #1b5e20; }
        .tick-btn { width: 40px; height: 40px; border-radius: 50%; font-size: 1.5em; padding:0; display:flex; align-items:center; justify-content:center;}
        
        #btn-range { background-color: #ff9800; color: black; border-color: #f57c00; }
        #btn-range.active { background-color: #e65100; color: white; box-shadow: 0 0 10px #ff9800; }

        #editor-panel {
            position: absolute; top: 0; right: 0; bottom: 0;
            width: 280px; background: #222;
            border-left: 1px solid #444; padding: 15px;
            display: flex; flex-direction: column; overflow-y: auto;
            transform: translateX(100%); transition: transform 0.3s;
            z-index: 100; box-shadow: -5px 0 15px rgba(0,0,0,0.5);
        }
        #editor-panel.visible { transform: translateX(0); }

        .editor-section { margin-bottom: 20px; }
        .editor-title { font-weight: bold; margin-bottom: 8px; color: #fff; border-bottom: 1px solid #555; padding-bottom: 5px; font-size: 0.9em; }
        .preset-group { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
        .preset-group button { width: 100%; font-size: 0.8em; padding: 10px; }
        .tool-btn { width: 100%; text-align: left; margin-bottom: 5px; padding: 12px; background: #333; border: 1px solid #444; color: #ccc;}
        .tool-btn.selected { background: #009688; color: white; }

        /* ÌÉÄÏùº Ïä§ÌÉÄÏùº */
        .subcell.sub-visible { background-color: rgba(76, 175, 80, 0.6) !important; box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.15); }
        .subcell.in-range { background-color: rgba(255, 235, 59, 0.25); box-shadow: inset 0 0 0 1px rgba(255, 235, 59, 0.5); }
        .subcell.sub-visible.in-range { background-color: rgba(0, 191, 255, 0.65) !important; box-shadow: inset 0 0 0 1px #fff; }
        
        .subcell.obs-full { background-color: #111; } 
        .subcell.obs-partial { background-color: #777; background-image: repeating-linear-gradient(45deg, #666, #666 2px, #777 2px, #777 4px); }
        .subcell.obs-weak { background-color: #009688; }
        .tile.start::after { content: ''; position: absolute; inset: 0; background-color: rgba(33, 150, 243, 0.6); border: 2px solid #2196f3; z-index: 5; pointer-events: none;}
        .tile.target::before { content: ''; position: absolute; inset: 0; background-color: rgba(244, 67, 54, 0.5); border: 2px solid #e53935; z-index: 6; pointer-events: none;}
        .tile.path::before { content: ''; position: absolute; inset: 2px; background-color: rgba(255, 235, 59, 0.3); border: 2px dashed #fdd835; z-index: 4; border-radius: 4px; pointer-events: none;}

        .l-green { background-color: rgba(76, 175, 80, 0.8); }
        .l-yellow { background-color: rgba(255, 235, 59, 0.5); border: 1px dashed #fff; }
        .l-blue { background-color: rgba(0, 191, 255, 0.8); }
        
        @media screen and (orientation: portrait) {
            body::after {
                content: "Í∞ÄÎ°ú Î™®ÎìúÎ°ú ÌöåÏ†ÑÌï¥Ï£ºÏÑ∏Ïöî üîÑ";
                position: fixed; top:0; left:0; right:0; bottom:0;
                background: rgba(0,0,0,0.9); z-index: 9999;
                display: flex; justify-content: center; align-items: center;
                color: white; font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <div class="main-area">
        <div class="ui-header">
            <div class="controls">
                <select id="map-selector" onchange="handleMapSelect()">
                    <option value="" disabled selected>Îßµ ÏÑ†ÌÉù</option>
                    <option value="__NEW__">ÏÉà Îßµ</option>
                </select>
                <div style="width:1px; height:20px; background:#555; margin:0 5px;"></div>
                <button id="btn-editor" onclick="toggleEditor()">üõ† Ìé∏Ïßë</button>
                <button id="btn-area1" onclick="toggleArea1()">A1</button>
                <button id="btn-area2" onclick="toggleArea2()">A2</button>
                <button id="btn-sim" onclick="toggleSimulator()">üé≤ Ïù¥Îèô</button>
                <button id="btn-los" onclick="toggleLOS()">üëÅ LOS</button>
                <button id="btn-range" onclick="toggleRangeMode()">üìè ÏÇ¨Í±∞Î¶¨</button>
            </div>
        </div>

        <div id="grid-wrapper">
            <div id="grid-container"></div>
        </div>

        <div class="bottom-ui">
            <div id="sim-controls">
                <button class="tick-btn" onclick="changeVal(-1)">-</button>
                <span id="tick-display" style="font-weight:bold; color: #fff; font-size:1.2em;">3</span>
                <button class="tick-btn" onclick="changeVal(1)">+</button>
            </div>

            <div id="info-panel">
                <div id="range-text">Ï§ÄÎπÑ ÏôÑÎ£å</div>
                <div id="detail-text">ÏùºÎ∞ò Î™®Îìú</div>
                <div id="status-text">ÏãúÏûë ÏßÄÏ†êÏùÑ ÌÑ∞ÏπòÌïòÏÑ∏Ïöî</div>
                
                <div class="legend-box">
                    <div class="legend-item"><div class="legend-color l-green"></div>ÏãúÏïº</div>
                    <div class="legend-item"><div class="legend-color l-yellow"></div>ÏÇ¨Í±∞Î¶¨</div>
                    <div class="legend-item"><div class="legend-color l-blue"></div>Í≥µÍ≤©Í∞ÄÎä•</div>
                </div>
            </div>
        </div>
    </div>

    <div id="editor-panel">
        <button onclick="toggleEditor()" style="margin-bottom:10px; background:#444;">‚ùå Îã´Í∏∞</button>
        <div class="editor-section">
            <div class="editor-title">Í∏∞Î≥∏ ÎèÑÍµ¨</div>
            <button class="tool-btn selected" onclick="selectTool('ERASER')">‚¨ú ÏßÄÏö∞Í∞ú</button>
            <button class="tool-btn" onclick="selectTool('CUSTOM_DRAW')">‚úèÔ∏è ÏßÅÏ†ë Í∑∏Î¶¨Í∏∞</button>
            <button class="tool-btn" onclick="selectTool('FULL')">‚¨õ 3x3 Î∞ïÏä§</button>
        </div>
        <div class="editor-section">
            <div class="editor-title">üîÑ ÎåÄÏπ≠ Î≥µÏÇ¨</div>
            <div class="preset-group">
                <button onclick="applySymmetry('T2B')">‚¨Ü‚û°‚¨á</button>
                <button onclick="applySymmetry('B2T')">‚¨á‚û°‚¨Ü</button>
                <button onclick="applySymmetry('L2R')">‚¨Ö‚û°‚û°</button>
                <button onclick="applySymmetry('R2L')">‚û°‚û°‚¨Ö</button>
            </div>
        </div>
        <div class="editor-section">
            <div class="editor-title">Îßµ Í¥ÄÎ¶¨</div>
            <button class="tool-btn" onclick="saveMapAs()">üíæ Ï†ÄÏû•</button>
            <button class="tool-btn" onclick="deleteCurrentMap()" style="background:#c62828;">üóë ÏÇ≠Ï†ú</button>
            <button class="tool-btn" onclick="clearMapData()" style="background:#d32f2f;">‚ö° Ï¥àÍ∏∞Ìôî</button>
        </div>
    </div>

    <script>
        // ‚úÖ [ÌïÑÏàò] PWA ÏÑúÎπÑÏä§ ÏõåÏª§ Îì±Î°ù ÏΩîÎìú (Ïù¥Í≤å ÏûàÏñ¥Ïïº Ïï± ÏÑ§ÏπòÎê®!)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(() => console.log('Service Worker Registered'))
                    .catch((err) => console.log('SW Failed', err));
            });
        }

        const container = document.getElementById('grid-container');
        const infoPanel = document.getElementById('info-panel');
        const rangeText = document.getElementById('range-text');
        const detailText = document.getElementById('detail-text');
        const statusText = document.getElementById('status-text');
        const editorPanel = document.getElementById('editor-panel');
        const simControls = document.getElementById('sim-controls');
        const tickDisplay = document.getElementById('tick-display');
        const mapSelector = document.getElementById('map-selector');
        
        let tiles = []; 
        let isEditorMode = false;
        let isSimMode = false;
        let isRangeMode = false; 
        let isArea1Active = false; 
        let isArea2Active = false;
        let isLOSActive = false;
        let isMouseDown = false;
        let currentTool = 'ERASER'; 
        
        let currentGridWidth = 12;
        let currentGridHeight = 12;
        
        let startPoint = null;
        let isLocked = false;
        let maxTicks = 3;
        let rangeValue = 4; 
        let simSegments = []; 
        let lockedAxis = null; 
        let currentEditingMapName = null;
        let savedMaps = {};

        let isDragging = false;
        container.addEventListener('touchmove', handleTouchMove, { passive: false });
        container.addEventListener('touchstart', (e) => { isDragging = true; }, { passive: true });
        container.addEventListener('touchend', (e) => { isDragging = false; }, { passive: true });

        function handleTouchMove(e) {
            e.preventDefault(); 
            if (!isDragging) return;
            const touch = e.touches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            if (target) {
                const tile = target.closest('.tile');
                if (tile) {
                    const x = parseInt(tile.dataset.x);
                    const y = parseInt(tile.dataset.y);
                    if (isEditorMode) renderTileObject(tile, {t: currentTool});
                    else if ((isSimMode || !isEditorMode) && startPoint) handleMeasureHover(x, y);
                }
            }
        }

        const defaultMaps = {
            hotspot: [{x:9, y:1, t:'CONTAINER', idx:[8]}, {x:7, y:2, t:'FULL'}, {x:8, y:2, t:'CONTAINER', idx:[2]}, {x:10, y:2, t:'BLK_B'},{x:2, y:3, t:'GRY_R'}, {x:7, y:3, t:'FULL'}, {x:2, y:4, t:'BLK_T'}, {x:5, y:4, t:'BLK_T'}, {x:6, y:4, t:'CONTAINER', idx:[2,5]},{x:8, y:4, t:'FULL'}, {x:9, y:4, t:'CONTAINER', idx:[7,8]}, {x:10, y:4, t:'CONTAINER', idx:[3,6]}, {x:4, y:5, t:'CONTAINER', idx:[2]},{x:8, y:5, t:'GRY_R'}, {x:3, y:6, t:'GRY_L'}, {x:7, y:6, t:'CONTAINER', idx:[6]}, {x:1, y:7, t:'CONTAINER', idx:[2,5]},{x:2, y:7, t:'CONTAINER', idx:[0,1]}, {x:3, y:7, t:'FULL'}, {x:5, y:7, t:'CONTAINER', idx:[3,6]}, {x:6, y:7, t:'BLK_B'},{x:9, y:7, t:'BLK_B'}, {x:4, y:8, t:'FULL'}, {x:9, y:8, t:'GRY_L'}, {x:1, y:9, t:'BLK_T'}, {x:3, y:9, t:'CONTAINER', idx:[0]},{x:4, y:9, t:'FULL'}, {x:2, y:10, t:'CONTAINER', idx:[0]}],
            crossroads: [{x:8, y:2, t:'BLK_L'}, {x:4, y:3, t:'GRY_R'}, {x:8, y:3, t:'FULL'}, {x:9, y:3, t:'GRY_T'}, {x:0, y:4, t:'CONTAINER', idx:[7,8]},{x:1, y:4, t:'BLK_B'}, {x:2, y:4, t:'BLK_B'}, {x:3, y:4, t:'FULL'}, {x:4, y:4, t:'FULL'}, {x:5, y:4, t:'CONTAINER', idx:[7,8]},{x:6, y:4, t:'CONTAINER', idx:[5,8]}, {x:8, y:4, t:'GRY_R'}, {x:4, y:5, t:'CONTAINER', idx:[8]}, {x:7, y:6, t:'CONTAINER', idx:[0]},{x:3, y:7, t:'GRY_L'}, {x:5, y:7, t:'CONTAINER', idx:[0,3]}, {x:6, y:7, t:'CONTAINER', idx:[0,1]}, {x:7, y:7, t:'FULL'},{x:8, y:7, t:'FULL'}, {x:9, y:7, t:'BLK_T'}, {x:10, y:7, t:'BLK_T'}, {x:11, y:7, t:'CONTAINER', idx:[0,1]}, {x:2, y:8, t:'GRY_B'},{x:3, y:8, t:'FULL'}, {x:7, y:8, t:'GRY_L'}, {x:3, y:9, t:'BLK_R'}],
            alley: [{x:5, y:2, t:'BLK_B'}, {x:10, y:2, t:'GRY_L'}, {x:3, y:3, t:'GRY_L'}, {x:4, y:3, t:'CONTAINER', idx:[5,8]}, {x:6, y:3, t:'CONTAINER', idx:[8]},{x:0, y:4, t:'BLK_T'}, {x:2, y:4, t:'CONTAINER', idx:[6,7]}, {x:4, y:4, t:'BLK_T'}, {x:6, y:4, t:'FULL'}, {x:8, y:4, t:'FULL'},{x:9, y:4, t:'GRY_T'}, {x:10, y:4, t:'CONTAINER', idx:[8]}, {x:3, y:5, t:'CONTAINER', idx:[5,8]}, {x:7, y:5, t:'FULL'},{x:11, y:5, t:'CONTAINER', idx:[0]}, {x:0, y:6, t:'CONTAINER', idx:[8]}, {x:4, y:6, t:'FULL'}, {x:8, y:6, t:'CONTAINER', idx:[0,3]},{x:1, y:7, t:'CONTAINER', idx:[0]}, {x:2, y:7, t:'GRY_B'}, {x:3, y:7, t:'FULL'}, {x:5, y:7, t:'FULL'}, {x:7, y:7, t:'BLK_B'},{x:9, y:7, t:'CONTAINER', idx:[1,2]}, {x:11, y:7, t:'BLK_B'}, {x:5, y:8, t:'CONTAINER', idx:[0]}, {x:7, y:8, t:'CONTAINER', idx:[0,3]},{x:8, y:8, t:'GRY_R'}, {x:1, y:9, t:'GRY_R'}, {x:6, y:9, t:'BLK_T'}]
        };

        function initMapStorage() {
            const stored = localStorage.getItem('obsidian_saved_maps_v2');
            if (stored) {
                try { savedMaps = JSON.parse(stored); } 
                catch(e) { console.error(e); savedMaps = {}; }
            }
            refreshMapDropdown();
        }

        function refreshMapDropdown() {
            const options = mapSelector.querySelectorAll('option');
            mapSelector.innerHTML = '';
            mapSelector.appendChild(options[0]);
            mapSelector.appendChild(options[1]);
            Object.keys(savedMaps).sort().forEach(name => {
                const opt = document.createElement('option');
                opt.value = name; opt.textContent = name;
                mapSelector.appendChild(opt);
            });
        }

        function updateLOS() {
            document.querySelectorAll('.subcell').forEach(s => s.classList.remove('sub-visible', 'in-range'));
            let origin = null;
            if (simSegments.length > 0) origin = simSegments[simSegments.length - 1].end;
            else if (startPoint) origin = startPoint;

            if (isRangeMode && origin) {
                calculateRangeArea(origin);
                calculateLOS(origin); 
            } else if (isLOSActive && origin) {
                calculateLOS(origin);
            }
        }

        function calculateRangeArea(origin) {
            for(let y=0; y<currentGridHeight; y++) {
                for(let x=0; x<currentGridWidth; x++) {
                    const dist = Math.abs(x - origin.x) + Math.abs(y - origin.y);
                    if (dist <= rangeValue) {
                        const idx = y * currentGridWidth + x;
                        const tile = tiles[idx];
                        for(let i=0; i<9; i++) tile.children[i+1].classList.add('in-range');
                    }
                }
            }
        }

        function calculateLOS(origin) {
            const tileX = origin.x * 3;
            const tileY = origin.y * 3;
            const inset = 0.01;
            const originPoints = [
                {x: tileX + 1.5, y: tileY + 1.5},
                {x: tileX + inset, y: tileY + inset},
                {x: tileX + 3 - inset, y: tileY + inset},
                {x: tileX + inset, y: tileY + 3 - inset},
                {x: tileX + 3 - inset, y: tileY + 3 - inset}
            ];

            const blockers = [];
            for(let y=0; y<currentGridHeight; y++) {
                for(let x=0; x<currentGridWidth; x++) {
                    const idx = y * currentGridWidth + x;
                    const tile = tiles[idx];
                    for(let i=0; i<9; i++) {
                        if(tile.children[i+1].classList.contains('obs-full')) {
                            blockers.push({ x: x * 3 + (i % 3), y: y * 3 + Math.floor(i / 3), w: 1, h: 1, tx: x, ty: y });
                        }
                    }
                }
            }

            const validOrigins = [];
            for (let op of originPoints) {
                let insideWall = false;
                for (let b of blockers) {
                    if (op.x >= b.x && op.x <= b.x + 1 && op.y >= b.y && op.y <= b.y + 1) { 
                        insideWall = true; 
                        break; 
                    }
                }
                if (!insideWall) validOrigins.push(op);
            }
            if (validOrigins.length === 0) return;

            const gridW = currentGridWidth * 3;
            const gridH = currentGridHeight * 3;

            for (let gy = 0; gy < gridH; gy++) {
                for (let gx = 0; gx < gridW; gx++) {
                    const tx = Math.floor(gx / 3);
                    const ty = Math.floor(gy / 3);
                    const tileIdx = ty * currentGridWidth + tx;
                    const tile = tiles[tileIdx];
                    const subIdx = (gy % 3) * 3 + (gx % 3);
                    
                    if (!tile || tile.children[subIdx + 1].classList.contains('obs-full')) continue;

                    const tInset = 0.1;
                    const targetPoints = [
                        {x: gx + 0.5, y: gy + 0.5},
                        {x: gx + tInset, y: gy + tInset},
                        {x: gx + 1-tInset, y: gy + tInset},
                        {x: gx + tInset, y: gy + 1-tInset},
                        {x: gx + 1-tInset, y: gy + 1-tInset}
                    ];
                    
                    let isVisible = false;
                    outerCheck:
                    for (let op of validOrigins) {
                        for (let tp of targetPoints) {
                            if (!isRayBlocked(op.x, op.y, tp.x, tp.y, blockers)) {
                                isVisible = true;
                                break outerCheck;
                            }
                        }
                    }
                    if (isVisible) tile.children[subIdx + 1].classList.add('sub-visible');
                }
            }
        }

        function isRayBlocked(x0, y0, x1, y1, blockers) {
            const tSubX = Math.floor(x1);
            const tSubY = Math.floor(y1);
            for (let b of blockers) {
                if(b.x === tSubX && b.y === tSubY) continue;
                if(lineIntersectsBox(x0, y0, x1, y1, b.x, b.y, 1, 1)) return true;
            }
            return false;
        }

        function lineIntersectsBox(x1, y1, x2, y2, bx, by, bw, bh) {
            const minX = bx, minY = by, maxX = bx + bw, maxY = by + bh;
            const dx = x2 - x1, dy = y2 - y1;
            let t0 = 0.0, t1 = 1.0;
            const p = [-dx, dx, -dy, dy];
            const q = [x1 - minX, maxX - x1, y1 - minY, maxY - y1];
            for(let i=0; i<4; i++) {
                if(p[i] === 0) { if(q[i] < 0) return false; } 
                else {
                    const t = q[i] / p[i];
                    if(p[i] < 0) { if(t > t1) return false; if(t > t0) t0 = t; } 
                    else { if(t < t0) return false; if(t < t1) t1 = t; }
                }
            }
            return t0 <= t1;
        }

        function createGrid() {
            container.style.gridTemplateColumns = `repeat(${currentGridWidth}, 40px)`;
            container.style.gridTemplateRows = `repeat(${currentGridHeight}, 40px)`;
            container.innerHTML = '';
            tiles = [];

            for (let y = 0; y < currentGridHeight; y++) {
                for (let x = 0; x < currentGridWidth; x++) {
                    const tile = document.createElement('div');
                    tile.classList.add('tile');
                    tile.dataset.x = x; tile.dataset.y = y;
                    
                    const label = document.createElement('span');
                    label.classList.add('coord-label');
                    label.textContent = `${x},${y}`;
                    tile.appendChild(label);
                    
                    for (let i = 0; i < 9; i++) {
                        const sub = document.createElement('div');
                        sub.classList.add('subcell');
                        sub.dataset.idx = i; 
                        tile.appendChild(sub);
                    }
                    
                    tile.addEventListener('click', (e) => {
                        if (isEditorMode) handleEditorClick(e, x, y);
                        else if (isSimMode) handleSimClick(x, y);
                        else handleMeasureClick(x, y);
                    });
                    
                    tile.addEventListener('mouseenter', (e) => {
                        if (isEditorMode && e.buttons === 1) handleEditorClick(e, x, y);
                        else if (!isEditorMode) handleSimHover(x, y);
                    });

                    container.appendChild(tile);
                    tiles.push(tile);
                }
            }
            updateAreaOverlay();
            updateLOS();
        }

        function toggleEditor() {
            isEditorMode = !isEditorMode;
            const panel = document.getElementById('editor-panel');
            const btn = document.getElementById('btn-editor');
            if (isEditorMode) {
                panel.classList.add('visible'); btn.classList.add('active');
                infoPanel.classList.add('edit-mode');
                resetMeasureState();
                rangeText.textContent = "ÏóêÎîîÌÑ∞ Î™®Îìú";
                rangeText.style.color = "#4fc3f7";
            } else {
                panel.classList.remove('visible'); btn.classList.remove('active');
                infoPanel.classList.remove('edit-mode');
                rangeText.textContent = "ÏùºÎ∞ò Î™®Îìú";
            }
        }
        function selectTool(tool) { currentTool = tool; 
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('selected'));
            event.target.classList.add('selected');
        }
        function handleEditorClick(e, x, y) {
            const tile = tiles[y * currentGridWidth + x];
            if(currentTool === 'ERASER') renderTileObject(tile, {t:null}); // Clear
            else renderTileObject(tile, {t:currentTool});
        }
        function renderTileObject(tile, data) {
            const subcells = tile.querySelectorAll('.subcell');
            subcells.forEach(c => c.className = 'subcell'); // Clear
            const type = data.t;
            if(!type) return;
            
            if(type === 'FULL') subcells.forEach(c => c.classList.add('obs-full'));
            else if(type === 'BLK_T') [0,1,2].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'BLK_B') [6,7,8].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'BLK_L') [0,3,6].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'BLK_R') [2,5,8].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'BLK_M_H') [3,4,5].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'BLK_M_V') [1,4,7].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'GRY_T') [0,1,2].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if(type === 'GRY_B') [6,7,8].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if(type === 'GRY_L') [0,3,6].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if(type === 'GRY_R') [2,5,8].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if(type === 'GRY_M_H') [3,4,5].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if(type === 'GRY_M_V') [1,4,7].forEach(i=>subcells[i].classList.add('obs-partial'));
        }
        
        function applySymmetry(mode) {
             const W = currentGridWidth; const H = currentGridHeight;
             const halfH = Math.ceil(H/2); const halfW = Math.ceil(W/2);
             let startX=0, endX=W, startY=0, endY=H;
             if(mode==='T2B') endY=halfH; else if(mode==='B2T') startY=Math.floor(H/2);
             else if(mode==='L2R') endX=halfW; else if(mode==='R2L') startX=Math.floor(W/2);
             
             const updates = [];
             for(let y=startY; y<endY; y++) {
                 for(let x=startX; x<endX; x++) {
                     const srcIdx = y*W+x; const srcTile=tiles[srcIdx];
                     const tx=(W-1)-x; const ty=(H-1)-y;
                     const cellData=[];
                     srcTile.querySelectorAll('.subcell').forEach(c=>{
                         if(c.classList.contains('obs-full')) cellData.push('obs-full');
                         else if(c.classList.contains('obs-partial')) cellData.push('obs-partial');
                         else cellData.push(null);
                     });
                     updates.push({tx,ty,cellData});
                 }
             }
             updates.forEach(u=>{
                 const t=tiles[u.ty*W+u.tx]; if(!t) return;
                 for(let i=0;i<9;i++) {
                     t.children[i+1].className='subcell';
                     if(u.cellData[i]) t.children[(8-i)+1].classList.add(u.cellData[i]);
                 }
             });
             updateLOS();
        }

        function toggleSimulator() {
            isSimMode = !isSimMode; isRangeMode = false;
            document.getElementById('btn-range').classList.remove('active');
            const btn = document.getElementById('btn-sim');
            if(isSimMode) {
                btn.classList.add('active'); simControls.classList.add('visible'); 
                infoPanel.classList.add('sim-mode'); infoPanel.classList.remove('range-mode');
                resetSimState();
                rangeText.textContent = "ÏãúÎÆ¨Î†àÏù¥ÌÑ∞ ÎåÄÍ∏∞";
                rangeText.style.color = "#4fc3f7";
            } else {
                btn.classList.remove('active'); simControls.classList.remove('visible');
                infoPanel.classList.remove('sim-mode');
                resetMeasureState();
            }
        }
        
        function toggleRangeMode() {
            isRangeMode = !isRangeMode; isSimMode = false;
            document.getElementById('btn-sim').classList.remove('active');
            const btn = document.getElementById('btn-range');
            if(isRangeMode) {
                btn.classList.add('active'); simControls.classList.add('visible');
                infoPanel.classList.add('range-mode'); infoPanel.classList.remove('sim-mode');
                rangeText.textContent = "ÏÇ¨Í±∞Î¶¨ ÌôïÏù∏";
                resetMeasureState();
            } else {
                btn.classList.remove('active'); simControls.classList.remove('visible');
                infoPanel.classList.remove('range-mode');
                resetMeasureState();
                rangeText.textContent = "ÏúÑÏπò ÏÑ†ÌÉù";
                rangeText.style.color = "#4fc3f7";
            }
            updateLOS();
        }

        function changeVal(delta) {
            if(isSimMode) {
                maxTicks+=delta; if(maxTicks<1) maxTicks=1;
                document.getElementById('tick-display').textContent = maxTicks;
                resetSimState();
            } else if(isRangeMode) {
                rangeValue+=delta; if(rangeValue<1) rangeValue=1;
                document.getElementById('tick-display').textContent = rangeValue;
                updateLOS();
            }
        }

        function resetMeasureState() {
            startPoint = null; isLocked = false; lockedAxis = null;
            tiles.forEach(t => t.classList.remove('start', 'path', 'target', 'locked'));
            updateLOS();
        }

        function handleMeasureClick(x, y) {
            if (!startPoint) {
                startPoint = { x, y };
                tiles[y * currentGridWidth + x].classList.add('start');
                handleSimHover(x, y); updateLOS();
                return;
            }
            if (isRangeMode) { // Re-click resets start
                resetMeasureState(); startPoint = {x, y};
                tiles[y * currentGridWidth + x].classList.add('start');
                updateLOS(); return;
            }
            if (!isLocked) { isLocked = true; return; }
            resetMeasureState();
        }

        function handleSimHover(tx, ty) {
            if (isRangeMode) return;
            if (isLocked || !startPoint) return;
            tiles.forEach(t => t.classList.remove('path', 'target'));
            tiles[ty * currentGridWidth + tx].classList.add('target');
            
            const sx = startPoint.x; const sy = startPoint.y;
            if (lockedAxis === null && (tx !== sx || ty !== sy)) {
                if (Math.abs(tx - sx) > Math.abs(ty - sy)) lockedAxis = 'x'; else lockedAxis = 'y';
            }
            if (tx === sx && ty === sy) lockedAxis = null;
            
            const cells = [];
            let xDir = cx > sx ? 1 : -1; let yDir = cy > sy ? 1 : -1;
            let cx, cy;
            if (lockedAxis === 'y') { cx = sx; cy = ty; } else { cx = tx; cy = sy; }

            for(let i=1; i<=Math.abs(cx-sx); i++) cells.push({x:sx+i*xDir, y:sy});
            for(let i=1; i<=Math.abs(cy-sy); i++) cells.push({x:cx, y:sy+i*yDir});
            xDir = tx > cx ? 1 : -1; yDir = ty > cy ? 1 : -1;
            for(let i=1; i<=Math.abs(tx-cx); i++) cells.push({x:cx+i*xDir, y:cy});
            for(let i=1; i<=Math.abs(ty-cy); i++) cells.push({x:cx, y:cy+i*yDir});

            cells.forEach(c => {
                const idx = c.y * currentGridWidth + c.x;
                if(tiles[idx]) tiles[idx].classList.add('path');
            });
            
            const distX = Math.abs(tx - sx); const distY = Math.abs(ty - sy);
            rangeText.innerHTML = `Í±∞Î¶¨: ${distX + distY} (Í∞ÄÎ°ú${distX}+ÏÑ∏Î°ú${distY})`;
            rangeText.style.color = "#4fc3f7";
        }
        
        function toggleArea1() { isArea1Active=!isArea1Active; updateAreaOverlay(); document.getElementById('btn-area1').classList.toggle('active'); }
        function toggleArea2() { isArea2Active=!isArea2Active; updateAreaOverlay(); document.getElementById('btn-area2').classList.toggle('active'); }

        createGrid();
        initMapStorage();
        loadMap('hotspot');

    </script>
</body>
</html>
