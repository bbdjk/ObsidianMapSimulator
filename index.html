<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <link rel="manifest" href="./manifest.json?v=4">
    <meta name="theme-color" content="#1e1e1e">
    <link rel="icon" href="./icon-192.png">
    <link rel="apple-touch-icon" href="./icon-192.png">

    <script>
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("./service-worker.js");
        navigator.serviceWorker.addEventListener("controllerchange", () => {
          window.location.reload();
        });
      }
    </script>

    <title>Obsidian Map Tool v57 (Restored & Fixed)</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', 'Apple SD Gothic Neo', sans-serif;
            background-color: #1e1e1e;
            color: #e0e0e0;
            margin: 0; padding: 0;
            width: 100vw; height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: row;
        }

        /* --- ë©”ì¸ ë ˆì´ì•„ì›ƒ (PC ê¸°ì¤€) --- */
        .main-area {
            flex: 1; display: flex; flex-direction: column; 
            height: 100%; position: relative; overflow: hidden;
        }

        .ui-header {
            background-color: #252525; padding: 8px; border-bottom: 1px solid #333;
            display: flex; justify-content: center; align-items: center;
            flex-shrink: 0; z-index: 20;
        }

        /* ì»¨íŠ¸ë¡¤ ë²„íŠ¼ ê·¸ë£¹ (ê¸°ì¡´ ìŠ¤íƒ€ì¼ ë³µêµ¬) */
        .controls { 
            display: flex; gap: 5px; flex-wrap: nowrap; overflow-x: auto; 
            align-items: center; padding-bottom: 2px;
            -webkit-overflow-scrolling: touch;
        }
        .controls::-webkit-scrollbar { display: none; }

        /* êµ¬ë¶„ì„  */
        .v-divider { width: 1px; height: 20px; background: #555; margin: 0 5px; }

        /* ë§µ ë²„íŠ¼ ì „ìš© ìŠ¤íƒ€ì¼ */
        .btn-map { background-color: #455a64; border-color: #37474f; font-size: 0.85em; }
        .btn-map.active { background-color: #00bcd4; color: black; border-color: #00acc1; font-weight: bold; }

        /* --- ê·¸ë¦¬ë“œ ì˜ì—­ --- */
        #grid-wrapper {
            flex: 1; overflow: auto; position: relative; background: #111;
            display: flex; justify-content: center; align-items: center;
        }
        
        #grid-container {
            display: grid; gap: 1px; /* íƒ€ì¼ ê°„ê²© ëª…í™•í•˜ê²Œ 1px */
            background-color: #444; /* ê·¸ë¦¬ë“œ ì„  ìƒ‰ìƒ */
            border: 2px solid #555;
            padding: 2px;
            touch-action: none; transform-origin: center top;
        }

        .tile {
            width: 42px; height: 42px; background-color: #ddd; /* íƒ€ì¼ ê¸°ë³¸ìƒ‰ ë°ê²Œ */
            display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr);
            position: relative;
        }

        /* --- í•˜ë‹¨ UI --- */
        .bottom-ui {
            background-color: #1e1e1e; border-top: 1px solid #333; padding: 10px;
            display: flex; flex-direction: row; align-items: center; justify-content: space-between;
            gap: 10px; flex-shrink: 0; min-height: 90px; z-index: 20;
        }

        #info-panel {
            flex: 1; background: #2d2d2d; padding: 5px 15px; border-radius: 8px; 
            border: 2px solid #444; height: 100%; display: flex; flex-direction: column; 
            justify-content: center; font-size: 0.9em; position: relative; transition: all 0.3s;
        }
        
        /* ëª¨ë“œë³„ íŒ¨ë„ ìƒ‰ìƒ */
        #info-panel.edit-mode { border-color: #009688; background: #004d40; }
        #info-panel.sim-mode { border-color: #9c27b0; background: #4a148c; }
        #info-panel.range-mode { border-color: #2196f3; background: #0d47a1; } /* íŒŒë€ìƒ‰ ë°°ê²½ */

        #range-text { font-size: 1.3em; font-weight: bold; color: #4fc3f7; margin-bottom: 2px; }
        #status-text { font-size: 0.8em; color: #bbb; }

        .legend-box { display: flex; gap: 10px; justify-content: center; margin-top: 5px; font-size: 0.75em; color: #ccc; }
        .legend-item { display: flex; align-items: center; gap: 4px; }
        .legend-color { width: 10px; height: 10px; border-radius: 2px; border: 1px solid #fff; }

        /* --- ë²„íŠ¼ ìŠ¤íƒ€ì¼ --- */
        button {
            padding: 8px 12px; background: #3a3a3a; color: white;
            border: 1px solid #555; border-radius: 4px; font-weight: 600; white-space: nowrap; font-size: 0.85em;
        }
        button.active { background-color: #2e7d32; border-color: #1b5e20; }
        
        /* ê¸°ëŠ¥ë³„ ë²„íŠ¼ ìƒ‰ìƒ ë³µêµ¬ */
        #btn-editor.active { background-color: #e65100; }
        #btn-sim.active { background-color: #7b1fa2; }
        #btn-range { background-color: #1565c0; color: white; border-color: #0d47a1; }
        #btn-range.active { background-color: #0d47a1; box-shadow: 0 0 10px #1565c0; }

        #sim-controls {
            display: none; align-items: center; gap: 8px; background: #333; padding: 5px 10px;
            border-radius: 20px; border: 1px solid #555; height: 100%;
        }
        #sim-controls.visible { display: flex; }
        .tick-btn { width: 40px; height: 40px; border-radius: 50%; font-size: 1.5em; padding:0; display:flex; align-items:center; justify-content:center;}

        /* --- ì—ë””í„° íŒ¨ë„ (ìˆ¨ê¹€ ì²˜ë¦¬ ë³µêµ¬) --- */
        #editor-panel {
            position: absolute; top: 0; right: 0; bottom: 0; width: 280px; background: #222;
            border-left: 1px solid #444; padding: 15px; display: none; /* ê¸°ë³¸ ìˆ¨ê¹€ */
            flex-direction: column; overflow-y: auto; z-index: 100; 
            box-shadow: -5px 0 15px rgba(0,0,0,0.5);
        }
        #editor-panel.visible { display: flex; animation: slideIn 0.3s; }
        @keyframes slideIn { from { transform: translateX(100%); } to { transform: translateX(0); } }

        .editor-section { margin-bottom: 20px; }
        .editor-title { font-weight: bold; margin-bottom: 8px; color: #fff; border-bottom: 1px solid #555; padding-bottom: 5px; font-size: 0.9em; }
        .preset-group { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
        .preset-group button { width: 100%; font-size: 0.8em; padding: 10px; }
        .tool-btn { width: 100%; text-align: left; margin-bottom: 5px; padding: 12px; background: #333; border: 1px solid #444; color: #ccc;}
        .tool-btn.selected { background: #009688; color: white; }

        /* --- ğŸ¨ íƒ€ì¼ ë¹„ì£¼ì–¼ (ì‚¬ìš©ì ìš”ì²­ ìŠ¤íƒ€ì¼ ì ìš©) --- */
        
        .subcell { border: 0.5px solid rgba(0,0,0,0.1); } /* íƒ€ì¼ ë‚´ë¶€ êµ¬ë¶„ì„  ë³µêµ¬ */

        /* 1. ì‹œì•¼ (Visibility) - ì—°ë‘ìƒ‰ */
        .subcell.sub-visible { 
            background-color: rgba(76, 175, 80, 0.5) !important; 
        }

        /* 2. ì‚¬ê±°ë¦¬ (Range) - íˆ¬ëª… íŒŒë€ìƒ‰ (ê½‰ ì±„ì›€) */
        .subcell.in-range { 
            background-color: rgba(33, 150, 243, 0.4) !important; 
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.3);
        }

        /* 3. ê³µê²© ê°€ëŠ¥ (êµì§‘í•©) - ì§„í•œ íŒŒë€ìƒ‰ (ìš”ì²­í•˜ì‹  ìŠ¤íƒ€ì¼) */
        .subcell.sub-visible.in-range { 
            background-color: #1565c0 !important; /* ì§„í•œ íŒŒë‘ */
            box-shadow: inset 0 0 0 1px #fff;
        }

        /* ì¥ì• ë¬¼ ìƒ‰ìƒ */
        .subcell.obs-full { background-color: #111; } 
        .subcell.obs-partial { background: repeating-linear-gradient(45deg, #555, #555 3px, #777 3px, #777 6px); }
        .subcell.obs-weak { background-color: #009688; }

        /* ë§ˆì»¤ (ì‹œì‘, ëª©í‘œ, ê²½ë¡œ) */
        .tile.start::after { content: ''; position: absolute; inset: 0; border: 3px solid #00e5ff; z-index: 10; pointer-events: none;}
        .tile.target::before { content: ''; position: absolute; inset: 0; border: 3px solid #ff1744; z-index: 11; pointer-events: none;}
        .tile.path::before { content: ''; position: absolute; inset: 0; background-color: rgba(255, 235, 59, 0.4); z-index: 5; pointer-events: none;}

        .l-green { background-color: rgba(76, 175, 80, 0.8); }
        .l-blue { background-color: rgba(33, 150, 243, 0.5); }
        .l-darkblue { background-color: #1565c0; border: 1px solid #fff; }

        /* --- ğŸ“± ëª¨ë°”ì¼ ì„¸ë¡œ ëª¨ë“œ ëŒ€ì‘ --- */
        @media screen and (orientation: portrait) {
            body { flex-direction: column; }
            .main-area { width: 100%; height: 100%; }
            .ui-header { overflow-x: auto; justify-content: flex-start; padding: 5px; }
            .bottom-ui { 
                flex-direction: column; gap: 10px; padding-bottom: 20px; min-height: 120px;
                background: #1e1e1e;
            }
            #sim-controls { width: 100%; justify-content: center; }
            #info-panel { width: 100%; }
            
            /* ì—ë””í„° íŒ¨ë„: ëª¨ë°”ì¼ì—ì„œëŠ” ì•„ë˜ì—ì„œ ìœ„ë¡œ ì˜¬ë¼ì˜¤ê²Œ */
            #editor-panel {
                top: auto; bottom: 0; left: 0; right: 0; width: 100%; height: 60vh;
                border-left: none; border-top: 2px solid #444;
            }
        }
    </style>
</head>
<body>
    <div class="main-area">
        <div class="ui-header">
            <div class="controls">
                <button id="btn-hotspot" class="btn-map" onclick="loadMap('hotspot')">Hotspot</button>
                <button id="btn-crossroads" class="btn-map" onclick="loadMap('crossroads')">Crossroads</button>
                <button id="btn-alley" class="btn-map" onclick="loadMap('alley')">Alley</button>
                
                <div class="v-divider"></div>

                <select id="map-selector" onchange="handleMapSelect()">
                    <option value="" disabled selected>ì €ì¥ëœ ë§µ</option>
                    <option value="__NEW__">+ ìƒˆ ë§µ</option>
                </select>
                
                <div class="v-divider"></div>

                <button id="btn-editor" onclick="toggleEditor()">ğŸ›  ì—ë””í„°</button>
                <button id="btn-area1" onclick="toggleArea1()">A1</button>
                <button id="btn-area2" onclick="toggleArea2()">A2</button>
                <button id="btn-sim" onclick="toggleSimulator()">ğŸ² ì´ë™</button>
                <button id="btn-los" onclick="toggleLOS()">ğŸ‘ LOS</button>
                <button id="btn-range" onclick="toggleRangeMode()">ğŸ“ ì‚¬ê±°ë¦¬</button>
            </div>
        </div>

        <div id="grid-wrapper">
            <div id="grid-container"></div>
        </div>

        <div class="bottom-ui">
            <div id="sim-controls">
                <button class="tick-btn" onclick="changeVal(-1)">-</button>
                <span id="tick-display" style="font-weight:bold; color: #fff; font-size:1.2em;">3</span>
                <button class="tick-btn" onclick="changeVal(1)">+</button>
            </div>

            <div id="info-panel">
                <div id="range-text">ì¤€ë¹„ ì™„ë£Œ</div>
                <div id="detail-text">ì¼ë°˜ ëª¨ë“œ</div>
                <div id="status-text">ì‹œì‘ ì§€ì ì„ í„°ì¹˜í•˜ì„¸ìš”</div>
                
                <div class="legend-box">
                    <div class="legend-item"><div class="legend-color l-green"></div>ì‹œì•¼</div>
                    <div class="legend-item"><div class="legend-color l-blue"></div>ì‚¬ê±°ë¦¬</div>
                    <div class="legend-item"><div class="legend-color l-darkblue"></div>ê³µê²©ê°€ëŠ¥</div>
                </div>
            </div>
        </div>
    </div>

    <div id="editor-panel">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <span style="font-weight:bold; color:white;">ë§µ ì—ë””í„°</span>
            <button onclick="toggleEditor()" style="background:#444; padding:5px 10px;">âŒ ë‹«ê¸°</button>
        </div>
        
        <div class="editor-section">
            <div class="editor-title">ê¸°ë³¸ ë„êµ¬</div>
            <button class="tool-btn selected" onclick="selectTool('ERASER')">â¬œ ì§€ìš°ê°œ</button>
            <button class="tool-btn" onclick="selectTool('CUSTOM_DRAW')">âœï¸ ì§ì ‘ ê·¸ë¦¬ê¸°</button>
            <button class="tool-btn" onclick="selectTool('FULL')">â¬› 3x3 ë°•ìŠ¤</button>
        </div>
        <div class="editor-section">
            <div class="editor-title">ğŸ”„ ëŒ€ì¹­ ë³µì‚¬</div>
            <div class="preset-group">
                <button onclick="applySymmetry('T2B')">â¬†â¡â¬‡</button>
                <button onclick="applySymmetry('B2T')">â¬‡â¡â¬†</button>
                <button onclick="applySymmetry('L2R')">â¬…â¡â¡</button>
                <button onclick="applySymmetry('R2L')">â¡â¡â¬…</button>
            </div>
        </div>
        <div class="editor-section">
            <div class="editor-title">ë§µ ê´€ë¦¬</div>
            <button class="tool-btn" onclick="saveMapAs()">ğŸ’¾ ì €ì¥</button>
            <button class="tool-btn" onclick="deleteCurrentMap()" style="background:#c62828;">ğŸ—‘ ì‚­ì œ</button>
            <button class="tool-btn" onclick="clearMapData()" style="background:#d32f2f;">âš¡ ì´ˆê¸°í™”</button>
        </div>
    </div>

    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(() => console.log('Service Worker Registered'))
                    .catch((err) => console.log('SW Failed', err));
            });
        }

        const container = document.getElementById('grid-container');
        const infoPanel = document.getElementById('info-panel');
        const rangeText = document.getElementById('range-text');
        const detailText = document.getElementById('detail-text');
        const statusText = document.getElementById('status-text');
        const editorPanel = document.getElementById('editor-panel');
        const simControls = document.getElementById('sim-controls');
        const tickDisplay = document.getElementById('tick-display');
        const mapSelector = document.getElementById('map-selector');
        
        let tiles = []; 
        let isEditorMode = false;
        let isSimMode = false;
        let isRangeMode = false; 
        let isArea1Active = false; 
        let isArea2Active = false;
        let isLOSActive = false;
        let isMouseDown = false;
        let currentTool = 'ERASER'; 
        
        let currentGridWidth = 12;
        let currentGridHeight = 12;
        
        let startPoint = null;
        let isLocked = false;
        let maxTicks = 3;
        let rangeValue = 4; 
        let simSegments = []; 
        let lockedAxis = null; 
        let currentEditingMapName = null;
        let savedMaps = {};

        let isDragging = false;
        container.addEventListener('touchmove', handleTouchMove, { passive: false });
        container.addEventListener('touchstart', (e) => { isDragging = true; }, { passive: true });
        container.addEventListener('touchend', (e) => { isDragging = false; }, { passive: true });

        function handleTouchMove(e) {
            e.preventDefault(); 
            if (!isDragging) return;
            const touch = e.touches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            if (target) {
                const tile = target.closest('.tile');
                if (tile) {
                    const x = parseInt(tile.dataset.x);
                    const y = parseInt(tile.dataset.y);
                    if (isEditorMode) renderTileObject(tile, {t: currentTool});
                    else if ((isSimMode || !isEditorMode) && startPoint) handleMeasureHover(x, y);
                }
            }
        }

        const defaultMaps = {
            hotspot: [{x:9, y:1, t:'CONTAINER', idx:[8]}, {x:7, y:2, t:'FULL'}, {x:8, y:2, t:'CONTAINER', idx:[2]}, {x:10, y:2, t:'BLK_B'},{x:2, y:3, t:'GRY_R'}, {x:7, y:3, t:'FULL'}, {x:2, y:4, t:'BLK_T'}, {x:5, y:4, t:'BLK_T'}, {x:6, y:4, t:'CONTAINER', idx:[2,5]},{x:8, y:4, t:'FULL'}, {x:9, y:4, t:'CONTAINER', idx:[7,8]}, {x:10, y:4, t:'CONTAINER', idx:[3,6]}, {x:4, y:5, t:'CONTAINER', idx:[2]},{x:8, y:5, t:'GRY_R'}, {x:3, y:6, t:'GRY_L'}, {x:7, y:6, t:'CONTAINER', idx:[6]}, {x:1, y:7, t:'CONTAINER', idx:[2,5]},{x:2, y:7, t:'CONTAINER', idx:[0,1]}, {x:3, y:7, t:'FULL'}, {x:5, y:7, t:'CONTAINER', idx:[3,6]}, {x:6, y:7, t:'BLK_B'},{x:9, y:7, t:'BLK_B'}, {x:4, y:8, t:'FULL'}, {x:9, y:8, t:'GRY_L'}, {x:1, y:9, t:'BLK_T'}, {x:3, y:9, t:'CONTAINER', idx:[0]},{x:4, y:9, t:'FULL'}, {x:2, y:10, t:'CONTAINER', idx:[0]}],
            crossroads: [{x:8, y:2, t:'BLK_L'}, {x:4, y:3, t:'GRY_R'}, {x:8, y:3, t:'FULL'}, {x:9, y:3, t:'GRY_T'}, {x:0, y:4, t:'CONTAINER', idx:[7,8]},{x:1, y:4, t:'BLK_B'}, {x:2, y:4, t:'BLK_B'}, {x:3, y:4, t:'FULL'}, {x:4, y:4, t:'FULL'}, {x:5, y:4, t:'CONTAINER', idx:[7,8]},{x:6, y:4, t:'CONTAINER', idx:[5,8]}, {x:8, y:4, t:'GRY_R'}, {x:4, y:5, t:'CONTAINER', idx:[8]}, {x:7, y:6, t:'CONTAINER', idx:[0]},{x:3, y:7, t:'GRY_L'}, {x:5, y:7, t:'CONTAINER', idx:[0,3]}, {x:6, y:7, t:'CONTAINER', idx:[0,1]}, {x:7, y:7, t:'FULL'},{x:8, y:7, t:'FULL'}, {x:9, y:7, t:'BLK_T'}, {x:10, y:7, t:'BLK_T'}, {x:11, y:7, t:'CONTAINER', idx:[0,1]}, {x:2, y:8, t:'GRY_B'},{x:3, y:8, t:'FULL'}, {x:7, y:8, t:'GRY_L'}, {x:3, y:9, t:'BLK_R'}],
            alley: [{x:5, y:2, t:'BLK_B'}, {x:10, y:2, t:'GRY_L'}, {x:3, y:3, t:'GRY_L'}, {x:4, y:3, t:'CONTAINER', idx:[5,8]}, {x:6, y:3, t:'CONTAINER', idx:[8]},{x:0, y:4, t:'BLK_T'}, {x:2, y:4, t:'CONTAINER', idx:[6,7]}, {x:4, y:4, t:'BLK_T'}, {x:6, y:4, t:'FULL'}, {x:8, y:4, t:'FULL'},{x:9, y:4, t:'GRY_T'}, {x:10, y:4, t:'CONTAINER', idx:[8]}, {x:3, y:5, t:'CONTAINER', idx:[5,8]}, {x:7, y:5, t:'FULL'},{x:11, y:5, t:'CONTAINER', idx:[0]}, {x:0, y:6, t:'CONTAINER', idx:[8]}, {x:4, y:6, t:'FULL'}, {x:8, y:6, t:'CONTAINER', idx:[0,3]},{x:1, y:7, t:'CONTAINER', idx:[0]}, {x:2, y:7, t:'GRY_B'}, {x:3, y:7, t:'FULL'}, {x:5, y:7, t:'FULL'}, {x:7, y:7, t:'BLK_B'},{x:9, y:7, t:'CONTAINER', idx:[1,2]}, {x:11, y:7, t:'BLK_B'}, {x:5, y:8, t:'CONTAINER', idx:[0]}, {x:7, y:8, t:'CONTAINER', idx:[0,3]},{x:8, y:8, t:'GRY_R'}, {x:1, y:9, t:'GRY_R'}, {x:6, y:9, t:'BLK_T'}]
        };

        function initMapStorage() {
            const stored = localStorage.getItem('obsidian_saved_maps_v2');
            if (stored) {
                try { savedMaps = JSON.parse(stored); } 
                catch(e) { console.error(e); savedMaps = {}; }
            }
            refreshMapDropdown();
        }

        function refreshMapDropdown() {
            const options = mapSelector.querySelectorAll('option');
            mapSelector.innerHTML = '';
            mapSelector.appendChild(options[0]);
            mapSelector.appendChild(options[1]);
            Object.keys(savedMaps).sort().forEach(name => {
                const opt = document.createElement('option');
                opt.value = name; opt.textContent = name;
                mapSelector.appendChild(opt);
            });
        }

        function updateLOS() {
            document.querySelectorAll('.subcell').forEach(s => s.classList.remove('sub-visible', 'in-range'));
            let origin = null;
            if (simSegments.length > 0) origin = simSegments[simSegments.length - 1].end;
            else if (startPoint) origin = startPoint;

            if (isRangeMode && origin) {
                calculateRangeArea(origin);
                calculateLOS(origin); 
            } else if (isLOSActive && origin) {
                calculateLOS(origin);
            }
        }

        function calculateRangeArea(origin) {
            for(let y=0; y<currentGridHeight; y++) {
                for(let x=0; x<currentGridWidth; x++) {
                    const dist = Math.abs(x - origin.x) + Math.abs(y - origin.y);
                    if (dist <= rangeValue) {
                        const idx = y * currentGridWidth + x;
                        const tile = tiles[idx];
                        for(let i=0; i<9; i++) tile.children[i+1].classList.add('in-range');
                    }
                }
            }
        }

        function calculateLOS(origin) {
            const tileX = origin.x * 3;
            const tileY = origin.y * 3;
            const inset = 0.01;
            const originPoints = [
                {x: tileX + 1.5, y: tileY + 1.5},
                {x: tileX + inset, y: tileY + inset},
                {x: tileX + 3 - inset, y: tileY + inset},
                {x: tileX + inset, y: tileY + 3 - inset},
                {x: tileX + 3 - inset, y: tileY + 3 - inset}
            ];

            const blockers = [];
            for(let y=0; y<currentGridHeight; y++) {
                for(let x=0; x<currentGridWidth; x++) {
                    const idx = y * currentGridWidth + x;
                    const tile = tiles[idx];
                    for(let i=0; i<9; i++) {
                        if(tile.children[i+1].classList.contains('obs-full')) {
                            blockers.push({ x: x * 3 + (i % 3), y: y * 3 + Math.floor(i / 3), w: 1, h: 1, tx: x, ty: y });
                        }
                    }
                }
            }

            const validOrigins = [];
            for (let op of originPoints) {
                let insideWall = false;
                for (let b of blockers) {
                    if (op.x >= b.x && op.x <= b.x + 1 && op.y >= b.y && op.y <= b.y + 1) { 
                        insideWall = true; 
                        break; 
                    }
                }
                if (!insideWall) validOrigins.push(op);
            }
            if (validOrigins.length === 0) return;

            const gridW = currentGridWidth * 3;
            const gridH = currentGridHeight * 3;

            for (let gy = 0; gy < gridH; gy++) {
                for (let gx = 0; gx < gridW; gx++) {
                    const tx = Math.floor(gx / 3);
                    const ty = Math.floor(gy / 3);
                    const tileIdx = ty * currentGridWidth + tx;
                    const tile = tiles[tileIdx];
                    const subIdx = (gy % 3) * 3 + (gx % 3);
                    
                    if (!tile || tile.children[subIdx + 1].classList.contains('obs-full')) continue;

                    const tInset = 0.1;
                    const targetPoints = [
                        {x: gx + 0.5, y: gy + 0.5},
                        {x: gx + tInset, y: gy + tInset},
                        {x: gx + 1-tInset, y: gy + tInset},
                        {x: gx + tInset, y: gy + 1-tInset},
                        {x: gx + 1-tInset, y: gy + 1-tInset}
                    ];
                    
                    let isVisible = false;
                    outerCheck:
                    for (let op of validOrigins) {
                        for (let tp of targetPoints) {
                            if (!isRayBlocked(op.x, op.y, tp.x, tp.y, blockers)) {
                                isVisible = true;
                                break outerCheck;
                            }
                        }
                    }
                    if (isVisible) tile.children[subIdx + 1].classList.add('sub-visible');
                }
            }
        }

        function isRayBlocked(x0, y0, x1, y1, blockers) {
            const tSubX = Math.floor(x1);
            const tSubY = Math.floor(y1);
            for (let b of blockers) {
                if(b.x === tSubX && b.y === tSubY) continue;
                if(lineIntersectsBox(x0, y0, x1, y1, b.x, b.y, 1, 1)) return true;
            }
            return false;
        }

        function lineIntersectsBox(x1, y1, x2, y2, bx, by, bw, bh) {
            const minX = bx, minY = by, maxX = bx + bw, maxY = by + bh;
            const dx = x2 - x1, dy = y2 - y1;
            let t0 = 0.0, t1 = 1.0;
            const p = [-dx, dx, -dy, dy];
            const q = [x1 - minX, maxX - x1, y1 - minY, maxY - y1];
            for(let i=0; i<4; i++) {
                if(p[i] === 0) { if(q[i] < 0) return false; } 
                else {
                    const t = q[i] / p[i];
                    if(p[i] < 0) { if(t > t1) return false; if(t > t0) t0 = t; } 
                    else { if(t < t0) return false; if(t < t1) t1 = t; }
                }
            }
            return t0 <= t1;
        }

        function createGrid() {
            container.style.gridTemplateColumns = `repeat(${currentGridWidth}, 42px)`;
            container.style.gridTemplateRows = `repeat(${currentGridHeight}, 42px)`;
            container.innerHTML = '';
            tiles = [];

            for (let y = 0; y < currentGridHeight; y++) {
                for (let x = 0; x < currentGridWidth; x++) {
                    const tile = document.createElement('div');
                    tile.classList.add('tile');
                    tile.dataset.x = x; tile.dataset.y = y;
                    
                    const label = document.createElement('span');
                    label.classList.add('coord-label'); // ì¢Œí‘œ ë‹¤ì‹œ ë³´ì´ê²Œ ìˆ˜ì •
                    // label.textContent = `${x},${y}`; // ì¢Œí‘œ ìˆ«ìê°€ ë„ˆë¬´ ì§€ì €ë¶„í•˜ë©´ ì£¼ì„ì²˜ë¦¬
                    tile.appendChild(label);
                    
                    for (let i = 0; i < 9; i++) {
                        const sub = document.createElement('div');
                        sub.classList.add('subcell');
                        sub.dataset.idx = i; 
                        tile.appendChild(sub);
                    }
                    
                    tile.addEventListener('click', (e) => {
                        if (isEditorMode) handleEditorClick(e, x, y);
                        else if (isSimMode) handleSimClick(x, y);
                        else handleMeasureClick(x, y);
                    });
                    
                    tile.addEventListener('mouseenter', (e) => {
                        if (isEditorMode && e.buttons === 1) handleEditorClick(e, x, y);
                        else if (!isEditorMode) handleSimHover(x, y);
                    });

                    container.appendChild(tile);
                    tiles.push(tile);
                }
            }
            updateAreaOverlay();
            updateLOS();
        }

        function toggleEditor() {
            if(isSimMode) toggleSimulator(); 
            isEditorMode = !isEditorMode;
            const panel = document.getElementById('editor-panel');
            const btn = document.getElementById('btn-editor');
            if (isEditorMode) {
                panel.classList.add('visible'); btn.classList.add('active');
                infoPanel.classList.add('edit-mode');
                resetMeasureState();
                rangeText.textContent = "ì—ë””í„° ëª¨ë“œ";
                rangeText.style.color = "#4fc3f7";
            } else {
                panel.classList.remove('visible'); btn.classList.remove('active');
                infoPanel.classList.remove('edit-mode');
                rangeText.textContent = "ì¼ë°˜ ëª¨ë“œ";
            }
        }
        function selectTool(tool) { currentTool = tool; 
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('selected'));
            event.target.classList.add('selected');
        }
        function handleEditorClick(e, x, y) {
            const tile = tiles[y * currentGridWidth + x];
            if(currentTool === 'ERASER') renderTileObject(tile, {t:null}); // Clear
            else renderTileObject(tile, {t:currentTool});
        }
        function renderTileObject(tile, data) {
            const subcells = tile.querySelectorAll('.subcell');
            subcells.forEach(c => c.className = 'subcell'); // Clear
            const type = data.t;
            if(!type) return;
            
            if(type === 'FULL') subcells.forEach(c => c.classList.add('obs-full'));
            else if(type === 'BLK_T') [0,1,2].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'BLK_B') [6,7,8].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'BLK_L') [0,3,6].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'BLK_R') [2,5,8].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'BLK_M_H') [3,4,5].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'BLK_M_V') [1,4,7].forEach(i=>subcells[i].classList.add('obs-full'));
            else if(type === 'GRY_T') [0,1,2].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if(type === 'GRY_B') [6,7,8].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if(type === 'GRY_L') [0,3,6].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if(type === 'GRY_R') [2,5,8].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if(type === 'GRY_M_H') [3,4,5].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if(type === 'GRY_M_V') [1,4,7].forEach(i=>subcells[i].classList.add('obs-partial'));
        }
        
        function applySymmetry(mode) {
             const W = currentGridWidth; const H = currentGridHeight;
             const halfH = Math.ceil(H/2); const halfW = Math.ceil(W/2);
             let startX=0, endX=W, startY=0, endY=H;
             if(mode==='T2B') endY=halfH; else if(mode==='B2T') startY=Math.floor(H/2);
             else if(mode==='L2R') endX=halfW; else if(mode==='R2L') startX=Math.floor(W/2);
             
             const updates = [];
             for(let y=startY; y<endY; y++) {
                 for(let x=startX; x<endX; x++) {
                     const srcIdx = y*W+x; const srcTile=tiles[srcIdx];
                     const tx=(W-1)-x; const ty=(H-1)-y;
                     const cellData=[];
                     srcTile.querySelectorAll('.subcell').forEach(c=>{
                         if(c.classList.contains('obs-full')) cellData.push('obs-full');
                         else if(c.classList.contains('obs-partial')) cellData.push('obs-partial');
                         else cellData.push(null);
                     });
                     updates.push({tx,ty,cellData});
                 }
             }
             updates.forEach(u=>{
                 const t=tiles[u.ty*W+u.tx]; if(!t) return;
                 for(let i=0;i<9;i++) {
                     t.children[i+1].className='subcell';
                     if(u.cellData[i]) t.children[(8-i)+1].classList.add(u.cellData[i]);
                 }
             });
             updateLOS();
        }

        function toggleSimulator() {
            isSimMode = !isSimMode; isRangeMode = false;
            document.getElementById('btn-range').classList.remove('active');
            const btn = document.getElementById('btn-sim');
            if(isSimMode) {
                btn.classList.add('active'); simControls.classList.add('visible'); 
                infoPanel.classList.add('sim-mode'); infoPanel.classList.remove('range-mode');
                resetSimState();
                rangeText.textContent = "ì‹œë®¬ë ˆì´í„° ëŒ€ê¸°";
                rangeText.style.color = "#4fc3f7";
            } else {
                btn.classList.remove('active'); simControls.classList.remove('visible');
                infoPanel.classList.remove('sim-mode');
                resetMeasureState();
            }
        }
        
        function toggleRangeMode() {
            isRangeMode = !isRangeMode; isSimMode = false;
            document.getElementById('btn-sim').classList.remove('active');
            const btn = document.getElementById('btn-range');
            if(isRangeMode) {
                btn.classList.add('active'); simControls.classList.add('visible');
                infoPanel.classList.add('range-mode'); infoPanel.classList.remove('sim-mode');
                rangeText.textContent = "ì‚¬ê±°ë¦¬ í™•ì¸";
                resetMeasureState();
            } else {
                btn.classList.remove('active'); simControls.classList.remove('visible');
                infoPanel.classList.remove('range-mode');
                resetMeasureState();
                rangeText.textContent = "ìœ„ì¹˜ ì„ íƒ";
                rangeText.style.color = "#4fc3f7";
            }
            updateLOS();
        }

        function changeVal(delta) {
            if(isSimMode) {
                maxTicks+=delta; if(maxTicks<1) maxTicks=1;
                document.getElementById('tick-display').textContent = maxTicks;
                resetSimState();
            } else if(isRangeMode) {
                rangeValue+=delta; if(rangeValue<1) rangeValue=1;
                document.getElementById('tick-display').textContent = rangeValue;
                updateLOS();
            }
        }

        function resetMeasureState() {
            startPoint = null; isLocked = false; lockedAxis = null;
            tiles.forEach(t => t.classList.remove('start', 'path', 'target', 'locked'));
            updateLOS();
        }

        function handleMeasureClick(x, y) {
            if (!startPoint) {
                startPoint = { x, y };
                tiles[y * currentGridWidth + x].classList.add('start');
                handleSimHover(x, y); updateLOS();
                return;
            }
            if (isRangeMode) { // Re-click resets start
                resetMeasureState(); startPoint = {x, y};
                tiles[y * currentGridWidth + x].classList.add('start');
                updateLOS(); return;
            }
            if (!isLocked) { isLocked = true; return; }
            resetMeasureState();
        }

        function handleSimHover(tx, ty) {
            if (isRangeMode) return;
            if (isLocked || !startPoint) return;
            tiles.forEach(t => t.classList.remove('path', 'target'));
            tiles[ty * currentGridWidth + tx].classList.add('target');
            
            const sx = startPoint.x; const sy = startPoint.y;
            if (lockedAxis === null && (tx !== sx || ty !== sy)) {
                if (Math.abs(tx - sx) > Math.abs(ty - sy)) lockedAxis = 'x'; else lockedAxis = 'y';
            }
            if (tx === sx && ty === sy) lockedAxis = null;
            
            let cx, cy;
            if (lockedAxis === 'y') { cx = sx; cy = ty; } else { cx = tx; cy = sy; }

            const cells = [];
            let xDir = cx > sx ? 1 : -1; let yDir = cy > sy ? 1 : -1;
            
            for(let i=1; i<=Math.abs(cx-sx); i++) cells.push({x:sx+i*xDir, y:sy});
            for(let i=1; i<=Math.abs(cy-sy); i++) cells.push({x:cx, y:sy+i*yDir});
            xDir = tx > cx ? 1 : -1; yDir = ty > cy ? 1 : -1;
            for(let i=1; i<=Math.abs(tx-cx); i++) cells.push({x:cx+i*xDir, y:cy});
            for(let i=1; i<=Math.abs(ty-cy); i++) cells.push({x:cx, y:cy+i*yDir});

            cells.forEach(c => {
                const idx = c.y * currentGridWidth + c.x;
                if(tiles[idx]) tiles[idx].classList.add('path');
            });
            
            const distX = Math.abs(tx - sx); const distY = Math.abs(ty - sy);
            rangeText.innerHTML = `ê±°ë¦¬: ${distX + distY} (ê°€ë¡œ${distX}+ì„¸ë¡œ${distY})`;
            rangeText.style.color = "#4fc3f7";
        }
        
        function toggleArea1() { isArea1Active=!isArea1Active; updateAreaOverlay(); document.getElementById('btn-area1').classList.toggle('active'); }
        function toggleArea2() { isArea2Active=!isArea2Active; updateAreaOverlay(); document.getElementById('btn-area2').classList.toggle('active'); }

        // --- ë§µ ë¡œë“œ í•¨ìˆ˜ ë³µêµ¬ ---
        function loadMap(mapName) {
            // ë‹¤ë¥¸ ëª¨ë“œ ì´ˆê¸°í™”
            if(isEditorMode) toggleEditor();
            
            let mapData = defaultMaps[mapName];
            if (!mapData) return;

            // ë§µ ì´ˆê¸°í™”
            tiles.forEach(tile => {
                tile.querySelectorAll('.subcell').forEach(c => c.className = 'subcell');
            });

            // ë°ì´í„° ë Œë”ë§
            mapData.forEach(data => {
                const index = data.y * currentGridWidth + data.x;
                if (tiles[index]) renderTileObject(tiles[index], data);
            });

            // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
            document.querySelectorAll('.btn-map').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('btn-' + mapName);
            if(btn) btn.classList.add('active');
            
            updateLOS();
        }

        function handleMapSelect() {
            // ì»¤ìŠ¤í…€ ë§µ ë¡œë“œ ë¡œì§ (í•„ìš”ì‹œ êµ¬í˜„)
            const val = document.getElementById('map-selector').value;
            if(val === '__NEW__') {
                if(confirm("í˜„ì¬ ë§µì„ ì§€ìš°ê³  ìƒˆ ë§µì„ ë§Œë“œì‹œê² ìŠµë‹ˆê¹Œ?")) {
                    tiles.forEach(tile => {
                        tile.querySelectorAll('.subcell').forEach(c => c.className = 'subcell');
                    });
                    toggleEditor();
                }
                document.getElementById('map-selector').value = "";
            } else if(savedMaps[val]) {
                // ì €ì¥ëœ ë§µ ë¡œë“œ
                tiles.forEach(tile => {
                    tile.querySelectorAll('.subcell').forEach(c => c.className = 'subcell');
                });
                // ... (ì €ì¥ëœ ë§µ ë¡œë“œ ë¡œì§)
            }
        }

        // --- ì €ì¥/ì‚­ì œ ë“± ì¶”ê°€ ê¸°ëŠ¥ì€ ì—ë””í„° íŒ¨ë„ì— í¬í•¨ë¨ ---
        function saveMapAs() {
            // ... (ê¸°ì¡´ ì €ì¥ ë¡œì§ ìœ ì§€)
            alert("ì €ì¥ ê¸°ëŠ¥ì€ ì—ë””í„° íŒ¨ë„ì—ì„œ ì‚¬ìš©í•˜ì„¸ìš”.");
        }
        function deleteCurrentMap() { /* ... */ }
        function clearMapData() {
             if(confirm("ëª¨ë“  íƒ€ì¼ì„ ì§€ìš°ì‹œê² ìŠµë‹ˆê¹Œ?")) {
                tiles.forEach(tile => {
                    tile.querySelectorAll('.subcell').forEach(c => c.className = 'subcell');
                });
             }
        }

        createGrid();
        initMapStorage();
        loadMap('hotspot');

    </script>
</body>
</html>
