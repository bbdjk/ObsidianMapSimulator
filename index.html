<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <link rel="manifest" href="./manifest.json?v=8">
    <meta name="theme-color" content="#1e1e1e">
    <link rel="icon" href="./icon-192.png">
    <link rel="apple-touch-icon" href="./icon-192.png">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ObsidianMap">

    <script>
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("./service-worker.js").then(reg => {
            console.log("SW Registered");
            reg.addEventListener('updatefound', () => {
                const newWorker = reg.installing;
                newWorker.addEventListener('statechange', () => {
                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                        window.location.reload();
                    }
                });
            });
        });
        navigator.serviceWorker.addEventListener("controllerchange", () => {
          window.location.reload();
        });
      }
    </script>

    <title>Obsidian Protocol Map Tool v62 (Cover Logic Added)</title>
    <style>
        /* --- Ïä§ÌÉÄÏùº Ï†ïÏùò --- */
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #1e1e1e;
            color: #e0e0e0;
            display: flex;
            flex-direction: row;
            justify-content: center;
            margin: 0;
            --base-pad: 20px;
            padding: var(--base-pad);
            padding-top: calc(var(--base-pad) + env(safe-area-inset-top));
            padding-bottom: calc(var(--base-pad) + env(safe-area-inset-bottom));
            padding-left: calc(var(--base-pad) + env(safe-area-inset-left));
            padding-right: calc(var(--base-pad) + env(safe-area-inset-right));
            user-select: none;
            min-height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        body::-webkit-scrollbar{ width: 0; height: 0; }
        
        .main-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-right: 20px;
            flex: 1;
            overflow: visible;
            padding-bottom: 50px;
            position: relative;
        }

        .ui-header {
            position: sticky;
            top: 0;
            z-index: 100;
            background-color: #1e1e1e;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-bottom: 6px;
            border-bottom: 1px solid #333;
            margin-bottom: 12px;
        }
        .ui-header .titlebar{
            width: 100%;
            max-width: 800px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 10px 8px;
            padding-top: calc(10px + env(safe-area-inset-top));
            border-bottom: 1px solid rgba(255,255,255,0.06);
            margin-bottom: 8px;
        }
        .ui-header .titlebar .title{
            font-weight: 800;
            letter-spacing: 0.2px;
            color: #e0e0e0;
            opacity: 0.95;
            user-select: none;
        }
        #btn-header-toggle{
            padding: 6px 12px;
            border-radius: 999px;
            background: #2b2b2b;
            border: 1px solid #555;
            color: #fff;
            cursor: pointer;
            font-weight: 700;
            line-height: 1;
        }
        #btn-header-toggle:hover{ background:#3a3a3a; }

        #grid-wrap{ position: relative; width: 100%; display: flex; flex-direction: column; align-items: center; }
        
        #map-toggle-row{
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 8px 0 10px;
            pointer-events: auto;
        }
        #grid-container{ position: relative; }

        #btn-header-toggle.map-toggle{
            position: static;
            z-index: 150;
            border-radius: 12px;
            min-width: 90px;
            min-height: 40px;
            padding: 6px 10px;
            font-size: 1.0em;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: rgba(43,43,43,0.92);
            border: 1px solid rgba(255,255,255,0.25);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
        }

        @media (max-width: 900px){
            #btn-header-toggle.map-toggle{
                min-width: 240px;
                min-height: 18px;
                padding: 5px 9px;
                font-size: 1.0em;
            }
            #btn-header-toggle.map-toggle:active{ transform: scale(0.99); }
        }
        .ui-header.collapsed .controls{ display: none; }
        .ui-header.collapsed{ padding-bottom: 0; margin-bottom: 8px; }

        .controls { 
            display: flex;
            flex-direction: column;
            gap: 8px;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 900px;
        }
        .controls-row{
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            width: 100%;
        }
        .v-sep{ width:1px; height:20px; background:#555; margin:0 5px; }

        .bottom-ui {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            margin-top: 20px;
            padding-bottom: 50px;
        }

        #info-panel {
            text-align: center;
            background: #2d2d2d;
            padding: 15px 30px;
            border-radius: 8px;
            border: 1px solid #444;
            width: 80%;
            max-width: 600px;
            height: auto; 
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            transition: 0.3s;
            position: relative;
        }
        #info-panel.edit-mode { border-color: #009688; background-color: #004d40; }
        #info-panel.sim-mode { border-color: #9c27b0; background-color: #4a148c; }
        #info-panel.range-mode { border-color: #fbc02d; background-color: #1a1a1a; }
        
        #range-text { 
            font-size: 1.4em; font-weight: bold; color: #4fc3f7; margin-bottom: 8px; 
            white-space: pre-wrap; line-height: 1.5;
            max-height: none; overflow: visible;
        }
        
        #detail-text { font-size: 1.1em; color: #aaa; margin-bottom: 5px; }
        #status-text { font-size: 0.95em; color: #888; font-style: italic; margin-bottom: 10px;}

        .legend-box {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.2);
            font-size: 0.85em;
            color: #ddd;
        }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; border: 1px solid rgba(255,255,255,0.3); }
        .l-green { background-color: rgba(76, 175, 80, 0.8); }
        .l-yellow { background-color: rgba(255, 235, 59, 0.5); border: 1px dashed #fff; }
        .l-blue { background-color: rgba(33, 150, 243, 0.8); }
/* [ÏàòÏ†ï] Î≤îÎ°ÄÏö© ÏÉâÏÉÅ ÌÅ¥ÎûòÏä§ (Î≥¥ÎùºÏÉâ) */
.l-cover-purple { 
    background-color: rgba(180, 0, 255, 0.9); 
    border: 1px solid rgba(255, 255, 255, 0.5); 
}

        button {
            padding: 8px 14px;
            background: #3a3a3a;
            color: white;
            border: 1px solid #555;
            cursor: pointer;
            border-radius: 4px;
            font-weight: 600;
            transition: all 0.2s;
        }
        button:hover { background: #505050; }
        button.active { background-color: #2e7d32; border-color: #1b5e20; }
        
        #btn-editor { background-color: #ff9800; color: #000; border-color: #f57c00; }
        #btn-editor.active { background-color: #e65100; color: white; box-shadow: 0 0 10px #ff9800; }

        #btn-sim { background-color: #9c27b0; color: white; border-color: #7b1fa2; }
        #btn-sim.active { background-color: #7b1fa2; box-shadow: 0 0 10px #9c27b0; }

        #btn-area1 { border-color: #ff5722; color: #ffab91; }
        #btn-area1.active { background-color: #d84315; color: white; box-shadow: 0 0 8px #ff5722; }
        #btn-area2 { border-color: #00bcd4; color: #80deea; }
        #btn-area2.active { background-color: #0097a7; color: white; box-shadow: 0 0 8px #00bcd4; }

        /* --- Í∏∞Ï≤¥ Ï∂îÍ∞Ä UI --- */
        #btn-units { border-color: #ff4fd8; color: #ffb3ee; }
        #btn-units.active { background-color: #b40086; color: white; box-shadow: 0 0 8px #ff4fd8; }
        #btn-units:disabled{ opacity: 0.45; cursor: not-allowed; filter: grayscale(0.25); }

        #unit-panel{
            display: none;
            width: 100%;
            max-width: 900px;
            margin: 10px auto 0;
            padding: 8px 10px;
            border: 1px solid #444;
            border-radius: 10px;
            background: rgba(45,45,45,0.9);
            gap: 6px;
            flex-wrap: nowrap;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            justify-content: center;
            align-items: center;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        #unit-panel::-webkit-scrollbar{ width: 0; height: 0; display: none; }
        #unit-panel.visible{ display: flex; }

        .unit-tool-btn{
            padding: 12px 18px;
            font-size: 1.05em;
            min-height: 44px;
            border-radius: 8px;
        }
        .main-area{ scrollbar-width: none; -ms-overflow-style: none; }
        .main-area::-webkit-scrollbar{ width: 0; height: 0; display: none; }
        .unit-tool-btn.active{
            background-color: #b40086;
            border-color: #ff4fd8;
            box-shadow: 0 0 10px rgba(255,79,216,0.55);
        }

        #btn-los { background-color: #00897b; color: white; border-color: #00695c; }
        #btn-los.active { background-color: #004d40; box-shadow: 0 0 10px #00897b; }

        #btn-range { background-color: #fbc02d; color: black; border-color: #f57f17; }
        #btn-range.active { background-color: #f57f17; color: white; box-shadow: 0 0 10px #fbc02d; }

        #map-selector {
            padding: 8px; border-radius: 4px; background-color: #263238;
            color: white; border: 1px solid #37474f; font-size: 0.95em;
            cursor: pointer; min-width: 150px;
        }
        #map-selector:focus { outline: none; border-color: #00bcd4; }

        #sim-controls {
            display: none; align-items: center; gap: 15px;
            margin-bottom: 15px; 
            background: #333; padding: 8px 20px;
            border-radius: 20px; border: 1px solid #555;
        }
        #sim-controls.visible { display: flex; }
        .tick-btn { width: 35px; height: 35px; border-radius: 50%; padding: 0; font-size: 1.4em; line-height: 1;}

        #grid-container {
            --tile-size: 65px;
            display: grid; gap: 1px;
            background-color: #444; border: 4px solid #333;
            padding: 2px; border-radius: 4px;
            touch-action: none;
            max-width: 100%;
            max-height: 100%;
            margin: 0 auto;
            overscroll-behavior: contain;
        }

        .tile {
            width: var(--tile-size); height: var(--tile-size); background-color: #fff;
            display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr);
            position: relative; cursor: crosshair;
        }
        
        .tile.area-red { background-color: rgba(255, 50, 50, 0.02) !important; box-shadow: inset 0 0 0 2px rgba(255, 50, 50, 0.3); }
        .tile.area-blue { background-color: rgba(50, 50, 255, 0.02) !important; box-shadow: inset 0 0 0 2px rgba(80, 80, 255, 0.3); }

        .subcell.sub-visible {
            background-color: rgba(76, 175, 80, 0.6) !important; 
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.15);
        }
        .subcell.in-range {
            background-color: rgba(255, 235, 59, 0.25); 
            box-shadow: inset 0 0 0 1px rgba(255, 235, 59, 0.5); 
        }
        .subcell.sub-visible.in-range {
            background-color: rgba(33, 150, 243, 0.65) !important; 
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.4);
        }

        .coord-label {
            position: absolute; top: 1px; left: 2px;
            font-size: clamp(8px, calc(var(--tile-size) * 0.17), 12px); color: #ccc; z-index: 10; pointer-events: none; font-family: monospace;
        }

        .subcell { border: 0.1px solid rgba(0,0,0,0.05); box-sizing: border-box; }
        .subcell.obs-full { background-color: #111; } 
        .subcell.obs-partial { background-color: #777; background-image: repeating-linear-gradient(45deg, #666, #666 2px, #777 2px, #777 4px); }
        .subcell.obs-weak { background-color: #009688; box-shadow: inset 0 0 2px rgba(255,255,255,0.3); }

        /* --- Í∏∞Ï≤¥ Î∏îÎü≠ --- */
        .subcell.unit-block {
            background-color: rgba(255, 79, 216, 0.35);
            box-shadow: inset 0 0 0 1px rgba(255, 79, 216, 0.75);
        }

        /* --- Í∏∞Ï≤¥ Î∞∞Ïπò ÌîÑÎ¶¨Î∑∞ --- */
        .subcell.unit-preview{
            background-color: rgba(255, 79, 216, 0.18);
            box-shadow:
                inset 0 0 0 2px rgba(255, 255, 255, 0.75),
                0 0 10px rgba(255, 79, 216, 0.45);
        }

        .subcell.unit-block.sub-visible,
        .subcell.unit-block.in-range,
        .subcell.unit-block.sub-visible.in-range {
            background-color: rgba(255, 79, 216, 0.35) !important;
            box-shadow: inset 0 0 0 1px rgba(255, 79, 216, 0.75);
        }

        /* --- ÌÉÄÍ≤© Í∞ÄÎä• (Îπ®Í∞ï ÌïòÏù¥ÎùºÏù¥Ìä∏) --- */
        .subcell.unit-block.unit-highlight {
            background-color: rgba(255, 0, 0, 0.55) !important;
            box-shadow:
                inset 0 0 0 1px rgba(255, 255, 255, 0.35),
                0 0 10px rgba(255, 0, 0, 0.85),
                inset 0 0 0 2px rgba(255, 0, 0, 0.95) !important;
        }

/* [ÏàòÏ†ï] ÏãúÏïº Î∞©Ìï¥(Cover) - ÏÑ†Î™ÖÌïú Î≥¥ÎùºÏÉâ */
.subcell.unit-obscured {
    background-color: rgba(180, 0, 255, 0.55) !important; /* Î∞ùÏùÄ Î≥¥ÎùºÏÉâ */
    box-shadow:
        inset 0 0 0 1px rgba(255, 255, 255, 0.4),
        0 0 12px rgba(180, 0, 255, 0.85), /* Î≥¥ÎùºÏÉâ Î∞úÍ¥ë */
        inset 0 0 0 2px rgba(180, 0, 255, 0.95) !important; /* ÏßÑÌïú Î≥¥ÎùºÏÉâ ÌÖåÎëêÎ¶¨ */
}

        /* --- Ïò§Î≤ÑÎ†àÏù¥ Î≤ÑÌäºÎì§ --- */
        #range-dir-overlay,
        #sim-dir-overlay{
            position: absolute; left: 0; top: 0; width: 100%; height: 100%; z-index: 180; pointer-events: none; display: none;
        }
        #range-dir-overlay.visible,
        #sim-dir-overlay.visible{ display:block; }
        
        .dir-btn{
            position: absolute; width: var(--tile-size); height: var(--tile-size);
            background: rgba(10,10,10,0.58); border: 2px solid rgba(0,0,0,0.78); border-radius: 10px;
            padding: 0; display: flex; align-items: center; justify-content: center; cursor: pointer; pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
            font-size: calc(var(--tile-size) * 0.58); font-weight: 900; line-height: 1;
            color: rgba(0, 229, 255, 1);
            text-shadow: 0 2px 2px rgba(0,0,0,0.95), 0 0 10px rgba(0,229,255,0.70);
            box-shadow: 0 6px 14px rgba(0,0,0,0.35), 0 0 14px rgba(0,229,255,0.20);
            backdrop-filter: blur(2px); -webkit-backdrop-filter: blur(2px);
        }
        .dir-btn:hover{
            background: rgba(15,15,15,0.70); border-color: rgba(0,229,255,0.55);
            box-shadow: 0 6px 14px rgba(0,0,0,0.35), 0 0 18px rgba(0,229,255,0.30);
        }
        .dir-btn:active{ transform: scale(0.985); }
        .dir-btn.selected{
            background: rgba(25, 0, 0, 0.62); border-color: rgba(255,0,0,0.70);
            box-shadow: 0 6px 14px rgba(0,0,0,0.35), 0 0 18px rgba(255,0,0,0.40);
            color: rgba(255, 120, 120, 1);
            text-shadow: 0 2px 2px rgba(0,0,0,0.95), 0 0 10px rgba(255,0,0,0.55);
        }

        .tile.start::after { content: ''; position: absolute; inset: 0; background-color: rgba(33, 150, 243, 0.6); border: 2px solid #2196f3; z-index: 5; pointer-events: none;}
        .tile.path::before { content: ''; position: absolute; inset: 2px; background-color: rgba(255, 235, 59, 0.3); border: 2px dashed #fdd835; z-index: 4; border-radius: 4px; pointer-events: none;}
        .tile.path-tick-0::before { content: ''; position: absolute; inset: 2px; background-color: rgba(33, 150, 243, 0.4); border: 2px dashed #fdd835; z-index: 4; border-radius: 4px; pointer-events: none;}
        .tile.path-tick-1::before { content: ''; position: absolute; inset: 2px; background-color: rgba(255, 235, 59, 0.4); border: 2px dashed #fdd835; z-index: 4; border-radius: 4px; pointer-events: none;}
        .tile.path-tick-2::before { content: ''; position: absolute; inset: 2px; background-color: rgba(244, 67, 54, 0.4); border: 2px dashed #d32f2f; z-index: 4; border-radius: 4px; pointer-events: none;}
        .tile.target::before { content: ''; position: absolute; inset: 0; background-color: rgba(244, 67, 54, 0.5); border: 2px solid #e53935; z-index: 6; pointer-events: none;}

        #editor-panel {
            width: 320px; min-width: 320px; background: #222;
            border-left: 1px solid #444; padding: 15px;
            display: none; flex-direction: column; overflow-y: auto;
        }
        #editor-panel.visible { display: flex; }

        .editor-section { margin-bottom: 25px; }
        .editor-title { 
            font-weight: bold; margin-bottom: 10px; color: #fff; 
            border-bottom: 1px solid #555; padding-bottom: 5px; font-size: 0.95em;
        }
        
        .tool-btn {
            display: flex; align-items: center; justify-content: space-between;
            width: 100%; margin-bottom: 5px; text-align: left;
            padding: 10px;
                padding-top: calc(10px + env(safe-area-inset-top));
                padding-bottom: calc(10px + env(safe-area-inset-bottom));
                padding-left: calc(10px + env(safe-area-inset-left));
                padding-right: calc(10px + env(safe-area-inset-right)); background: #333; border: 1px solid #444;
            font-size: 0.9em; cursor: pointer; color: #ccc;
        }
        .tool-btn:hover { background: #444; }
        .tool-btn.selected { background: #009688; color: white; border-color: #004d40; }
        
        .preset-group { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .preset-group button { 
            width: 100%; font-size: 0.85em; padding: 8px; cursor: pointer; 
            background: #444; color: #ddd; border: 1px solid #555;
            display: flex; align-items: center; justify-content: center; gap: 4px;
        }
        .preset-group button:hover { background: #555; }

        #io-area { margin-top: auto; border-top: 1px solid #555; padding-top: 10px; }
        #import-input {
            width: 100%; height: 50px; background: #111; color: #0f0; font-family: monospace; font-size: 0.8em;
            border: 1px solid #444; margin-bottom: 5px; resize: none;
        }
        .io-btn-group { display: flex; gap: 5px; margin-bottom: 5px;}
        .io-btn { flex: 1; padding: 10px; font-weight: bold; cursor: pointer; color: white; border: none; }
        
        #btn-export { background: #0277bd; }
        #btn-import { background: #e65100; }
        
        #save-controls { display: flex; gap: 5px; margin-bottom: 10px; }
        #btn-save-as { background: #2e7d32; flex:1; }
        #btn-delete-map { background: #c62828; flex:1; }
        
        #clear-editor-btn { width: 100%; background: #d32f2f; margin-bottom: 10px; color: white; cursor: pointer; padding:10px; border:none;}

        #grid-size-controls {
            display: flex; align-items: center; gap: 5px; background: #333; padding: 10px; border-radius: 4px;
        }
        .size-input { width: 45px; padding: 5px; background: #222; color: white; border: 1px solid #555; font-weight: bold; text-align: center;}

        /* --- üì± Î™®Î∞îÏùº ÏÑ∏Î°ú Î™®Îìú ÎåÄÏùë --- */
        @media screen and (orientation: portrait) {
            body {
                flex-direction: column; height: 100dvh; overflow: hidden; --base-pad: 10px;
                padding: var(--base-pad);
                padding-top: calc(var(--base-pad) + env(safe-area-inset-top));
                padding-bottom: calc(var(--base-pad) + env(safe-area-inset-bottom));
                padding-left: calc(var(--base-pad) + env(safe-area-inset-left));
                padding-right: calc(var(--base-pad) + env(safe-area-inset-right));
            }
            .main-area { width: 100%; flex: 1 1 auto; margin-right: 0; overflow: hidden; padding-bottom: 10px; }
            .ui-header { padding: 5px; }
            .ui-header .titlebar{ padding: 12px 8px; padding-top: calc(12px + env(safe-area-inset-top)); }
            .ui-header.collapsed .titlebar{ margin-bottom: 0; }
            .controls { max-width: 100%; }
            .controls-row{ gap: 6px; }
            .v-sep{ height: 18px; }
            button { padding: 7px 10px; font-size: 0.9em; }
            #map-selector { min-width: 130px; }
            #grid-container { align-self: center; }
            .bottom-ui {
                flex-direction: column; gap: 10px; padding-bottom: 20px; min-height: 120px; background: #1e1e1e;
            }
            #sim-controls { width: 100%; justify-content: center; }
            #info-panel { width: 100%; margin-bottom: 0; }
            #editor-panel {
                position: fixed; top: auto; bottom: 0; left: 0; right: 0;
                width: 100%; height: 50dvh; border-left: none; border-top: 2px solid #444;
                z-index: 200; box-shadow: 0 -10px 20px rgba(0,0,0,0.6);
            }
        }
    </style>
</head>
<body>

    <div class="main-area">
        <div class="ui-header">
            <div class="titlebar">
                <div class="title">Map Simulator</div>
            </div>
            
            <div class="controls">
                <div class="controls-row">
                    <button id="btn-hotspot" onclick="loadMap('hotspot')">Hotspot</button>
                    <button id="btn-crossroads" onclick="loadMap('crossroads')">Crossroads</button>
                    <button id="btn-alley" onclick="loadMap('alley')">Alley</button>
                    <div class="v-sep" aria-hidden="true" title="Íµ¨Î∂ÑÏÑ†"></div>
                </div>

                <div class="controls-row">
                    <button id="btn-area1" class="btn-area" onclick="toggleArea1()">Area1</button>
                    <button id="btn-area2" class="btn-area" onclick="toggleArea2()">Area2</button>
                    <button id="btn-units" onclick="toggleUnitPanel()">Í∏∞Ï≤¥ Ï∂îÍ∞Ä</button>
                </div>

                <div class="controls-row">
                    <button id="btn-editor" onclick="toggleEditor()">üõ† Îßµ ÏóêÎîîÌÑ∞</button>

                    <select id="map-selector" onchange="handleMapSelect()">
                        <option value="" disabled selected>-- Ï†ÄÏû•Îêú Îßµ ÏÑ†ÌÉù --</option>
                        <option value="__NEW__">&lt; ÏÉà Îßµ Ï∂îÍ∞Ä &gt;</option>
                    </select>
                </div>

                <div class="controls-row">
                    <button id="btn-los" onclick="toggleLOS()">üëÅ LOS</button>
                    <button id="btn-range" onclick="toggleRangeMode()">üìè ÏÇ¨Í±∞Î¶¨Î≤îÏúÑ</button>
                    <button id="btn-sim" onclick="toggleSimulator()">üé≤ ÏãúÎÆ¨Î†àÏù¥ÌÑ∞</button>
                </div>
            </div>
        </div>
        <div id="grid-wrap">
            <div id="map-toggle-row">
                <button id="btn-header-toggle" class="map-toggle" type="button" aria-expanded="true" onclick="toggleHeaderUI()" aria-label="ÏÉÅÎã® Î©îÎâ¥ Ï†ëÍ∏∞/ÌéºÏπòÍ∏∞">‚ñ¥</button>
            </div>
            <div id="grid-container"></div>
            <div id="range-dir-overlay" aria-label="ÏÇ¨Í±∞Î¶¨ Î∞©Ìñ• ÏÑ†ÌÉù"></div>
            <div id="sim-dir-overlay" aria-label="ÏãúÎÆ¨Î†àÏù¥ÌÑ∞ Î∞©Ìñ• ÏÑ†ÌÉù"></div>
        </div>

        <div id="unit-panel" aria-label="Í∏∞Ï≤¥ Ï∂îÍ∞Ä ÎèÑÍµ¨">
            <button id="btn-unit-large" class="unit-tool-btn" onclick="selectUnitTool('LARGE')">ÎåÄÌòïÍ∏∞Ï≤¥ Ï∂îÍ∞Ä</button>
            <button id="btn-unit-drone" class="unit-tool-btn" onclick="selectUnitTool('DRONE')">ÎìúÎ°† Ï∂îÍ∞Ä</button>
            <button id="btn-unit-low" class="unit-tool-btn" onclick="selectUnitTool('LOW')">Ï†ÄÍ∞ÄÏπò Ï∂îÍ∞Ä</button>
            <button id="btn-unit-erase" class="unit-tool-btn" onclick="selectUnitTool('ERASE')">Í∏∞Ï≤¥ Ï†úÍ±∞</button>
        </div>

        <div class="bottom-ui">
            <div id="sim-controls">
                <button class="tick-btn" onclick="changeVal(-1)">-</button>
                <span id="tick-display" style="font-weight:bold; color: #fff;">Ìã± Í∞ØÏàò : 3</span>
                <button class="tick-btn" onclick="changeVal(1)">+</button>
            </div>

            <div id="info-panel">
                <div id="range-text">ÏúÑÏπò ÏÑ†ÌÉù</div>
                <div id="detail-text">ÏùºÎ∞ò Î™®Îìú</div>
                <div id="status-text">ÏãúÏûë ÏßÄÏ†êÏùÑ ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî</div>
                
<div class="legend-box">
    <div class="legend-item"><div class="legend-color l-green"></div><span>ÏãúÏïº</span></div>
    <div class="legend-item"><div class="legend-color l-yellow"></div><span>ÏÇ¨Í±∞Î¶¨</span></div>
    <div class="legend-item"><div class="legend-color l-blue"></div><span>Í≥µÍ≤© Í∞ÄÎä•</span></div>
    <div class="legend-item"><div class="legend-color l-cover-purple"></div><span>ÏãúÏïº Î∞©Ìï¥</span></div>
</div>
            </div>
        </div>
    </div>

    <div id="editor-panel">
        <div class="editor-section">
            <div class="editor-title">üîÑ ÎåÄÏπ≠ Î≥µÏÇ¨ ÎèÑÍµ¨ (Ï†êÎåÄÏπ≠)</div>
            <div class="preset-group">
                <button onclick="applySymmetry('T2B')">‚¨Ü ÏÉÅÎã® ‚û° ÌïòÎã®</button>
                <button onclick="applySymmetry('B2T')">‚¨á ÌïòÎã® ‚û° ÏÉÅÎã®</button>
                <button onclick="applySymmetry('L2R')">‚¨Ö Ï¢åÏ∏° ‚û° Ïö∞Ï∏°</button>
                <button onclick="applySymmetry('R2L')">‚û° Ïö∞Ï∏° ‚û° Ï¢åÏ∏°</button>
            </div>
            <div style="font-size:0.8em; color:#888; margin-top:5px; text-align:center;">* Î∞òÎåÄÌé∏ÏùÑ ÏßÄÏö∞Í≥† ÌöåÏ†ÑÌïòÏó¨ ÎçÆÏñ¥ÏîÅÎãàÎã§.</div>
        </div>

        <div class="editor-section">
            <div class="editor-title">üìê Îßµ ÌÅ¨Í∏∞ ÏÑ§Ï†ï (Max 40)</div>
            <div id="grid-size-controls">
                <span>W:</span> <input type="number" id="grid-width-input" class="size-input" value="12" min="5" max="40">
                <span>H:</span> <input type="number" id="grid-height-input" class="size-input" value="12" min="5" max="40">
                <button class="io-btn" style="padding: 5px 10px; flex:0;" onclick="applyGridSize()">Î≥ÄÍ≤Ω</button>
            </div>
            <div style="font-size:0.8em; color:#888; margin-top:5px;">* Î≥ÄÍ≤Ω Ïãú Í∏∞Ï°¥ Î∞∞ÏπòÎäî Ïú†ÏßÄÎê©ÎãàÎã§.</div>
        </div>

        <div class="editor-section">
            <div class="editor-title">Îßµ Ï†ÄÏû• Í¥ÄÎ¶¨</div>
            <div id="current-map-name" style="color:#00bcd4; margin-bottom:5px; font-size:0.9em;">ÌòÑÏû¨ Îßµ: (Ï†ÄÏû•ÎêòÏßÄ ÏïäÏùå)</div>
            <div id="save-controls">
                <button id="btn-save-as" class="io-btn" onclick="saveMapAs()">üíæ Ï†ÄÏû• / Ïù¥Î¶ÑÎ≥ÄÍ≤Ω</button>
                <button id="btn-delete-map" class="io-btn" onclick="deleteCurrentMap()">üóë ÏÇ≠Ï†ú</button>
            </div>
            <textarea id="import-input" placeholder="ÏΩîÎìú Î∂ôÏó¨ÎÑ£Í∏∞..."></textarea>
            <div class="io-btn-group">
                <button id="btn-export" class="io-btn" onclick="exportMapCode()">üìã ÏΩîÎìú Î≥µÏÇ¨</button>
                <button id="btn-import" class="io-btn" onclick="importMapCode()">üìÇ ÏΩîÎìú Î∂àÎü¨Ïò§Í∏∞</button>
            </div>
        </div>

        <button id="clear-editor-btn" onclick="clearMapData()">‚ö° Îßµ Ï¥àÍ∏∞Ìôî (ÏßÄÏö∞Í∏∞)</button>

        <div class="editor-section">
            <div class="editor-title">Í∏∞Î≥∏ ÎèÑÍµ¨</div>
            <button class="tool-btn selected" onclick="selectTool('ERASER')"><span>‚¨ú ÏßÄÏö∞Í∞ú</span></button>
        </div>
        <div class="editor-section">
            <div class="editor-title">Î∂ÑÏáÑÍ∞ÄÎä•Î≤Ω (Breakable)</div>
            <button class="tool-btn" onclick="selectTool('CUSTOM_DRAW')"><span>‚úèÔ∏è <b>ÏßÅÏ†ë Í∑∏Î¶¨Í∏∞ (ÌÅ¥Î¶≠/ÎìúÎûòÍ∑∏)</b></span></button>
        </div>
        <div class="editor-section">
            <div class="editor-title">‚¨õ Í±¥Ï∂ïÎ¨º (3x3 - Ï†ÑÏ≤¥)</div>
            <button class="tool-btn" onclick="selectTool('FULL')"><span>‚¨õ 3x3 ÍΩâ Ï∞¨ ÏÉÅÏûê</span></button>
        </div>
        <div class="editor-section">
            <div class="editor-title">‚¨õ Í±¥Ï∂ïÎ¨º (1x3 - Î∂ÄÎ∂Ñ)</div>
            <div class="preset-group">
                <button onclick="selectTool('BLK_T')">‚¨Ü ÏÉÅÎã®</button>
                <button onclick="selectTool('BLK_B')">‚¨á ÌïòÎã®</button>
                <button onclick="selectTool('BLK_L')">‚¨Ö Ï¢åÏ∏°</button>
                <button onclick="selectTool('BLK_R')">‚û° Ïö∞Ï∏°</button>
                <button onclick="selectTool('BLK_M_H')">‚ûñ Ï§ëÏïô(Í∞Ä)</button>
                <button onclick="selectTool('BLK_M_V')">‚ùò Ï§ëÏïô(ÏÑ∏)</button>
            </div>
        </div>
        <div class="editor-section">
            <div class="editor-title">‚ñ® Î∞©Ïñ¥Î≤Ω (1x2 - Î∂ÄÎ∂Ñ)</div>
            <div class="preset-group">
                <button onclick="selectTool('GRY_T')">‚¨Ü ÏÉÅÎã®</button>
                <button onclick="selectTool('GRY_B')">‚¨á ÌïòÎã®</button>
                <button onclick="selectTool('GRY_L')">‚¨Ö Ï¢åÏ∏°</button>
                <button onclick="selectTool('GRY_R')">‚û° Ïö∞Ï∏°</button>
                <button onclick="selectTool('GRY_M_H')">‚ûñ Ï§ëÏïô(Í∞Ä)</button>
                <button onclick="selectTool('GRY_M_V')">‚ùò Ï§ëÏïô(ÏÑ∏)</button>
            </div>
        </div>
    </div>

    <script>
        const container = document.getElementById('grid-container');
        const infoPanel = document.getElementById('info-panel');
        const rangeText = document.getElementById('range-text');
        const detailText = document.getElementById('detail-text');
        const statusText = document.getElementById('status-text');
        const editorPanel = document.getElementById('editor-panel');
        const simControls = document.getElementById('sim-controls');
        const tickDisplay = document.getElementById('tick-display');
        const importInput = document.getElementById('import-input');
        const mapSelector = document.getElementById('map-selector');
        const currentMapNameDisplay = document.getElementById('current-map-name');

        const btnUnits = document.getElementById('btn-units');
        const unitPanel = document.getElementById('unit-panel');
        const unitToolButtons = {
            LARGE: document.getElementById('btn-unit-large'),
            DRONE: document.getElementById('btn-unit-drone'),
            LOW: document.getElementById('btn-unit-low'),
            ERASE: document.getElementById('btn-unit-erase'),
        };
        
        const widthInput = document.getElementById('grid-width-input');
        const heightInput = document.getElementById('grid-height-input');
        
        let tiles = []; 
        let isEditorMode = false;
        let isSimMode = false;
        let isRangeMode = false; 
        let isArea1Active = false; 
        let isArea2Active = false;
        let isLOSActive = false;
        let isMouseDown = false;
        let currentTool = 'ERASER'; 

        let isUnitPanelVisible = false;
        let unitTool = null;
        let unitBlocks = [];
        let unitCellToBlock = new Map();
        let nextUnitBlockId = 1;
        let isUnitDragging = false;
        let unitPreviewCells = null;

        let rangeDir = null;
        let isRangeDirOverlayVisible = false;
        const rangeDirOverlay = document.getElementById('range-dir-overlay');
        const rangeDirButtons = {};

        let simDir = null;
        let isSimDirOverlayVisible = false;
        const simDirOverlay = document.getElementById('sim-dir-overlay');
        const simDirButtons = {};

        function buildRangeDirOverlay() {
            if (!rangeDirOverlay) return;
            rangeDirOverlay.innerHTML = '';
            function mkBtn(dir, label) {
                const b = document.createElement('button');
                b.type = 'button'; b.className = 'dir-btn'; b.dataset.dir = dir;
                b.setAttribute('aria-label', 'Î∞©Ìñ• ÏÑ†ÌÉù: ' + dir); b.textContent = label;
                b.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); setRangeDirection(dir); });
                return b;
            }
            rangeDirButtons.UP = mkBtn('UP', '‚ñ≤'); rangeDirButtons.DOWN = mkBtn('DOWN', '‚ñº');
            rangeDirButtons.LEFT = mkBtn('LEFT', '‚óÄ'); rangeDirButtons.RIGHT = mkBtn('RIGHT', '‚ñ∂');
            rangeDirOverlay.append(rangeDirButtons.UP, rangeDirButtons.DOWN, rangeDirButtons.LEFT, rangeDirButtons.RIGHT);
            rangeDirOverlay.addEventListener('pointerdown', (e) => { e.stopPropagation(); });
        }

        function buildSimDirOverlay() {
            if (!simDirOverlay) return;
            simDirOverlay.innerHTML = '';
            function mkBtn(dir, label) {
                const b = document.createElement('button');
                b.type = 'button'; b.className = 'dir-btn'; b.dataset.dir = dir;
                b.setAttribute('aria-label', 'ÏãúÎÆ¨Î†àÏù¥ÌÑ∞ Î∞©Ìñ• ÏÑ†ÌÉù: ' + dir); b.textContent = label;
                b.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); setSimDirection(dir); });
                return b;
            }
            simDirButtons.UP = mkBtn('UP', '‚ñ≤'); simDirButtons.DOWN = mkBtn('DOWN', '‚ñº');
            simDirButtons.LEFT = mkBtn('LEFT', '‚óÄ'); simDirButtons.RIGHT = mkBtn('RIGHT', '‚ñ∂');
            simDirOverlay.append(simDirButtons.UP, simDirButtons.DOWN, simDirButtons.LEFT, simDirButtons.RIGHT);
            simDirOverlay.addEventListener('pointerdown', (e) => { e.stopPropagation(); });
        }

        function hideSimDirOverlay() {
            isSimDirOverlayVisible = false; if (!simDirOverlay) return;
            simDirOverlay.style.display = 'none'; simDirOverlay.classList.remove('visible');
        }

        function showSimDirOverlayAtTile(tx, ty) {
            if (!simDirOverlay) return;
            if (!Object.keys(simDirButtons).length) buildSimDirOverlay();
            const wrapEl = document.getElementById('grid-wrap'); if (!wrapEl) return;
            const wrapRect = wrapEl.getBoundingClientRect();
            const neigh = { UP: { x: tx, y: ty - 1 }, DOWN: { x: tx, y: ty + 1 }, LEFT: { x: tx - 1, y: ty }, RIGHT: { x: tx + 1, y: ty } };

            for (const dir of ['UP','DOWN','LEFT','RIGHT']) {
                const b = simDirButtons[dir]; if (!b) continue;
                const nx = neigh[dir].x, ny = neigh[dir].y;
                if (nx < 0 || ny < 0 || nx >= currentGridWidth || ny >= currentGridHeight) { b.style.display = 'none'; continue; }
                const nIdx = ny * currentGridWidth + nx; const nTileEl = tiles[nIdx];
                if (!nTileEl) { b.style.display = 'none'; continue; }
                const r = nTileEl.getBoundingClientRect();
                b.style.display = 'flex'; b.style.left = (r.left - wrapRect.left) + 'px'; b.style.top  = (r.top  - wrapRect.top) + 'px';
                b.style.width = r.width + 'px'; b.style.height = r.height + 'px';
                b.classList.toggle('selected', simDir === dir);
            }
            simDirOverlay.style.display = 'block'; simDirOverlay.classList.add('visible'); isSimDirOverlayVisible = true;
        }

        function setSimDirection(dir) {
            simDir = (simDir === dir) ? null : dir;
            const o = getCurrentOrigin?.();
            if (o && isSimMode && simSegments.length === maxTicks) showSimDirOverlayAtTile(o.x, o.y);
            updateLOS();
        }

        function hideRangeDirOverlay() {
            isRangeDirOverlayVisible = false; if (!rangeDirOverlay) return;
            rangeDirOverlay.style.display = 'none'; rangeDirOverlay.classList.remove('visible');
        }

        function showRangeDirOverlayAtTile(tx, ty) {
            if (!rangeDirOverlay) return;
            if (!Object.keys(rangeDirButtons).length) buildRangeDirOverlay();
            const wrapEl = document.getElementById('grid-wrap'); if (!wrapEl) return;
            const wrapRect = wrapEl.getBoundingClientRect();
            const neigh = { UP: { x: tx, y: ty - 1 }, DOWN: { x: tx, y: ty + 1 }, LEFT: { x: tx - 1, y: ty }, RIGHT: { x: tx + 1, y: ty } };

            for (const dir of ['UP','DOWN','LEFT','RIGHT']) {
                const b = rangeDirButtons[dir]; if (!b) continue;
                const nx = neigh[dir].x, ny = neigh[dir].y;
                if (nx < 0 || ny < 0 || nx >= currentGridWidth || ny >= currentGridHeight) { b.style.display = 'none'; continue; }
                const nIdx = ny * currentGridWidth + nx; const nTileEl = tiles[nIdx];
                if (!nTileEl) { b.style.display = 'none'; continue; }
                const r = nTileEl.getBoundingClientRect();
                b.style.display = 'flex'; b.style.left = (r.left - wrapRect.left) + 'px'; b.style.top  = (r.top  - wrapRect.top) + 'px';
                b.style.width = r.width + 'px'; b.style.height = r.height + 'px';
                b.classList.toggle('selected', rangeDir === dir);
            }
            rangeDirOverlay.style.display = 'block'; rangeDirOverlay.classList.add('visible'); isRangeDirOverlayVisible = true;
        }

        function setRangeDirection(dir) {
            rangeDir = (rangeDir === dir) ? null : dir;
            hideRangeDirOverlay();
            updateLOS();
        }

        function turnOffUnitTool() { if (typeof setUnitPanelVisible === 'function') setUnitPanelVisible(false); }
        function updateUnitButtonAvailability() { if (!btnUnits) return; btnUnits.disabled = false; }
        
        let currentGridWidth = 12;
        let currentGridHeight = 12;
        const headerEl = document.querySelector('.ui-header');
        const bottomEl = document.querySelector('.bottom-ui');

        function applyResponsiveLayout() {
            const base = 65;
            const bodyStyle = getComputedStyle(document.body);
            const padX = (parseFloat(bodyStyle.paddingLeft) || 0) + (parseFloat(bodyStyle.paddingRight) || 0);
            const padY = (parseFloat(bodyStyle.paddingTop) || 0) + (parseFloat(bodyStyle.paddingBottom) || 0);
            const viewportW = Math.max(0, window.innerWidth - padX - 8);
            const viewportH = Math.max(0, window.innerHeight - padY - 8);
            const headerH = headerEl ? headerEl.getBoundingClientRect().height : 0;
            const bottomH = bottomEl ? bottomEl.getBoundingClientRect().height : 0;
            const unitPanelH = (unitPanel && isUnitPanelVisible) ? unitPanel.getBoundingClientRect().height : 0;
            const toggleH = toggleRowEl ? toggleRowEl.getBoundingClientRect().height : 0;
            const availableW = Math.max(0, viewportW - 20);
            const availableH = Math.max(0, viewportH - headerH - bottomH - toggleH - unitPanelH - 20);
            let tileSize = Math.floor(Math.min(base, availableW / currentGridWidth, availableH / currentGridHeight));
            tileSize = Math.max(22, tileSize);
            container.style.setProperty('--tile-size', `${tileSize}px`);
            container.style.gridTemplateColumns = `repeat(${currentGridWidth}, var(--tile-size))`;
            container.style.gridTemplateRows = `repeat(${currentGridHeight}, var(--tile-size))`;
            if (isSimMode && startPoint && simSegments.length === maxTicks) {
                const o = getCurrentOrigin(); if (o) showSimDirOverlayAtTile(o.x, o.y);
            }
        }

        const headerToggleBtn = document.getElementById('btn-header-toggle');
        const toggleRowEl = document.getElementById('map-toggle-row');
        let headerCollapsed = false;

        function toggleHeaderUI(forceState) {
            headerCollapsed = (typeof forceState === 'boolean') ? forceState : !headerCollapsed;
            if (!headerEl) return;
            headerEl.classList.toggle('collapsed', headerCollapsed);
            if (headerToggleBtn) {
                headerToggleBtn.textContent = headerCollapsed ? '‚ñæ' : '‚ñ¥';
                headerToggleBtn.setAttribute('aria-label', headerCollapsed ? 'ÏÉÅÎã® Î©îÎâ¥ ÌéºÏπòÍ∏∞' : 'ÏÉÅÎã® Î©îÎâ¥ Ï†ëÍ∏∞');
                headerToggleBtn.setAttribute('aria-expanded', headerCollapsed ? 'false' : 'true');
            }
            setTimeout(applyResponsiveLayout, 0);
        }

        window.addEventListener('resize', () => applyResponsiveLayout(), { passive: true });
        window.addEventListener('orientationchange', () => setTimeout(applyResponsiveLayout, 60), { passive: true });

        let isPointerDown = false;
        let lastPointerKey = null;

        function getHitFromPoint(clientX, clientY) {
            const el = document.elementFromPoint(clientX, clientY);
            if (!el) return null;
            const tileEl = el.classList?.contains('tile') ? el : el.closest?.('.tile');
            if (!tileEl) return null;
            const x = parseInt(tileEl.dataset.x, 10);
            const y = parseInt(tileEl.dataset.y, 10);
            if (Number.isNaN(x) || Number.isNaN(y)) return null;
            return { tileEl, x, y, targetEl: el };
        }

        function processPointerAt(clientX, clientY, isDownAction) {
            const hit = getHitFromPoint(clientX, clientY);
            if (!hit) return;
            const isSub = hit.targetEl.classList?.contains('subcell');
            const subIdx = isSub ? (hit.targetEl.dataset.idx ?? '') : '';
            const key = `${hit.x},${hit.y}:${subIdx}`;
            if (!isDownAction && key === lastPointerKey) return;
            lastPointerKey = key;

            if (unitTool) {
                if (unitTool === 'ERASE') {
                    if (isDownAction || isPointerDown) tryPlaceUnitAt(hit);
                } else {
                    if (isDownAction) beginUnitDrag(hit);
                    else if (isPointerDown && isUnitDragging) updateUnitDrag(hit);
                }
                return;
            }
            if (isEditorMode) { handleEditorClick({ target: hit.targetEl }, hit.x, hit.y); return; }
            if (isSimMode) {
                if (isDownAction) handleSimClick(hit.x, hit.y);
                else handleSimHover(hit.x, hit.y);
                return;
            }
            if (isDownAction) handleMeasureClick(hit.x, hit.y);
            else handleMeasureHover(hit.x, hit.y);
        }

        container.addEventListener('pointerdown', (e) => {
            if (e.button !== undefined && e.button !== 0) return;
            isPointerDown = true; lastPointerKey = null;
            try { container.setPointerCapture(e.pointerId); } catch (_) {}
            e.preventDefault(); processPointerAt(e.clientX, e.clientY, true);
        }, { passive: false });

        container.addEventListener('pointermove', (e) => {
            if (!isPointerDown) {
                if (e.pointerType === 'mouse' && !isEditorMode) processPointerAt(e.clientX, e.clientY, false);
                return;
            }
            e.preventDefault(); processPointerAt(e.clientX, e.clientY, false);
        }, { passive: false });

        window.addEventListener('pointerup', () => { if (isUnitDragging) commitUnitDrag(); isPointerDown = false; lastPointerKey = null; }, { passive: true });
        window.addEventListener('pointercancel', () => { if (isUnitDragging) cancelUnitDrag(); isPointerDown = false; lastPointerKey = null; }, { passive: true });

        let startPoint = null;
        let isLocked = false;
        let maxTicks = 3;
        let rangeValue = 4;
        let simSegments = []; 
        let lockedAxis = null; 
        let currentEditingMapName = null;
        window.addEventListener('mouseup', () => { isMouseDown = false; });

        const defaultMaps = {
            hotspot: [
                {x:9, y:1, t:'CONTAINER', idx:[8]}, {x:7, y:2, t:'FULL'}, {x:8, y:2, t:'CONTAINER', idx:[2]}, {x:10, y:2, t:'BLK_B'},
                {x:2, y:3, t:'GRY_R'}, {x:7, y:3, t:'FULL'}, {x:2, y:4, t:'BLK_T'}, {x:5, y:4, t:'BLK_T'}, {x:6, y:4, t:'CONTAINER', idx:[2,5]},
                {x:8, y:4, t:'FULL'}, {x:9, y:4, t:'CONTAINER', idx:[7,8]}, {x:10, y:4, t:'CONTAINER', idx:[3,6]}, {x:4, y:5, t:'CONTAINER', idx:[2]},
                {x:8, y:5, t:'GRY_R'}, {x:3, y:6, t:'GRY_L'}, {x:7, y:6, t:'CONTAINER', idx:[6]}, {x:1, y:7, t:'CONTAINER', idx:[2,5]},
                {x:2, y:7, t:'CONTAINER', idx:[0,1]}, {x:3, y:7, t:'FULL'}, {x:5, y:7, t:'CONTAINER', idx:[3,6]}, {x:6, y:7, t:'BLK_B'},
                {x:9, y:7, t:'BLK_B'}, {x:4, y:8, t:'FULL'}, {x:9, y:8, t:'GRY_L'}, {x:1, y:9, t:'BLK_T'}, {x:3, y:9, t:'CONTAINER', idx:[0]},
                {x:4, y:9, t:'FULL'}, {x:2, y:10, t:'CONTAINER', idx:[0]}
            ],
            crossroads: [
                {x:8, y:2, t:'BLK_L'}, {x:4, y:3, t:'GRY_R'}, {x:8, y:3, t:'FULL'}, {x:9, y:3, t:'GRY_T'}, {x:0, y:4, t:'CONTAINER', idx:[7,8]},
                {x:1, y:4, t:'BLK_B'}, {x:2, y:4, t:'BLK_B'}, {x:3, y:4, t:'FULL'}, {x:4, y:4, t:'FULL'}, {x:5, y:4, t:'CONTAINER', idx:[7,8]},
                {x:6, y:4, t:'CONTAINER', idx:[5,8]}, {x:8, y:4, t:'GRY_R'}, {x:4, y:5, t:'CONTAINER', idx:[8]}, {x:7, y:6, t:'CONTAINER', idx:[0]},
                {x:3, y:7, t:'GRY_L'}, {x:5, y:7, t:'CONTAINER', idx:[0,3]}, {x:6, y:7, t:'CONTAINER', idx:[0,1]}, {x:7, y:7, t:'FULL'},
                {x:8, y:7, t:'FULL'}, {x:9, y:7, t:'BLK_T'}, {x:10, y:7, t:'BLK_T'}, {x:11, y:7, t:'CONTAINER', idx:[0,1]}, {x:2, y:8, t:'GRY_B'},
                {x:3, y:8, t:'FULL'}, {x:7, y:8, t:'GRY_L'}, {x:3, y:9, t:'BLK_R'}
            ],
            alley: [
                {x:5, y:2, t:'BLK_B'}, {x:10, y:2, t:'GRY_L'}, {x:3, y:3, t:'GRY_L'}, {x:4, y:3, t:'CONTAINER', idx:[5,8]}, {x:6, y:3, t:'CONTAINER', idx:[8]},
                {x:0, y:4, t:'BLK_T'}, {x:2, y:4, t:'CONTAINER', idx:[6,7]}, {x:4, y:4, t:'BLK_T'}, {x:6, y:4, t:'FULL'}, {x:8, y:4, t:'FULL'},
                {x:9, y:4, t:'GRY_T'}, {x:10, y:4, t:'CONTAINER', idx:[8]}, {x:3, y:5, t:'CONTAINER', idx:[5,8]}, {x:7, y:5, t:'FULL'},
                {x:11, y:5, t:'CONTAINER', idx:[0]}, {x:0, y:6, t:'CONTAINER', idx:[8]}, {x:4, y:6, t:'FULL'}, {x:8, y:6, t:'CONTAINER', idx:[0,3]},
                {x:1, y:7, t:'CONTAINER', idx:[0]}, {x:2, y:7, t:'GRY_B'}, {x:3, y:7, t:'FULL'}, {x:5, y:7, t:'FULL'}, {x:7, y:7, t:'BLK_B'},
                {x:9, y:7, t:'CONTAINER', idx:[1,2]}, {x:11, y:7, t:'BLK_B'}, {x:5, y:8, t:'CONTAINER', idx:[0]}, {x:7, y:8, t:'CONTAINER', idx:[0,3]},
                {x:8, y:8, t:'GRY_R'}, {x:1, y:9, t:'GRY_R'}, {x:6, y:9, t:'BLK_T'}
            ]
        };

        let savedMaps = {};
        function initMapStorage() {
            const stored = localStorage.getItem('obsidian_saved_maps_v2');
            if (stored) { try { savedMaps = JSON.parse(stored); } catch(e) { savedMaps = {}; } }
            refreshMapDropdown();
        }

        function refreshMapDropdown() {
            mapSelector.innerHTML = '<option value="" disabled selected>-- Ï†ÄÏû•Îêú Îßµ ÏÑ†ÌÉù --</option>';
            Object.keys(savedMaps).sort().forEach(name => {
                const opt = document.createElement('option');
                opt.value = name; opt.textContent = name;
                mapSelector.appendChild(opt);
            });
            const newOpt = document.createElement('option');
            newOpt.value = "__NEW__"; newOpt.textContent = "< ÏÉà Îßµ Ï∂îÍ∞Ä >";
            newOpt.style.color = "#4fc3f7"; newOpt.style.fontWeight = "bold";
            mapSelector.appendChild(newOpt);
        }

        function applySymmetry(mode) {
            const W = currentGridWidth, H = currentGridHeight, halfH = Math.ceil(H / 2), halfW = Math.ceil(W / 2);
            let startX = 0, endX = W, startY = 0, endY = H;
            if (mode === 'T2B') endY = halfH; 
            else if (mode === 'B2T') startY = Math.floor(H/2);
            else if (mode === 'L2R') endX = halfW;
            else if (mode === 'R2L') startX = Math.floor(W/2);

            const updates = [];
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const srcIdx = y * W + x; const srcTile = tiles[srcIdx];
                    const tx = (W - 1) - x; const ty = (H - 1) - y;
                    const subcells = srcTile.querySelectorAll('.subcell');
                    const cellData = [];
                    for(let i=0; i<9; i++) {
                        const cl = subcells[i].classList;
                        if(cl.contains('obs-full')) cellData.push('obs-full');
                        else if(cl.contains('obs-partial')) cellData.push('obs-partial');
                        else if(cl.contains('obs-weak')) cellData.push('obs-weak');
                        else cellData.push(null);
                    }
                    updates.push({tx, ty, cellData});
                }
            }
            updates.forEach(up => {
                const tgtIdx = up.ty * W + up.tx; const tgtTile = tiles[tgtIdx]; if (!tgtTile) return;
                for(let i=0; i<9; i++) tgtTile.children[i+1].className = 'subcell';
                for(let i=0; i<9; i++) { if (up.cellData[i]) tgtTile.children[(8-i)+1].classList.add(up.cellData[i]); }
            });
            updateLOS(); alert("ÎåÄÏπ≠ Î≥µÏÇ¨ ÏôÑÎ£å!");
        }

        function toggleLOS() {
            setUnitPanelVisible(false); isLOSActive = !isLOSActive;
            const btn = document.getElementById('btn-los');
            if(isLOSActive) btn.classList.add('active'); else btn.classList.remove('active');
            updateLOS(); updateUnitButtonAvailability();
        }

        function toggleRangeMode() {
            setUnitPanelVisible(false);
            if(isEditorMode) toggleEditor(); if(isSimMode) toggleSimulator();
            isRangeMode = !isRangeMode;
            const btn = document.getElementById('btn-range');
            if(isRangeMode) {
                btn.classList.add('active'); simControls.classList.add('visible'); infoPanel.classList.add('range-mode');
                tickDisplay.textContent = `ÏÇ¨Í±∞Î¶¨ : ${rangeValue}`; rangeText.textContent = "ÏÇ¨Í±∞Î¶¨ ÌôïÏù∏ Î™®Îìú";
                detailText.textContent = `ÌòÑÏû¨ ÏÑ§Ï†ïÎêú ÏÇ¨Í±∞Î¶¨: ${rangeValue}`; statusText.textContent = "ÎßµÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ ÏÇ¨Í±∞Î¶¨ÏôÄ ÏãúÏïºÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî";
                resetMeasureState();
            } else {
                btn.classList.remove('active'); simControls.classList.remove('visible'); infoPanel.classList.remove('range-mode');
                resetMeasureState();
            }
            updateLOS(); applyResponsiveLayout(); updateUnitButtonAvailability();
        }

        function updateLOS() {
            document.querySelectorAll('.subcell').forEach(s => s.classList.remove('sub-visible', 'in-range'));
            let origin = null;
            if (simSegments.length > 0) origin = simSegments[simSegments.length - 1].end;
            else if (startPoint) origin = startPoint;

            if (isRangeMode && origin) {
                calculateRangeArea(origin); calculateLOS(origin, rangeDir); 
            } else if (isSimMode && origin && startPoint && simSegments.length === maxTicks) {
                calculateLOS(origin, simDir);
            } else if (isLOSActive && origin) {
                calculateLOS(origin);
            }
            updateUnitHighlights(origin);
        }

        function calculateRangeArea(origin) {
            for(let y=0; y<currentGridHeight; y++) {
                for(let x=0; x<currentGridWidth; x++) {
                    const dist = Math.abs(x - origin.x) + Math.abs(y - origin.y);
                    if (dist <= rangeValue) {
                        const idx = y * currentGridWidth + x; const tile = tiles[idx];
                        for(let i=0; i<9; i++) tile.children[i+1].classList.add('in-range');
                    }
                }
            }
        }

        function calculateLOS(origin, dir = null) {
            const tileX = origin.x * 3, tileY = origin.y * 3;
            const ocx = tileX + 1.5, ocy = tileY + 1.5;
            let originPoints; const faceInset = 0.05;

            if (!dir) {
                originPoints = [ {x: ocx, y: ocy}, {x: tileX+faceInset, y: tileY+faceInset}, {x: tileX+3-faceInset, y: tileY+faceInset}, {x: tileX+faceInset, y: tileY+3-faceInset}, {x: tileX+3-faceInset, y: tileY+3-faceInset} ];
            } else {
                originPoints = [{x: ocx, y: ocy}];
                if (dir === 'UP' || dir === 'DOWN') {
                    const fy = (dir === 'UP') ? (tileY + faceInset) : (tileY + 3 - faceInset);
                    originPoints.push({x: tileX + faceInset, y: fy}, {x: tileX + 0.75, y: fy}, {x: ocx, y: fy}, {x: tileX + 2.25, y: fy}, {x: tileX + 3 - faceInset, y: fy});
                } else if (dir === 'LEFT' || dir === 'RIGHT') {
                    const fx = (dir === 'LEFT') ? (tileX + faceInset) : (tileX + 3 - faceInset);
                    originPoints.push({x: fx, y: tileY + faceInset}, {x: fx, y: tileY + 0.75}, {x: fx, y: ocy}, {x: fx, y: tileY + 2.25}, {x: fx, y: tileY + 3 - faceInset});
                }
                if (dir === 'UP') originPoints.push({x: tileX, y: tileY}, {x: tileX + 3, y: tileY});
                else if (dir === 'DOWN') originPoints.push({x: tileX, y: tileY + 3}, {x: tileX + 3, y: tileY + 3});
                else if (dir === 'LEFT') originPoints.push({x: tileX, y: tileY}, {x: tileX, y: tileY + 3});
                else if (dir === 'RIGHT') originPoints.push({x: tileX + 3, y: tileY}, {x: tileX + 3, y: tileY + 3});
            }

            const xL0 = tileX, xR0 = tileX + 3, yT0 = tileY, yB0 = tileY + 3;
            const blockers = []; const blockedSet = new Set();
            for(let y=0; y<currentGridHeight; y++) {
                for(let x=0; x<currentGridWidth; x++) {
                    const idx = y * currentGridWidth + x; const tile = tiles[idx];
                    for(let i=0; i<9; i++) {
                        if(tile.children[i+1].classList.contains('obs-full')) {
                            const bx = x * 3 + (i % 3), by = y * 3 + Math.floor(i / 3);
                            blockers.push({ x: bx, y: by, w: 1, h: 1, tx: x, ty: y }); blockedSet.add(`${bx},${by}`);
                        }
                    }
                }
            }

            const gridW = currentGridWidth * 3, gridH = currentGridHeight * 3, gapSize = 0.02, gapOffset = gapSize / 2;
            for (let gy = 0; gy < gridH - 1; gy++) {
                for (let gx = 0; gx < gridW - 1; gx++) {
                    const tl = blockedSet.has(`${gx},${gy}`), tr = blockedSet.has(`${gx+1},${gy}`);
                    const bl = blockedSet.has(`${gx},${gy+1}`), br = blockedSet.has(`${gx+1},${gy+1}`);
                    if ((tl && br && !tr && !bl) || (tr && bl && !tl && !br)) {
                        blockers.push({ x: (gx + 1) - gapOffset, y: (gy + 1) - gapOffset, w: gapSize, h: gapSize, isGapStopper: true });
                    }
                }
            }

            for (let gy = 0; gy < gridH; gy++) {
                for (let gx = 0; gx < gridW; gx++) {
                    const tx = Math.floor(gx / 3), ty = Math.floor(gy / 3);
                    const tileIdx = ty * currentGridWidth + tx; const tile = tiles[tileIdx];
                    const subIdx = (gy % 3) * 3 + (gx % 3);
                    if (!tile || tile.children[subIdx + 1].classList.contains('obs-full')) continue;
                    
                    const tInset = 0.05, baseX = gx, baseY = gy;
                    const targetPoints = [
                        {x: baseX + 0.5, y: baseY + 0.5}, {x: baseX, y: baseY}, {x: baseX + 1, y: baseY},
                        {x: baseX, y: baseY + 1}, {x: baseX + 1, y: baseY + 1},
                        {x: baseX + tInset, y: baseY + tInset}, {x: baseX + 1 - tInset, y: baseY + tInset},
                        {x: baseX + tInset, y: baseY + 1 - tInset}, {x: baseX + 1 - tInset, y: baseY + 1 - tInset}
                    ];

                    if (dir) {
                        const tcx = baseX + 0.5, tcy = baseY + 0.5, eps = 0.001;
                        if (dir === 'UP' && (yT0 - tcy <= eps || tcx < (xL0 - (yT0 - tcy) - eps) || tcx > (xR0 + (yT0 - tcy) + eps))) continue;
                        if (dir === 'DOWN' && (tcy - yB0 <= eps || tcx < (xL0 - (tcy - yB0) - eps) || tcx > (xR0 + (tcy - yB0) + eps))) continue;
                        if (dir === 'LEFT' && (xL0 - tcx <= eps || tcy < (yT0 - (xL0 - tcx) - eps) || tcy > (yB0 + (xL0 - tcx) + eps))) continue;
                        if (dir === 'RIGHT' && (tcx - xR0 <= eps || tcy < (yT0 - (tcx - xR0) - eps) || tcy > (yB0 + (tcx - xR0) + eps))) continue;
                    }

                    let isVisible = false;
                    outerCheck: for (let op of originPoints) {
                        for (let tp of targetPoints) {
                            if (!isRayBlocked(op.x, op.y, tp.x, tp.y, blockers, gx, gy)) { isVisible = true; break outerCheck; }
                        }
                    }
                    if (isVisible) tile.children[subIdx + 1].classList.add('sub-visible');
                }
            }
        }

        function isRayBlocked(x0, y0, x1, y1, blockers, targetSubX, targetSubY) {
            for (let b of blockers) {
                if (!b.isGapStopper && b.x === targetSubX && b.y === targetSubY) continue;
                if (lineIntersectsBox(x0, y0, x1, y1, b.x, b.y, b.w||1, b.h||1)) return true;
            }
            return false;
        }

        function lineIntersectsBox(x1, y1, x2, y2, bx, by, bw, bh) {
            const minX = bx, minY = by, maxX = bx + bw, maxY = by + bh;
            const dx = x2 - x1, dy = y2 - y1;
            let t0 = 0.0, t1 = 1.0;
            const p = [-dx, dx, -dy, dy]; const q = [x1 - minX, maxX - x1, y1 - minY, maxY - y1];
            for (let i = 0; i < 4; i++) {
                if (p[i] === 0) { if (q[i] < 0) return false; }
                else {
                    const t = q[i] / p[i];
                    if (p[i] < 0) { if (t > t1) return false; if (t > t0) t0 = t; }
                    else { if (t < t0) return false; if (t < t1) t1 = t; }
                }
            }
            const EPS = 1e-9;
            const seg = t1 - t0;
            if (seg > EPS) return true;
            const t = (t0 + t1) * 0.5;
            if (t <= EPS) return false;
            return true;
        }

        function toggleArea1() {
            if(isArea2Active) toggleArea2(); isArea1Active = !isArea1Active;
            const btn = document.getElementById('btn-area1');
            if(isArea1Active) btn.classList.add('active'); else btn.classList.remove('active');
            updateAreaOverlay();
        }

        function toggleArea2() {
            if(isArea1Active) toggleArea1(); isArea2Active = !isArea2Active;
            const btn = document.getElementById('btn-area2');
            if(isArea2Active) btn.classList.add('active'); else btn.classList.remove('active');
            updateAreaOverlay();
        }

        function updateAreaOverlay() {
            tiles.forEach(t => { t.classList.remove('area-red', 'area-blue'); });
            for(let y=0; y<currentGridHeight; y++) {
                for(let x=0; x<currentGridWidth; x++) {
                    const idx = y * currentGridWidth + x; const tile = tiles[idx]; if(!tile) continue;
                    if (isArea1Active) {
                        if (x >= 0 && x <= 4 && y >= 0 && y <= 2) tile.classList.add('area-red');
                        if (x >= 7 && x <= 11 && y >= 9 && y <= 11) tile.classList.add('area-blue');
                    }
                    if (isArea2Active) {
                        if (y >= 0 && y <= 1 && x >= 0 && x <= 11) tile.classList.add('area-red');
                        if (y >= 10 && y <= 11 && x >= 0 && x <= 11) tile.classList.add('area-blue');
                    }
                }
            }
        }

        function setUnitPanelVisible(visible) {
            isUnitPanelVisible = !!visible;
            if (unitPanel) unitPanel.classList.toggle('visible', isUnitPanelVisible);
            if (btnUnits) btnUnits.classList.toggle('active', isUnitPanelVisible);
            if (!isUnitPanelVisible) { cancelUnitDrag(); unitTool = null; refreshUnitToolButtons(); }
            setTimeout(applyResponsiveLayout, 0);
        }

        function toggleUnitPanel() { if (btnUnits && btnUnits.disabled) return; setUnitPanelVisible(!isUnitPanelVisible); }
        function refreshUnitToolButtons() { Object.keys(unitToolButtons).forEach(k => { const btn = unitToolButtons[k]; if (btn) btn.classList.toggle('active', unitTool === k); }); }
        
        function selectUnitTool(tool) {
            if (!isUnitPanelVisible) setUnitPanelVisible(true);
            unitTool = (unitTool === tool) ? null : tool;
            cancelUnitDrag(); refreshUnitToolButtons();
            if (unitTool) {
                detailText.textContent = 'Í∏∞Ï≤¥ Î∞∞Ïπò Î™®Îìú';
                statusText.textContent = (unitTool === 'ERASE') ? 'Í∏∞Ï≤¥ Ï†úÍ±∞: Í∏∞Ï≤¥ Î∏îÎü≠ÏùÑ ÌÅ¥Î¶≠/ÎìúÎûòÍ∑∏ÌïòÏó¨ ÏÇ≠Ï†ú' : 'Í∏∞Ï≤¥ Ï∂îÍ∞Ä: ÌÅ¥Î¶≠ ÌõÑ ÎìúÎûòÍ∑∏Î°ú Ïù¥ÎèôÌïòÏó¨ ÎÜìÏúºÎ©¥ Î∞∞ÏπòÎê©ÎãàÎã§';
            } else {
                if (isSimMode) detailText.textContent = "ÏãúÏûë ÏßÄÏ†êÏùÑ ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî";
                else if (isRangeMode) detailText.textContent = "ÏÇ¨Í±∞Î¶¨ Ï∏°Ï†ï";
                else if (isLOSActive) detailText.textContent = "LOS ÌôïÏù∏";
                else detailText.textContent = "ÏùºÎ∞ò Î™®Îìú";
            }
        }

        function getGlobalSubcellFromHit(hit) {
            if (hit?.targetEl?.classList?.contains('subcell')) {
                const idx = parseInt(hit.targetEl.dataset.idx, 10);
                return { gx: hit.x * 3 + (idx % 3), gy: hit.y * 3 + Math.floor(idx / 3) };
            }
            return { gx: hit.x * 3, gy: hit.y * 3 };
        }

        function getSubcellEl(gx, gy) {
            const tx = Math.floor(gx / 3), ty = Math.floor(gy / 3);
            if (tx < 0 || ty < 0 || tx >= currentGridWidth || ty >= currentGridHeight) return null;
            const tile = tiles[ty * currentGridWidth + tx]; if (!tile) return null;
            const subIdx = (gy % 3) * 3 + (gx % 3); return tile.children[subIdx + 1] || null;
        }

        function removeUnitBlockById(blockId) {
            const idx = unitBlocks.findIndex(b => b.id === blockId); if (idx === -1) return;
            const block = unitBlocks[idx];
            block.cells.forEach(c => {
                unitCellToBlock.delete(`${c.gx},${c.gy}`);
                const el = getSubcellEl(c.gx, c.gy); if (el) { el.classList.remove('unit-block', 'unit-highlight', 'unit-obscured'); delete el.dataset.unitId; }
            });
            unitBlocks.splice(idx, 1); updateUnitHighlights(getCurrentOrigin());
        }

        function clearUnitBlocks() {
            unitBlocks.forEach(b => b.cells.forEach(c => { const el = getSubcellEl(c.gx, c.gy); if (el) { el.classList.remove('unit-block', 'unit-highlight', 'unit-obscured'); delete el.dataset.unitId; } }));
            unitBlocks = []; unitCellToBlock = new Map(); nextUnitBlockId = 1;
        }

        function addUnitBlock(type, cells) {
            const id = nextUnitBlockId++; const block = { id, type, cells };
            unitBlocks.push(block);
            cells.forEach(c => {
                unitCellToBlock.set(`${c.gx},${c.gy}`, id);
                const el = getSubcellEl(c.gx, c.gy); if (el) { el.classList.add('unit-block'); el.dataset.unitId = String(id); }
            });
            updateUnitHighlights(getCurrentOrigin()); return block;
        }

        function tryPlaceUnitAt(hit) {
            if (!unitTool) return;
            const { gx, gy } = getGlobalSubcellFromHit(hit);
            if (unitTool === 'ERASE') { const bid = unitCellToBlock.get(`${gx},${gy}`); if (bid) removeUnitBlockById(bid); return; }
            
            let anchorGx = gx, anchorGy = gy, w = 1, h = 1;
            if (unitTool === 'LARGE') { anchorGx = hit.x * 3; anchorGy = hit.y * 3; w = 3; h = 3; }
            else if (unitTool === 'DRONE') { w = 2; h = 2; }
            
            const maxGX = currentGridWidth * 3, maxGY = currentGridHeight * 3;
            if (anchorGx < 0 || anchorGy < 0 || (anchorGx + w) > maxGX || (anchorGy + h) > maxGY) return;
            const cells = [];
            for (let yy = 0; yy < h; yy++) {
                for (let xx = 0; xx < w; xx++) {
                    const cgx = anchorGx + xx, cgy = anchorGy + yy;
                    if (unitCellToBlock.has(`${cgx},${cgy}`)) return;
                    const el = getSubcellEl(cgx, cgy); if (el && el.classList.contains('obs-full')) return;
                    cells.push({ gx: cgx, gy: cgy });
                }
            }
            addUnitBlock(unitTool, cells);
        }

        function cancelUnitDrag() { isUnitDragging = false; clearUnitPreview(); }
        function clearUnitPreview() { if (!unitPreviewCells) return; unitPreviewCells.forEach(c => { const el = getSubcellEl(c.gx, c.gy); if (el) el.classList.remove('unit-preview'); }); unitPreviewCells = null; }
        function setUnitPreview(cells) { clearUnitPreview(); unitPreviewCells = cells; cells.forEach(c => { const el = getSubcellEl(c.gx, c.gy); if (el) el.classList.add('unit-preview'); }); }
        
        function computeUnitCellsAtHit(tool, hit) {
            if (!tool || tool === 'ERASE') return null;
            const { gx, gy } = getGlobalSubcellFromHit(hit);
            let anchorGx = gx, anchorGy = gy, w = 1, h = 1;
            if (tool === 'LARGE') { anchorGx = hit.x * 3; anchorGy = hit.y * 3; w = 3; h = 3; }
            else if (tool === 'DRONE') { w = 2; h = 2; }
            
            const maxGX = currentGridWidth * 3, maxGY = currentGridHeight * 3;
            if (anchorGx < 0 || anchorGy < 0 || (anchorGx + w) > maxGX || (anchorGy + h) > maxGY) return null;
            const cells = [];
            for (let yy = 0; yy < h; yy++) {
                for (let xx = 0; xx < w; xx++) {
                    const cgx = anchorGx + xx, cgy = anchorGy + yy;
                    if (unitCellToBlock.has(`${cgx},${cgy}`)) return null;
                    const el = getSubcellEl(cgx, cgy); if (el && el.classList.contains('obs-full')) return null;
                    cells.push({ gx: cgx, gy: cgy });
                }
            }
            return cells;
        }

        function beginUnitDrag(hit) { if (!unitTool || unitTool === 'ERASE') return; isUnitDragging = true; updateUnitDrag(hit); }
        function updateUnitDrag(hit) { if (!isUnitDragging) return; const cells = computeUnitCellsAtHit(unitTool, hit); if (cells) setUnitPreview(cells); else clearUnitPreview(); }
        function commitUnitDrag() { if (!isUnitDragging) return; const cells = unitPreviewCells ? unitPreviewCells.map(c => ({ gx: c.gx, gy: c.gy })) : null; cancelUnitDrag(); if (cells && cells.length) addUnitBlock(unitTool, cells); }

        function renderAllUnitBlocks() {
            const maxGX = currentGridWidth * 3, maxGY = currentGridHeight * 3;
            unitBlocks = unitBlocks.filter(b => b.cells.every(c => c.gx >= 0 && c.gx < maxGX && c.gy >= 0 && c.gy < maxGY));
            unitCellToBlock = new Map();
            unitBlocks.forEach(b => {
                b.cells.forEach(c => {
                    unitCellToBlock.set(`${c.gx},${c.gy}`, b.id);
                    const el = getSubcellEl(c.gx, c.gy); if (el) { el.classList.add('unit-block'); el.dataset.unitId = String(b.id); }
                });
            });
            updateUnitHighlights(getCurrentOrigin());
        }

        /* --- ÏãúÏïº Î∞©Ìï¥(Cover) Î°úÏßÅÏù¥ Ï†ÅÏö©Îêú ÌïòÏù¥ÎùºÏù¥Ìä∏ --- */
        function updateUnitHighlights(origin) {
            document.querySelectorAll('.subcell.unit-highlight, .subcell.unit-obscured').forEach(el => {
                el.classList.remove('unit-highlight', 'unit-obscured');
            });
            if (!origin || !isRangeMode || !unitBlocks.length) return;

            // 1. ÎÜíÏùÄ Ïû•Ïï†Î¨º(Í≤ÄÏùÄÎ≤Ω, ÌöåÏÉâÎ≤Ω, ÎåÄÌòïÍ∏∞Ï≤¥) ÏàòÏßë
            const highObstacles = [];
            for (let y = 0; y < currentGridHeight; y++) {
                for (let x = 0; x < currentGridWidth; x++) {
                    const idx = y * currentGridWidth + x; const tile = tiles[idx]; if (!tile) continue;
                    for (let i = 0; i < 9; i++) {
                        const sub = tile.children[i + 1];
                        if (sub.classList.contains('obs-full') || sub.classList.contains('obs-partial')) {
                            highObstacles.push({ x: x * 3 + (i % 3), y: y * 3 + Math.floor(i / 3), isUnit: false });
                        }
                    }
                }
            }
            unitBlocks.forEach(b => {
                if (b.type === 'LARGE') {
                    b.cells.forEach(c => highObstacles.push({ x: c.gx, y: c.gy, isUnit: true, id: b.id }));
                }
            });

            // 2. Í≥µÍ≤©Ïûê Ï§ëÏã¨ (ÌÉÄÏùº Ï§ëÏã¨)
            const attackerCenter = { x: origin.x * 3 + 1.5, y: origin.y * 3 + 1.5 };

            // 3. Í∞Å Í∏∞Ï≤¥ ÏÖÄ ÌåêÏ†ï
            unitBlocks.forEach(b => {
                b.cells.forEach(c => {
                    const el = getSubcellEl(c.gx, c.gy); if (!el) return;
                    if (el.classList.contains('in-range') && el.classList.contains('sub-visible')) {
                        const targetCenter = { x: c.gx + 0.5, y: c.gy + 0.5 };
                        // Ïû•Ïï†Î¨ºÏóê Í∞ÄÎ†§ÏßÄÎäîÏßÄ Ï≤¥ÌÅ¨
                        if (checkObscured(attackerCenter, targetCenter, highObstacles, b.id)) {
                            el.classList.add('unit-obscured');
                        } else {
                            el.classList.add('unit-highlight');
                        }
                    }
                });
            });
        }

        function checkObscured(p1, p2, obstacles, targetUnitId) {
            const dx = p2.x - p1.x, dy = p2.y - p1.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 1.5) return false; // Í∑ºÏ†ë(Ïù∏Ï†ëÌÉÄÏùº ÏàòÏ§Ä)ÏùÄ Î∞©Ìï¥ Î¨¥Ïãú

            for (const obs of obstacles) {
                if (obs.isUnit && obs.id === targetUnitId) continue; // ÏûêÍ∏∞ ÏûêÏã†ÏùÄ ÏóÑÌèêÎ¨º ÏïÑÎãò
                // ÏïΩÍ∞ÑÏùò Ïó¨Ïú†Î•º Îë¨ÏÑú(inset) Ïä§ÏπòÎäîÍ±¥ ÌóàÏö©
                const margin = 0.05;
                if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, obs.x + margin, obs.y + margin, 1 - margin*2, 1 - margin*2)) {
                    return true;
                }
            }
            return false;
        }

        function getCurrentOrigin() { return (simSegments.length > 0) ? simSegments[simSegments.length - 1].end : startPoint; }

        function toggleSimulator() {
            setUnitPanelVisible(false); if(isEditorMode) toggleEditor(); if(isRangeMode) toggleRangeMode(); 
            isSimMode = !isSimMode;
            const btn = document.getElementById('btn-sim');
            if(isSimMode) {
                btn.classList.add('active'); simControls.classList.add('visible'); infoPanel.classList.add('sim-mode');
                resetSimState(); 
                rangeText.textContent = "ÏãúÎÆ¨Î†àÏù¥ÌÑ∞ ÎåÄÍ∏∞"; detailText.textContent = "ÏãúÏûë ÏßÄÏ†êÏùÑ ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî";
                statusText.textContent = `Ìã± 1 Ïù¥ÎèôÏùÑ ÏãúÏûëÌïòÏÑ∏Ïöî (Ï¥ù ${maxTicks}Ìã±)`; tickDisplay.textContent = `Ìã± Í∞ØÏàò : ${maxTicks}`; 
            } else {
                btn.classList.remove('active'); simControls.classList.remove('visible'); infoPanel.classList.remove('sim-mode');
                simDir = null; hideSimDirOverlay(); resetMeasureState(); 
            }
            updateLOS(); applyResponsiveLayout(); updateUnitButtonAvailability();
        }

        function resetSimState() {
            startPoint = null; simSegments = []; lockedAxis = null; simDir = null;
            hideSimDirOverlay(); clearVisuals();
            rangeText.textContent = "ÏãúÎÆ¨Î†àÏù¥ÌÑ∞ ÎåÄÍ∏∞"; statusText.textContent = `Ìã± 1 Ïù¥ÎèôÏùÑ ÏãúÏûëÌïòÏÑ∏Ïöî (Ï¥ù ${maxTicks}Ìã±)`;
            updateLOS();
        }

        function changeVal(delta) {
            if (isSimMode) {
                maxTicks += delta; if(maxTicks < 1) maxTicks = 1;
                tickDisplay.textContent = `Ìã± Í∞ØÏàò : ${maxTicks}`; resetSimState();
                rangeText.textContent = "Î¶¨ÏÖãÎê®"; statusText.textContent = `Ìã± Í∞ØÏàò Î≥ÄÍ≤ΩÎê®. Îã§Ïãú ÏãúÏûëÌïòÏÑ∏Ïöî.`;
            } else if (isRangeMode) {
                rangeValue += delta; if(rangeValue < 1) rangeValue = 1;
                tickDisplay.textContent = `ÏÇ¨Í±∞Î¶¨ : ${rangeValue}`; detailText.textContent = `ÌòÑÏû¨ ÏÑ§Ï†ïÎêú ÏÇ¨Í±∞Î¶¨: ${rangeValue}`;
                updateLOS(); 
            }
        }

        function handleSimClick(x, y) {
            if (!startPoint) {
                startPoint = { x, y }; lockedAxis = null; 
                const idx = y * currentGridWidth + x; if(tiles[idx]) tiles[idx].classList.add('start');
                statusText.textContent = `Ìã± 1 Î™©ÌëúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî`; simDir = null; hideSimDirOverlay();
                updateLOS(); return;
            }
            if (simSegments.length < maxTicks) {
                let lastPoint = (simSegments.length === 0) ? startPoint : simSegments[simSegments.length-1].end;
                const dist = Math.abs(x - lastPoint.x) + Math.abs(y - lastPoint.y);
                let currentAxis = lockedAxis;
                if (!currentAxis) currentAxis = (Math.abs(x - lastPoint.x) > Math.abs(y - lastPoint.y)) ? 'x' : 'y';
                simSegments.push({ start: lastPoint, end: {x, y}, dist: dist, axis: currentAxis });
                lockedAxis = null; 

                if (simSegments.length === maxTicks) statusText.textContent = "Î™®Îì† Ìã± Ïù¥Îèô ÏôÑÎ£å! (ÌÅ¥Î¶≠ÌïòÏó¨ Î¶¨ÏÖã)";
                else statusText.textContent = `Ìã± ${simSegments.length + 1} Î™©ÌëúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî`;
                
                handleSimHover(x, y);
                if (simSegments.length === maxTicks) { const o = getCurrentOrigin(); if (o) showSimDirOverlayAtTile(o.x, o.y); }
                else { simDir = null; hideSimDirOverlay(); }
                updateLOS(); return;
            } 
            resetSimState();
        }

        function handleSimHover(tx, ty) {
            if (!startPoint) return;
            clearVisuals();
            const startIdx = startPoint.y * currentGridWidth + startPoint.x;
            if(tiles[startIdx]) tiles[startIdx].classList.add('start');
            let totalDist = 0; let infoString = ""; const colorMap = ["ÌååÎûë", "ÎÖ∏Îûë", "Îπ®Í∞ï"];

            simSegments.forEach((seg, idx) => {
                drawPathWithAxis(seg.start, seg.end, idx, seg.axis || 'x'); 
                totalDist += seg.dist; const colorName = colorMap[idx % 3]; 
                infoString += `<span style="font-size:0.6em; color:#ccc">T${idx+1}(${colorName}):</span> ${seg.dist}  `;
            });

            if (simSegments.length < maxTicks) {
                let currentStart = (simSegments.length === 0) ? startPoint : simSegments[simSegments.length-1].end;
                const targetIdx = ty * currentGridWidth + tx; if(tiles[targetIdx]) tiles[targetIdx].classList.add('target');
                const currentIdx = simSegments.length;
                if (lockedAxis === null && (tx !== currentStart.x || ty !== currentStart.y)) {
                    if (Math.abs(tx - currentStart.x) > Math.abs(ty - currentStart.y)) lockedAxis = 'x'; else lockedAxis = 'y';
                }
                if (tx === currentStart.x && ty === currentStart.y) lockedAxis = null;
                let cx, cy;
                if (lockedAxis === 'y') { cx = currentStart.x; cy = ty; } else { cx = tx; cy = currentStart.y; }
                drawPathWithAxis(currentStart, {x: tx, y: ty}, currentIdx, lockedAxis);
                const currDist = Math.abs(tx - currentStart.x) + Math.abs(ty - currentStart.y);
                const colorName = colorMap[currentIdx % 3]; 
                infoString += `<span style="font-size:0.6em; color:#fff">T${currentIdx+1}(${colorName}):</span> <b>${currDist}</b>`;
                totalDist += currDist;
            }
            rangeText.innerHTML = infoString; detailText.textContent = `Ï¥ù Ïù¥Îèô Í±∞Î¶¨: ${totalDist}`;
        }

        function clearVisuals() { tiles.forEach(t => { t.classList.remove('target', 'start', 'path'); for(let i=0; i<3; i++) t.classList.remove(`path-tick-${i}`); }); }

        function getLPathCells(p1, p2, axis) {
            let cells = [];
            let cx, cy; if (axis === 'y') { cx = p1.x; cy = p2.y; } else { cx = p2.x; cy = p1.y; }
            let xDir = cx > p1.x ? 1 : -1; let yDir = cy > p1.y ? 1 : -1;
            for (let i = 1; i <= Math.abs(cx - p1.x); i++) cells.push({x: p1.x + i * xDir, y: p1.y});
            for (let i = 1; i <= Math.abs(cy - p1.y); i++) cells.push({x: cx, y: p1.y + i * yDir});
            xDir = p2.x > cx ? 1 : -1; yDir = p2.y > cy ? 1 : -1;
            for (let i = 1; i <= Math.abs(p2.x - cx); i++) cells.push({x: cx + i * xDir, y: cy});
            for (let i = 1; i <= Math.abs(p2.y - cy); i++) cells.push({x: cx, y: cy + i * yDir});
            return cells;
        }

        function drawPathWithAxis(p1, p2, tickIdx, axis) {
            const cells = getLPathCells(p1, p2, axis || 'x'); const pathClass = `path-tick-${tickIdx % 3}`;
            cells.forEach(c => { const idx = c.y * currentGridWidth + c.x; if (tiles[idx]) tiles[idx].classList.add(pathClass); });
        }

        function createGrid() {
            container.style.gridTemplateColumns = `repeat(${currentGridWidth}, var(--tile-size))`;
            container.style.gridTemplateRows = `repeat(${currentGridHeight}, var(--tile-size))`;
            container.innerHTML = ''; tiles = [];
            for (let y = 0; y < currentGridHeight; y++) {
                for (let x = 0; x < currentGridWidth; x++) {
                    const tile = document.createElement('div'); tile.classList.add('tile');
                    tile.dataset.x = x; tile.dataset.y = y;
                    const label = document.createElement('span'); label.classList.add('coord-label'); label.textContent = `${x},${y}`;
                    tile.appendChild(label);
                    for (let i = 0; i < 9; i++) {
                        const sub = document.createElement('div'); sub.classList.add('subcell'); sub.dataset.idx = i; 
                        tile.appendChild(sub);
                    }
                    container.appendChild(tile); tiles.push(tile);
                }
            }
            updateAreaOverlay(); renderAllUnitBlocks(); updateLOS(); applyResponsiveLayout();
        }

        function applyGridSize() {
            const newW = parseInt(widthInput.value), newH = parseInt(heightInput.value);
            if (isNaN(newW) || newW < 5 || newW > 40 || isNaN(newH) || newH < 5 || newH > 40) { alert("5 ~ 40 ÏÇ¨Ïù¥Ïùò Í∞íÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî."); return; }
            const oldW = currentGridWidth, oldH = currentGridHeight;
            const currentData = getMapDataFromScreen();
            const offX = Math.floor((newW - oldW) / 2), offY = Math.floor((newH - oldH) / 2);
            function shiftTilePoint(p) {
                if (!p) return null; const nx = p.x + offX, ny = p.y + offY;
                if (nx < 0 || ny < 0 || nx >= newW || ny >= newH) return null; return { x: nx, y: ny };
            }
            startPoint = shiftTilePoint(startPoint);
            if (Array.isArray(simSegments) && simSegments.length > 0) {
                const shiftedSegs = []; let ok = true;
                for (const seg of simSegments) {
                    const s = shiftTilePoint(seg.start), e = shiftTilePoint(seg.end);
                    if (!s || !e) { ok = false; break; } shiftedSegs.push({ ...seg, start: s, end: e });
                }
                if (ok) simSegments = shiftedSegs; else { simSegments = []; isLocked = false; lockedAxis = null; }
            }
            rangeDir = null; simDir = null; hideRangeDirOverlay && hideRangeDirOverlay(); hideSimDirOverlay && hideSimDirOverlay();

            if (Array.isArray(unitBlocks) && unitBlocks.length > 0) {
                const newBlocks = [], newMap = new Map(); const maxGX = newW * 3, maxGY = newH * 3;
                for (const b of unitBlocks) {
                    const newCells = []; let ok = true;
                    for (const c of b.cells) {
                        const ngx = c.gx + offX * 3, ngy = c.gy + offY * 3;
                        if (ngx < 0 || ngy < 0 || ngx >= maxGX || ngy >= maxGY) { ok = false; break; }
                        newCells.push({ gx: ngx, gy: ngy });
                    }
                    if (!ok) continue;
                    const nb = { ...b, cells: newCells }; newBlocks.push(nb);
                    newCells.forEach(c => newMap.set(`${c.gx},${c.gy}`, nb.id));
                }
                unitBlocks = newBlocks; unitCellToBlock = newMap;
            } else { unitBlocks = []; unitCellToBlock = new Map(); }

            currentGridWidth = newW; currentGridHeight = newH; createGrid();
            currentData.forEach(data => {
                const nx = data.x + offX, ny = data.y + offY;
                if (nx >= 0 && ny >= 0 && nx < currentGridWidth && ny < currentGridHeight) {
                    const index = ny * currentGridWidth + nx; const shifted = { ...data, x: nx, y: ny };
                    renderTileObject(tiles[index], shifted);
                }
            });
            updateLOS();
        }

        function handleEditorClick(e, x, y) {
            const index = y * currentGridWidth + x; const tile = tiles[index]; const target = e.target;
            if (currentTool === 'CUSTOM_DRAW') {
                if (target.classList.contains('subcell')) {
                    target.classList.add('obs-weak'); target.classList.remove('obs-full', 'obs-partial');
                }
                return;
            }
            tile.querySelectorAll('.subcell').forEach(c => c.className = 'subcell');
            tile.querySelector('.coord-label').style.color = '#ccc';
            if (currentTool === 'ERASER') return;
            renderTileObject(tile, { t: currentTool });
        }

        function handleMapSelect() {
            const selected = mapSelector.value; if (!selected) return;
            if (selected === "__NEW__") {
                if(confirm("ÌôîÎ©¥ÏùÑ Ï¥àÍ∏∞ÌôîÌïòÍ≥† ÏÉà ÎßµÏùÑ ÎßåÎìúÏãúÍ≤†ÏäµÎãàÍπå?")) {
                    clearMapData(true); currentEditingMapName = null;
                    currentMapNameDisplay.textContent = "ÌòÑÏû¨ Îßµ: (ÏÉà Îßµ - Ï†ÄÏû•ÎêòÏßÄ ÏïäÏùå)";
                    mapSelector.value = ""; toggleEditor(); 
                } else { mapSelector.value = ""; }
            } else { if (savedMaps[selected]) loadCustomMap(selected); }
        }

        function loadCustomMap(name) {
            if (isEditorMode || isSimMode || isRangeMode) resetAllModes();
            currentEditingMapName = name; currentMapNameDisplay.textContent = `ÌòÑÏû¨ Îßµ: ${name}`;
            const mapDataObj = savedMaps[name]; let tilesData = [];
            if (mapDataObj.width && mapDataObj.height && Array.isArray(mapDataObj.tiles)) {
                currentGridWidth = mapDataObj.width; currentGridHeight = mapDataObj.height; tilesData = mapDataObj.tiles;
            } else if (Array.isArray(mapDataObj)) {
                tilesData = mapDataObj;
                let maxX = 0, maxY = 0; tilesData.forEach(d => { if(d.x > maxX) maxX = d.x; if(d.y > maxY) maxY = d.y; });
                currentGridWidth = Math.max(12, maxX + 1); currentGridHeight = Math.max(12, maxY + 1);
            }
            widthInput.value = currentGridWidth; heightInput.value = currentGridHeight;
            createGrid();
            tilesData.forEach(data => {
                if(data.x < currentGridWidth && data.y < currentGridHeight) {
                    const index = data.y * currentGridWidth + data.x; if(tiles[index]) renderTileObject(tiles[index], data);
                }
            });
            document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
        }

        function saveMapAs() {
            const tilesData = getMapDataFromScreen();
            if (tilesData.length === 0 && !confirm("Îπà ÎßµÏûÖÎãàÎã§. Ï†ÄÏû•ÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) return;
            let newName = prompt("Ï†ÄÏû•Ìï† ÎßµÏùò Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî:", currentEditingMapName || "");
            if (newName === null) return; newName = newName.trim();
            if (newName === "") { alert("Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•Ìï¥Ïïº Ìï©ÎãàÎã§."); return; }
            if (savedMaps[newName] && newName !== currentEditingMapName) { if(!confirm(`'${newName}' ÎßµÏù¥ Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï©ÎãàÎã§. ÎçÆÏñ¥ÏîåÏö∞ÏãúÍ≤†ÏäµÎãàÍπå?`)) return; }
            const mapObj = { width: currentGridWidth, height: currentGridHeight, tiles: tilesData };
            savedMaps[newName] = mapObj; localStorage.setItem('obsidian_saved_maps_v2', JSON.stringify(savedMaps));
            currentEditingMapName = newName; refreshMapDropdown(); mapSelector.value = newName; 
            currentMapNameDisplay.textContent = `ÌòÑÏû¨ Îßµ: ${newName}`; alert("Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!");
        }

        function deleteCurrentMap() {
            if (!currentEditingMapName || !savedMaps[currentEditingMapName]) { alert("ÏÇ≠Ï†úÌï† ÎßµÏù¥ ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏïòÍ±∞ÎÇò Ï†ÄÏû•ÎêòÏßÄ ÏïäÏùÄ ÎßµÏûÖÎãàÎã§."); return; }
            if(confirm(`Ï†ïÎßêÎ°ú '${currentEditingMapName}' ÎßµÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
                delete savedMaps[currentEditingMapName]; localStorage.setItem('obsidian_saved_maps_v2', JSON.stringify(savedMaps));
                refreshMapDropdown(); clearMapData(true); currentEditingMapName = null;
                currentMapNameDisplay.textContent = "ÌòÑÏû¨ Îßµ: (ÏÇ≠Ï†úÎê®)"; alert("ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.");
            }
        }

        function getMapDataFromScreen() {
            const exportArray = [];
            for (let y = 0; y < currentGridHeight; y++) {
                for (let x = 0; x < currentGridWidth; x++) {
                    const idx = y * currentGridWidth + x; const tile = tiles[idx];
                    const subcells = tile.querySelectorAll('.subcell');
                    const fullCount = Array.from(subcells).filter(c => c.classList.contains('obs-full')).length;
                    if (fullCount === 9) { exportArray.push({x:x, y:y, t:'FULL'}); continue; }
                    const weakIndices = [];
                    subcells.forEach((c, i) => { if (c.classList.contains('obs-weak')) weakIndices.push(i); });
                    if (weakIndices.length > 0) exportArray.push({x:x, y:y, t:'CONTAINER', idx:weakIndices});
                    
                    if (fullCount > 0 && fullCount < 9) {
                         if (subcells[0].classList.contains('obs-full') && subcells[1].classList.contains('obs-full')) exportArray.push({x:x, y:y, t:'BLK_T'});
                         else if (subcells[6].classList.contains('obs-full') && subcells[7].classList.contains('obs-full')) exportArray.push({x:x, y:y, t:'BLK_B'});
                         else if (subcells[0].classList.contains('obs-full') && subcells[3].classList.contains('obs-full')) exportArray.push({x:x, y:y, t:'BLK_L'});
                         else if (subcells[2].classList.contains('obs-full') && subcells[5].classList.contains('obs-full')) exportArray.push({x:x, y:y, t:'BLK_R'});
                         else if (subcells[3].classList.contains('obs-full') && subcells[4].classList.contains('obs-full')) exportArray.push({x:x, y:y, t:'BLK_M_H'});
                         else if (subcells[1].classList.contains('obs-full') && subcells[4].classList.contains('obs-full')) exportArray.push({x:x, y:y, t:'BLK_M_V'});
                    }
                    const partialCount = Array.from(subcells).filter(c => c.classList.contains('obs-partial')).length;
                    if (partialCount > 0) {
                         if (subcells[0].classList.contains('obs-partial') && subcells[1].classList.contains('obs-partial')) exportArray.push({x:x, y:y, t:'GRY_T'});
                         else if (subcells[6].classList.contains('obs-partial') && subcells[7].classList.contains('obs-partial')) exportArray.push({x:x, y:y, t:'GRY_B'});
                         else if (subcells[0].classList.contains('obs-partial') && subcells[3].classList.contains('obs-partial')) exportArray.push({x:x, y:y, t:'GRY_L'});
                         else if (subcells[2].classList.contains('obs-partial') && subcells[5].classList.contains('obs-partial')) exportArray.push({x:x, y:y, t:'GRY_R'});
                         else if (subcells[3].classList.contains('obs-partial') && subcells[4].classList.contains('obs-partial')) exportArray.push({x:x, y:y, t:'GRY_M_H'});
                         else if (subcells[1].classList.contains('obs-partial') && subcells[4].classList.contains('obs-partial')) exportArray.push({x:x, y:y, t:'GRY_M_V'});
                    }
                }
            }
            return exportArray;
        }

        function exportMapCode() {
            const data = getMapDataFromScreen();
            const strLines = data.map(item => {
                if(item.idx) return `{x:${item.x}, y:${item.y}, t:'${item.t}', idx:[${item.idx.join(',')}]}`;
                return `{x:${item.x}, y:${item.y}, t:'${item.t}'}`;
            });
            const codeString = `{ width: ${currentGridWidth}, height: ${currentGridHeight}, tiles: [ ${strLines.join(',\n        ')} ] }`;
            navigator.clipboard.writeText(codeString).then(() => { alert("ÏΩîÎìúÍ∞Ä Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§!"); }).catch(() => { prompt("Ctrl+C:", codeString); });
            importInput.value = codeString; 
        }

        function importMapCode() {
            const code = importInput.value;
            if (!code.trim()) { alert("ÏΩîÎìúÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî."); return; }
            try {
                const parsed = new Function("return " + code)();
                let tilesData = [];
                if (parsed.width && parsed.height && Array.isArray(parsed.tiles)) {
                    currentGridWidth = parsed.width; currentGridHeight = parsed.height; tilesData = parsed.tiles;
                } else if (Array.isArray(parsed)) {
                    tilesData = parsed;
                    let maxX = 0, maxY = 0; tilesData.forEach(d => { if(d.x > maxX) maxX = d.x; if(d.y > maxY) maxY = d.y; });
                    currentGridWidth = Math.max(12, maxX + 1); currentGridHeight = Math.max(12, maxY + 1);
                } else { throw new Error("Ïò¨Î∞îÎ•∏ ÌòïÏãùÏù¥ ÏïÑÎãôÎãàÎã§."); }
                widthInput.value = currentGridWidth; heightInput.value = currentGridHeight;
                clearUnitBlocks(); setUnitPanelVisible(false); createGrid();
                tilesData.forEach(data => { const index = data.y * currentGridWidth + data.x; if (tiles[index]) renderTileObject(tiles[index], data); });
                alert("Îßµ ÏΩîÎìúÎ•º Ï†ÅÏö©ÌñàÏäµÎãàÎã§.");
            } catch (e) { alert("ÏΩîÎìú Ïò§Î•ò: " + e.message); }
        }

        function renderTileObject(tile, data) {
            const subcells = tile.querySelectorAll('.subcell'); const type = data.t;
            if (type === 'FULL') { subcells.forEach(c => c.classList.add('obs-full')); tile.querySelector('.coord-label').style.color = '#555'; }
            else if (type === 'CONTAINER') { if (data.idx) data.idx.forEach(i => subcells[i].classList.add('obs-weak')); }
            else if (type === 'BLK_T') [0,1,2].forEach(i=>subcells[i].classList.add('obs-full'));
            else if (type === 'BLK_B') [6,7,8].forEach(i=>subcells[i].classList.add('obs-full'));
            else if (type === 'BLK_L') [0,3,6].forEach(i=>subcells[i].classList.add('obs-full'));
            else if (type === 'BLK_R') [2,5,8].forEach(i=>subcells[i].classList.add('obs-full'));
            else if (type === 'BLK_M_H') [3,4,5].forEach(i=>subcells[i].classList.add('obs-full'));
            else if (type === 'BLK_M_V') [1,4,7].forEach(i=>subcells[i].classList.add('obs-full'));
            else if (type === 'GRY_T') [0,1,2].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if (type === 'GRY_B') [6,7,8].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if (type === 'GRY_L') [0,3,6].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if (type === 'GRY_R') [2,5,8].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if (type === 'GRY_M_H') [3,4,5].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if (type === 'GRY_M_V') [1,4,7].forEach(i=>subcells[i].classList.add('obs-partial'));
        }

        function toggleEditor() {
            setUnitPanelVisible(false); if(isSimMode) toggleSimulator(); 
            isEditorMode = !isEditorMode;
            const btn = document.getElementById('btn-editor');
            if (isEditorMode) {
                btn.classList.add('active'); editorPanel.classList.add('visible'); infoPanel.classList.add('edit-mode');
                resetMeasureState(); rangeText.textContent = "Îßµ ÏóêÎîîÌÑ∞"; detailText.textContent = "ÌÉÄÏùº Î∞∞Ïπò / ÏΩîÎìú Î≥µÏÇ¨"; statusText.textContent = "ÌÉÄÏùº ÌÅ¥Î¶≠ (ÎìúÎûòÍ∑∏ Í∞ÄÎä•)";
            } else {
                btn.classList.remove('active'); editorPanel.classList.remove('visible'); infoPanel.classList.remove('edit-mode');
                rangeText.textContent = "ÏúÑÏπò ÏÑ†ÌÉù"; detailText.textContent = "ÏùºÎ∞ò Î™®Îìú"; statusText.textContent = "ÏãúÏûë ÏßÄÏ†ê ÌÅ¥Î¶≠";
            }
            applyResponsiveLayout(); updateUnitButtonAvailability();
        }

        function selectTool(toolName) {
            currentTool = toolName;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('selected'));
            document.querySelectorAll('.preset-group button').forEach(b => b.style.backgroundColor = '');
            if(event.currentTarget.classList.contains('tool-btn')) event.currentTarget.classList.add('selected');
            else event.currentTarget.style.backgroundColor = '#009688';
        }

        function clearMapData(force = false) {
            if(!force && !confirm("ÌòÑÏû¨ ÎßµÏùÑ Î™®Îëê ÏßÄÏö∞ÏãúÍ≤†ÏäµÎãàÍπå?")) return;
            tiles.forEach(tile => { tile.querySelectorAll('.subcell').forEach(c => c.className = 'subcell'); tile.querySelector('.coord-label').style.color = '#ccc'; });
        }

        function resetAllModes() {
            isEditorMode = false; editorPanel.classList.remove('visible'); document.getElementById('btn-editor').classList.remove('active'); infoPanel.classList.remove('edit-mode');
            isSimMode = false; simControls.classList.remove('visible'); document.getElementById('btn-sim').classList.remove('active'); infoPanel.classList.remove('sim-mode'); simSegments = [];
            isLOSActive = false; document.getElementById('btn-los').classList.remove('active');
            isRangeMode = false; document.getElementById('btn-range').classList.remove('active'); infoPanel.classList.remove('range-mode');
            resetSimState(); tiles.forEach(t => t.className = 'tile');
            const activeMapBtn = document.querySelector('.controls button.active');
            if(activeMapBtn && !['btn-sim','btn-editor','btn-area1','btn-area2','btn-los','btn-range'].some(id => activeMapBtn.id.includes(id))) {
                loadMap(activeMapBtn.id.replace('btn-', '')); 
            }
            updateAreaOverlay(); setUnitPanelVisible(false); updateUnitButtonAvailability();
        }

        function loadMap(mapName) {
            clearUnitBlocks(); setUnitPanelVisible(false);
            if (isEditorMode || isSimMode || isRangeMode) resetAllModes();
            if (mapName !== 'custom' && (currentGridWidth !== 12 || currentGridHeight !== 12)) {
                currentGridWidth = 12; currentGridHeight = 12; widthInput.value = 12; heightInput.value = 12; createGrid();
            }
            let mapData = defaultMaps[mapName];
            tiles.forEach(tile => { tile.querySelectorAll('.subcell').forEach(c => c.className = 'subcell'); tile.querySelector('.coord-label').style.color = '#ccc'; });
            if (mapData) mapData.forEach(data => { const index = data.y * currentGridWidth + data.x; if (tiles[index]) renderTileObject(tiles[index], data); });
            document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('btn-' + mapName); if(btn) btn.classList.add('active');
            mapSelector.value = ""; currentEditingMapName = null; currentMapNameDisplay.textContent = `ÌòÑÏû¨ Îßµ: ${mapName} (Í∏∞Î≥∏)`;
            updateAreaOverlay(); updateLOS();
        }

        function resetMeasureState() {
            startPoint = null; isLocked = false; rangeDir = null; hideRangeDirOverlay(); lockedAxis = null; infoPanel.classList.remove('locked');
            if(!isSimMode && !isRangeMode) { rangeText.textContent = "ÏúÑÏπò ÏÑ†ÌÉù"; detailText.textContent = "ÏùºÎ∞ò Î™®Îìú"; statusText.textContent = "ÏãúÏûë ÏßÄÏ†êÏùÑ ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî"; }
            tiles.forEach(t => t.classList.remove('start', 'path', 'target', 'locked'));
            updateLOS();
        }
        
        function handleMeasureClick(x, y) {
            if (!startPoint) {
                startPoint = { x, y }; lockedAxis = null; tiles[y * currentGridWidth + x].classList.add('start');
                if (isRangeMode) statusText.textContent = "ÏãúÏûë ÏßÄÏ†ê ÏÑ†ÌÉùÎê®. ÏÇ¨Í±∞Î¶¨Î•º Ï°∞Ï†àÌïòÏÑ∏Ïöî.";
                else statusText.textContent = "Î™©Ìëú ÏßÄÏ†êÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ Í≥†Ï†ïÌïòÏÑ∏Ïöî";
                handleMeasureHover(x, y); updateLOS();
                if (isRangeMode) showRangeDirOverlayAtTile(x, y);
                return;
            }
            if (!isLocked && !isRangeMode) {
                isLocked = true; infoPanel.classList.add('locked'); statusText.textContent = "Í≥†Ï†ïÎê® (Îã§Ïãú ÌÅ¥Î¶≠ÌïòÏó¨ Ï¥àÍ∏∞Ìôî)"; tiles[y * currentGridWidth + x].classList.add('locked');
                return;
            }
            if (isRangeMode) {
                if (startPoint && x === startPoint.x && y === startPoint.y) { if (isRangeDirOverlayVisible) hideRangeDirOverlay(); else showRangeDirOverlayAtTile(x, y); return; }
                resetMeasureState(); startPoint = {x, y}; rangeDir = null; hideRangeDirOverlay();
                tiles[y * currentGridWidth + x].classList.add('start'); updateLOS(); showRangeDirOverlayAtTile(x, y); return;
            }
            if (isLocked) resetMeasureState();
        }

        function handleMeasureHover(tx, ty) {
            if (isRangeMode) return;
            if (isLocked || !startPoint) return;
            tiles.forEach(t => { t.classList.remove('path', 'target'); }); tiles[ty * currentGridWidth + tx].classList.add('target');
            const sx = startPoint.x; const sy = startPoint.y;
            if (lockedAxis === null && (tx !== sx || ty !== sy)) {
                if (Math.abs(tx - sx) > Math.abs(ty - sy)) lockedAxis = 'x'; else lockedAxis = 'y';
            }
            if (tx === sx && ty === sy) lockedAxis = null;
            const cells = getLPathCells(startPoint, {x: tx, y: ty}, lockedAxis || 'x');
            cells.forEach(c => { const idx = c.y * currentGridWidth + c.x; if(tiles[idx]) tiles[idx].classList.add('path'); });
            const distX = Math.abs(tx - sx); const distY = Math.abs(ty - sy);
            rangeText.innerHTML = `ÏÇ¨Í±∞Î¶¨: <span style="color:white">${distX + distY}</span>`; detailText.textContent = `Í∞ÄÎ°ú ${distX} + ÏÑ∏Î°ú ${distY}`;
        }

        createGrid(); initMapStorage(); loadMap('hotspot'); 
    </script>
</body>
</html>