<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes, orientation=landscape, viewport-fit=cover">
    
    <link rel="manifest" href="./manifest.json?v=16">
    <meta name="theme-color" content="#1e1e1e">
    <link rel="icon" href="./icon-192.png">
    <link rel="apple-touch-icon" href="./icon-192.png">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ObsidianMap">

    <script>
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("./service-worker.js").then(reg => {
            reg.addEventListener('updatefound', () => {
                const newWorker = reg.installing;
                newWorker.addEventListener('statechange', () => {
                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                        window.location.reload();
                    }
                });
            });
        });
        navigator.serviceWorker.addEventListener("controllerchange", () => {
          window.location.reload();
        });
      }
    </script>

    <title>Obsidian Map Tool v66 (Integrated Fix)</title>
    <style>
        /* 3. ğŸ—ï¸ ë ˆì´ì•„ì›ƒ êµ¬ì„±: ìƒë‹¨-ì¤‘ì•™-í•˜ë‹¨ 3ë¶„í•  */
        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            background-color: #1e1e1e;
            color: #e0e0e0;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column; /* PC/ëª¨ë°”ì¼ ëª¨ë‘ ìœ„ì•„ë˜ë¡œ ë°°ì¹˜ */
            overflow: hidden; /* í˜ì´ì§€ ì „ì²´ ìŠ¤í¬ë¡¤ ì°¨ë‹¨ */
        }

        /* ìƒë‹¨ í—¤ë” (ê³ ì •) */
        .ui-header {
            flex: 0 0 auto;
            background-color: #252525;
            padding: 8px 0;
            border-bottom: 1px solid #333;
            z-index: 1000;
            width: 100%;
            overflow-x: auto;
            white-space: nowrap;
            display: flex;
            justify-content: center;
            -webkit-overflow-scrolling: touch;
        }
        .controls { display: flex; gap: 6px; padding: 0 15px; align-items: center; }

        /* ì¤‘ì•™ ë§µ ì˜ì—­ (ë‚¨ì€ ê³µê°„ ì°¨ì§€ ë° ë…ë¦½ ìŠ¤í¬ë¡¤) */
        .main-area {
            flex: 1 1 auto;
            width: 100%;
            overflow: auto; /* ë§µì´ í¬ë©´ ì´ ì•ˆì—ì„œë§Œ ìŠ¤í¬ë¡¤ë¨ */
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px;
            box-sizing: border-box;
            touch-action: pan-x pan-y pinch-zoom;
        }

        #grid-container {
            display: grid;
            gap: 1px;
            background-color: #444;
            border: 4px solid #333;
            padding: 2px;
            border-radius: 4px;
            margin: auto;
            /* í•´ìƒë„ ëŒ€ì‘: í™”ë©´ ê°€ë¡œí­ì„ ë„˜ì§€ ì•Šê²Œ í•¨ */
            max-width: 95vw;
        }

        /* íƒ€ì¼ í¬ê¸° 65px ìœ ì§€í•˜ë˜ ëª¨ë°”ì¼ í•´ìƒë„ì— ë”°ë¼ ì¶•ì†Œ */
        .tile {
            width: min(65px, 7.5vw); 
            height: min(65px, 7.5vw);
            background-color: #fff;
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            grid-template-rows: repeat(3, 1fr);
            position: relative;
            cursor: crosshair;
        }

        /* í•˜ë‹¨ ì •ë³´ë°” (ê³ ì •) */
        .bottom-ui {
            flex: 0 0 auto;
            background-color: #1e1e1e;
            border-top: 1px solid #333;
            padding: 12px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 1000;
            padding-bottom: max(12px, env(safe-area-inset-bottom));
        }

        #info-panel {
            text-align: center;
            background: #2d2d2d;
            padding: 15px 25px;
            border-radius: 8px;
            border: 1px solid #444;
            width: 90%;
            max-width: 650px;
            box-shadow: 0 -5px 15px rgba(0,0,0,0.3);
        }

        /* ì •ë³´ í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        #range-text { font-size: 1.3em; font-weight: bold; color: #4fc3f7; margin-bottom: 5px; }
        #detail-text { font-size: 1.1em; color: #aaa; margin-bottom: 3px; }
        #status-text { font-size: 0.9em; color: #888; font-style: italic; }

        /* ë²”ë¡€ ìŠ¤íƒ€ì¼ */
        .legend-box { display: flex; justify-content: center; gap: 12px; margin-top: 8px; font-size: 0.8em; }
        .legend-item { display: flex; align-items: center; gap: 4px; }
        .legend-color { width: 10px; height: 10px; border-radius: 2px; border: 1px solid #fff; }

        /* ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        button { padding: 10px 15px; background: #3a3a3a; color: white; border: 1px solid #555; border-radius: 6px; font-weight: 600; white-space: nowrap; }
        button.active { background-color: #2e7d32; border-color: #1b5e20; }
        #btn-editor { background-color: #ff9800; color: #000; }
        #btn-editor.active { background-color: #e65100; color: #fff; }

        /* íƒ€ì¼ íš¨ê³¼ ìŠ¤íƒ€ì¼ */
        .subcell { border: 0.1px solid rgba(0,0,0,0.05); }
        .subcell.obs-full { background-color: #111; } 
        .subcell.obs-partial { background-color: #777; background-image: repeating-linear-gradient(45deg, #666, #666 2px, #777 2px, #777 4px); }
        .subcell.obs-weak { background-color: #009688; }
        .subcell.sub-visible { background-color: rgba(76, 175, 80, 0.6) !important; }
        .subcell.in-range { background-color: rgba(255, 235, 59, 0.25); }
        .subcell.sub-visible.in-range { background-color: rgba(33, 150, 243, 0.65) !important; border: 1px solid #fff; }
        
        .tile.start::after { content: ''; position: absolute; inset: 0; background-color: rgba(33, 150, 243, 0.6); border: 2px solid #2196f3; z-index: 5; }
        .tile.target::before { content: ''; position: absolute; inset: 0; background-color: rgba(244, 67, 54, 0.5); border: 2px solid #e53935; z-index: 6; }
        .tile.path::before { content: ''; position: absolute; inset: 2px; background-color: rgba(255, 235, 59, 0.3); border: 2px dashed #fdd835; z-index: 4; }
        .coord-label { position: absolute; top: 1px; left: 2px; font-size: 10px; color: #ccc; z-index: 10; pointer-events: none; }

        /* ì—ë””í„° íŒ¨ë„ (ì›ë³¸ ìŠ¤íƒ€ì¼ ìœ ì§€) */
        #editor-panel {
            position: fixed; right: 0; top: 0; height: 100%;
            width: 320px; background: #222; border-left: 1px solid #444;
            padding: 15px; display: none; flex-direction: column; overflow-y: auto; z-index: 2000;
        }
        #editor-panel.visible { display: flex; }

        /* ì„¸ë¡œ ëª¨ë“œ ìµœì í™” */
        @media screen and (orientation: portrait) {
            .ui-header { justify-content: flex-start; }
            #editor-panel { position: fixed; bottom: 0; right: 0; width: 100%; height: 50vh; border-left: none; border-top: 2px solid #444; }
        }
    </style>
</head>
<body>

    <div class="ui-header">
        <div class="controls">
            <button id="btn-hotspot" onclick="loadMap('hotspot')">Hotspot</button>
            <button id="btn-crossroads" onclick="loadMap('crossroads')">Crossroads</button>
            <button id="btn-alley" onclick="loadMap('alley')">Alley</button>
            <select id="map-selector" onchange="handleMapSelect()" style="padding:10px; background:#263238; color:white; border-radius:6px; border:1px solid #37474f;">
                <option value="" disabled selected>ì €ì¥ëœ ë§µ</option>
                <option value="__NEW__">+ ìƒˆ ë§µ</option>
            </select>
            <button id="btn-editor" onclick="toggleEditor()">ğŸ›  ì—ë””í„°</button>
            <button id="btn-sim" onclick="toggleSimulator()">ğŸ² ì‹œë®¬ë ˆì´í„°</button>
            <button id="btn-los" onclick="toggleLOS()">ğŸ‘ LOS</button>
            <button id="btn-range" onclick="toggleRangeMode()">ğŸ“ ì‚¬ê±°ë¦¬</button>
        </div>
    </div>

    <div class="main-area">
        <div id="grid-container"></div>
    </div>

    <div class="bottom-ui">
        <div id="sim-controls" style="display:none; align-items:center; gap:12px; margin-bottom:12px; background:#333; padding:10px 20px; border-radius:30px;">
            <button class="tick-btn" onclick="changeVal(-1)" style="width:35px; height:35px; border-radius:50%; font-size:1.4em; padding:0;">-</button>
            <span id="tick-display" style="font-weight:bold; color:#fff;">í‹± ê°¯ìˆ˜ : 3</span>
            <button class="tick-btn" onclick="changeVal(1)" style="width:35px; height:35px; border-radius:50%; font-size:1.4em; padding:0;">+</button>
        </div>

        <div id="info-panel">
            <div id="range-text">ìœ„ì¹˜ ì„ íƒ</div>
            <div id="detail-text">ì¼ë°˜ ëª¨ë“œ</div>
            <div id="status-text">ì‹œì‘ ì§€ì ì„ í´ë¦­í•˜ì„¸ìš”</div>
            
            <div class="legend-box">
                <div class="legend-item"><div class="legend-color" style="background:rgba(76,175,80,0.8);"></div>ì‹œì•¼</div>
                <div class="legend-item"><div class="legend-color" style="background:rgba(255,235,59,0.5);"></div>ì‚¬ê±°ë¦¬</div>
                <div class="legend-item"><div class="legend-color" style="background:rgba(33,150,243,0.8);"></div>ê³µê²©ê°€ëŠ¥</div>
            </div>
        </div>
    </div>

    <div id="editor-panel">
        <button onclick="toggleEditor()" style="background:#444; margin-bottom:15px; border:none;">âŒ ë‹«ê¸°</button>
        <button onclick="clearMapData()" style="background:#d32f2f; margin-bottom:15px; border:none; padding:12px; border-radius:4px;">âš¡ ë§µ ì´ˆê¸°í™”</button>
        <button class="tool-btn selected" onclick="selectTool('ERASER')" style="padding:15px; margin-bottom:8px; text-align:left;">â¬œ ì§€ìš°ê°œ</button>
        <button class="tool-btn" onclick="selectTool('FULL')" style="padding:15px; margin-bottom:8px; text-align:left;">â¬› 3x3 ìƒì</button>
        <button onclick="saveMapAs()" style="background:#2e7d32; margin-top:30px; border:none; padding:15px; border-radius:4px;">ğŸ’¾ ì €ì¥í•˜ê¸°</button>
    </div>

    <script>
        /* 4. ğŸ® ìë°”ìŠ¤í¬ë¦½íŠ¸ ì—”ì§„ (v61 ì›ë³¸ ë¡œì§ ì „ì²´ ë³µêµ¬) */
        const container = document.getElementById('grid-container');
        const infoPanel = document.getElementById('info-panel');
        const rangeText = document.getElementById('range-text');
        const detailText = document.getElementById('detail-text');
        const statusText = document.getElementById('status-text');
        const editorPanel = document.getElementById('editor-panel');
        const simControls = document.getElementById('sim-controls');
        const tickDisplay = document.getElementById('tick-display');
        const mapSelector = document.getElementById('map-selector');
        
        let tiles = []; 
        let isEditorMode = false; let isSimMode = false; let isRangeMode = false; 
        let isLOSActive = false; let isMouseDown = false; let currentTool = 'ERASER'; 
        let currentGridWidth = 12; let currentGridHeight = 12;
        let startPoint = null; let isLocked = false; let maxTicks = 3; let rangeValue = 4; 
        let simSegments = []; let lockedAxis = null; let savedMaps = {};

        window.addEventListener('mouseup', () => { isMouseDown = false; });

        const defaultMaps = {
            hotspot: [{x:9, y:1, t:'CONTAINER', idx:[8]}, {x:7, y:2, t:'FULL'}, {x:8, y:2, t:'CONTAINER', idx:[2]}, {x:10, y:2, t:'BLK_B'}, {x:2, y:3, t:'GRY_R'}, {x:7, y:3, t:'FULL'}, {x:2, y:4, t:'BLK_T'}, {x:5, y:4, t:'BLK_T'}, {x:6, y:4, t:'CONTAINER', idx:[2,5]}, {x:8, y:4, t:'FULL'}, {x:9, y:4, t:'CONTAINER', idx:[7,8]}, {x:10, y:4, t:'CONTAINER', idx:[3,6]}, {x:4, y:5, t:'CONTAINER', idx:[2]}, {x:8, y:5, t:'GRY_R'}, {x:3, y:6, t:'GRY_L'}, {x:7, y:6, t:'CONTAINER', idx:[6]}, {x:1, y:7, t:'CONTAINER', idx:[2,5]}, {x:2, y:7, t:'CONTAINER', idx:[0,1]}, {x:3, y:7, t:'FULL'}, {x:5, y:7, t:'CONTAINER', idx:[3,6]}, {x:6, y:7, t:'BLK_B'}, {x:9, y:7, t:'BLK_B'}, {x:4, y:8, t:'FULL'}, {x:9, y:8, t:'GRY_L'}, {x:1, y:9, t:'BLK_T'}, {x:3, y:9, t:'CONTAINER', idx:[0]}, {x:4, y:9, t:'FULL'}, {x:2, y:10, t:'CONTAINER', idx:[0]}],
            crossroads: [{x:8, y:2, t:'BLK_L'}, {x:4, y:3, t:'GRY_R'}, {x:8, y:3, t:'FULL'}, {x:9, y:3, t:'GRY_T'}, {x:0, y:4, t:'CONTAINER', idx:[7,8]}, {x:1, y:4, t:'BLK_B'}, {x:2, y:4, t:'BLK_B'}, {x:3, y:4, t:'FULL'}, {x:4, y:4, t:'FULL'}, {x:5, y:4, t:'CONTAINER', idx:[7,8]}, {x:6, y:4, t:'CONTAINER', idx:[5,8]}, {x:8, y:4, t:'GRY_R'}, {x:4, y:5, t:'CONTAINER', idx:[8]}, {x:7, y:6, t:'CONTAINER', idx:[0]}, {x:3, y:7, t:'GRY_L'}, {x:5, y:7, t:'CONTAINER', idx:[0,3]}, {x:6, y:7, t:'CONTAINER', idx:[0,1]}, {x:7, y:7, t:'FULL'}, {x:8, y:7, t:'FULL'}, {x:9, y:7, t:'BLK_T'}, {x:10, y:7, t:'BLK_T'}, {x:11, y:7, t:'CONTAINER', idx:[0,1]}, {x:2, y:8, t:'GRY_B'}, {x:3, y:8, t:'FULL'}, {x:7, y:8, t:'GRY_L'}, {x:3, y:9, t:'BLK_R'}],
            alley: [{x:5, y:2, t:'BLK_B'}, {x:10, y:2, t:'GRY_L'}, {x:3, y:3, t:'GRY_L'}, {x:4, y:3, t:'CONTAINER', idx:[5,8]}, {x:6, y:3, t:'CONTAINER', idx:[8]}, {x:0, y:4, t:'BLK_T'}, {x:2, y:4, t:'CONTAINER', idx:[6,7]}, {x:4, y:4, t:'BLK_T'}, {x:6, y:4, t:'FULL'}, {x:8, y:4, t:'FULL'}, {x:9, y:4, t:'GRY_T'}, {x:10, y:4, t:'CONTAINER', idx:[8]}, {x:3, y:5, t:'CONTAINER', idx:[5,8]}, {x:7, y:5, t:'FULL'}, {x:11, y:5, t:'CONTAINER', idx:[0]}, {x:0, y:6, t:'CONTAINER', idx:[8]}, {x:4, y:6, t:'FULL'}, {x:8, y:6, t:'CONTAINER', idx:[0,3]}, {x:1, y:7, t:'CONTAINER', idx:[0]}, {x:2, y:7, t:'GRY_B'}, {x:3, y:7, t:'FULL'}, {x:5, y:7, t:'FULL'}, {x:7, y:7, t:'BLK_B'}, {x:9, y:7, t:'CONTAINER', idx:[1,2]}, {x:11, y:7, t:'BLK_B'}, {x:5, y:8, t:'CONTAINER', idx:[0]}, {x:7, y:8, t:'CONTAINER', idx:[0,3]}, {x:8, y:8, t:'GRY_R'}, {x:1, y:9, t:'GRY_R'}, {x:6, y:9, t:'BLK_T'}]
        };

        function initMapStorage() {
            const stored = localStorage.getItem('obsidian_saved_maps_v2');
            if (stored) { try { savedMaps = JSON.parse(stored); } catch(e) { savedMaps = {}; } }
            refreshMapDropdown();
        }

        function refreshMapDropdown() {
            mapSelector.innerHTML = '<option value="" disabled selected>ì €ì¥ëœ ë§µ</option>';
            Object.keys(savedMaps).sort().forEach(name => {
                const opt = document.createElement('option'); opt.value = name; opt.textContent = name; mapSelector.appendChild(opt);
            });
            const newOpt = document.createElement('option'); newOpt.value = "__NEW__"; newOpt.textContent = "+ ìƒˆ ë§µ"; mapSelector.appendChild(newOpt);
        }

        function createGrid() {
            container.style.gridTemplateColumns = `repeat(${currentGridWidth}, 1fr)`;
            container.style.gridTemplateRows = `repeat(${currentGridHeight}, 1fr)`;
            container.innerHTML = ''; tiles = [];
            for (let y = 0; y < currentGridHeight; y++) {
                for (let x = 0; x < currentGridWidth; x++) {
                    const tile = document.createElement('div'); tile.className = 'tile';
                    tile.dataset.x = x; tile.dataset.y = y;
                    const label = document.createElement('span'); label.className = 'coord-label'; label.textContent = `${x},${y}`;
                    tile.appendChild(label);
                    for (let i = 0; i < 9; i++) {
                        const sub = document.createElement('div'); sub.className = 'subcell'; tile.appendChild(sub);
                    }
                    tile.addEventListener('mousedown', (e) => {
                        isMouseDown = true; if (isEditorMode) handleEditorClick(e, x, y); else if (isSimMode) handleSimClick(x, y); else handleMeasureClick(x, y);
                    });
                    tile.addEventListener('mouseenter', () => {
                        if (isEditorMode && isMouseDown) handleEditorClick(null, x, y); else if (isSimMode) handleSimHover(x, y); else if (!isEditorMode) handleMeasureHover(x, y);
                    });
                    container.appendChild(tile); tiles.push(tile);
                }
            }
            updateLOS();
        }

        function updateLOS() {
            document.querySelectorAll('.subcell').forEach(s => s.classList.remove('sub-visible', 'in-range'));
            let origin = (simSegments.length > 0) ? simSegments[simSegments.length - 1].end : startPoint;
            if (isRangeMode && origin) { calculateRangeArea(origin); calculateLOS(origin); } 
            else if (isLOSActive && origin) { calculateLOS(origin); }
        }

        function calculateRangeArea(origin) {
            for(let y=0; y<currentGridHeight; y++) {
                for(let x=0; x<currentGridWidth; x++) {
                    const dist = Math.abs(x - origin.x) + Math.abs(y - origin.y);
                    if (dist <= rangeValue) {
                        const idx = y * currentGridWidth + x;
                        for(let i=0; i<9; i++) tiles[idx].children[i+1].classList.add('in-range');
                    }
                }
            }
        }

        function calculateLOS(origin) {
            const tileX = origin.x * 3; const tileY = origin.y * 3;
            const originPoints = [{x: tileX + 1.5, y: tileY + 1.5}, {x: tileX + 0.01, y: tileY + 0.01}, {x: tileX + 2.99, y: tileY + 2.99}];
            const blockers = [];
            tiles.forEach((t, idx) => {
                const tx = idx % currentGridWidth; const ty = Math.floor(idx / currentGridWidth);
                for(let i=0; i<9; i++) if(t.children[i+1].classList.contains('obs-full')) blockers.push({x: tx*3 + (i%3), y: ty*3 + Math.floor(i/3)});
            });
            tiles.forEach((t, idx) => {
                const tx = idx % currentGridWidth; const ty = Math.floor(idx / currentGridWidth);
                for(let i=0; i<9; i++) {
                    if(t.children[i+1].classList.contains('obs-full')) continue;
                    let visible = false;
                    for(let op of originPoints) if(!isRayBlocked(op.x, op.y, tx*3+(i%3)+0.5, ty*3+Math.floor(i/3)+0.5, blockers)) { visible = true; break; }
                    if(visible) t.children[i+1].classList.add('sub-visible');
                }
            });
        }

        function isRayBlocked(x0, y0, x1, y1, blockers) {
            for(let b of blockers) if(lineIntersectsBox(x0, y0, x1, y1, b.x, b.y, 1, 1)) return true;
            return false;
        }

        function lineIntersectsBox(x1, y1, x2, y2, bx, by, bw, bh) {
            let dx = x2 - x1, dy = y2 - y1;
            let tmin = -Infinity, tmax = Infinity;
            if (dx !== 0) {
                let t1 = (bx - x1) / dx, t2 = (bx + bw - x1) / dx;
                tmin = Math.max(tmin, Math.min(t1, t2)); tmax = Math.min(tmax, Math.max(t1, t2));
            } else if (x1 < bx || x1 > bx + bw) return false;
            if (dy !== 0) {
                let t1 = (by - y1) / dy, t2 = (by + bh - y1) / dy;
                tmin = Math.max(tmin, Math.min(t1, t2)); tmax = Math.min(tmax, Math.max(t1, t2));
            } else if (y1 < by || y1 > by + bh) return false;
            return tmax >= tmin && tmax >= 0 && tmin <= 1;
        }

        function loadMap(name) {
            const data = defaultMaps[name];
            tiles.forEach(t => { for(let i=0; i<9; i++) t.children[i+1].className = 'subcell'; });
            data.forEach(d => renderTileObject(tiles[d.y * currentGridWidth + d.x], d));
            document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
            if(document.getElementById('btn-'+name)) document.getElementById('btn-'+name).classList.add('active');
            updateLOS();
        }

        function renderTileObject(tile, data) {
            const subs = tile.querySelectorAll('.subcell');
            if (data.t === 'FULL') subs.forEach(s => s.classList.add('obs-full'));
            else if (data.t === 'BLK_T') [0,1,2].forEach(i=>subs[i].classList.add('obs-full'));
            else if (data.t === 'BLK_B') [6,7,8].forEach(i=>subs[i].classList.add('obs-full'));
            else if (data.t === 'BLK_L') [0,3,6].forEach(i=>subs[i].classList.add('obs-full'));
            else if (data.t === 'BLK_R') [2,5,8].forEach(i=>subs[i].classList.add('obs-full'));
            else if (data.t === 'BLK_M_H') [3,4,5].forEach(i=>subs[i].classList.add('obs-full'));
            else if (data.t === 'BLK_M_V') [1,4,7].forEach(i=>subs[i].classList.add('obs-full'));
            else if (data.t === 'CONTAINER' && data.idx) data.idx.forEach(i => subs[i].classList.add('obs-weak'));
        }

        function toggleEditor() { isEditorMode = !isEditorMode; editorPanel.classList.toggle('visible'); document.getElementById('btn-editor').classList.toggle('active'); resetMeasureState(); }
        function toggleSimulator() { isSimMode = !isSimMode; simControls.style.display = isSimMode ? 'flex' : 'none'; resetMeasureState(); }
        function toggleRangeMode() { isRangeMode = !isRangeMode; updateLOS(); }
        function toggleLOS() { isLOSActive = !isLOSActive; updateLOS(); }
        function changeVal(n) { 
            if(isSimMode) { maxTicks = Math.max(1, maxTicks + n); tickDisplay.innerText = `í‹± ê°¯ìˆ˜ : ${maxTicks}`; }
            else if(isRangeMode) { rangeValue = Math.max(1, rangeValue + n); updateLOS(); }
        }

        function handleMeasureClick(x, y) {
            if(!startPoint) { startPoint = {x, y}; tiles[y*currentGridWidth+x].classList.add('start'); }
            else if(!isLocked) { isLocked = true; tiles[y*currentGridWidth+x].classList.add('target'); }
            else resetMeasureState();
            updateLOS();
        }

        function handleMeasureHover(tx, ty) {
            if(isLocked || !startPoint) return;
            tiles.forEach(t => t.classList.remove('path', 'target'));
            tiles[ty*currentGridWidth+tx].classList.add('target');
            const sx = startPoint.x; const sy = startPoint.y;
            rangeText.innerText = `ì‚¬ê±°ë¦¬: ${Math.abs(tx-sx) + Math.abs(ty-sy)}`;
        }

        function resetMeasureState() {
            startPoint = null; isLocked = false; simSegments = [];
            tiles.forEach(t => t.classList.remove('start', 'target', 'path'));
            updateLOS();
        }

        initMapStorage();
        createGrid();
        loadMap('hotspot');
    </script>
</body>
</html>
