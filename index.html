<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes, orientation=landscape, viewport-fit=cover">
    
    <link rel="manifest" href="./manifest.json?v=8">
    <meta name="theme-color" content="#1e1e1e">
    <link rel="icon" href="./icon-192.png">
    <link rel="apple-touch-icon" href="./icon-192.png">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ObsidianMap">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script>
      if ("serviceWorker" in navigator) {
        // ê²½ë¡œ ë¬¸ì œ ë°©ì§€ë¥¼ ìœ„í•´ ./ ì‚¬ìš© (GitHub Pages í˜¸í™˜)
        navigator.serviceWorker.register("./service-worker.js").then(reg => {
            console.log("SW Registered");
            
            // ì—…ë°ì´íŠ¸ê°€ ë°œê²¬ë˜ë©´ ëŒ€ê¸° ì¤‘ì¸ ìƒíƒœë¥¼ ê±´ë„ˆë›°ê³  ì¦‰ì‹œ ë¡œë“œ ì‹œë„
            reg.addEventListener('updatefound', () => {
                const newWorker = reg.installing;
                newWorker.addEventListener('statechange', () => {
                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                        // ìƒˆ ë²„ì „ì´ ì„¤ì¹˜ë˜ë©´ ìƒˆë¡œê³ ì¹¨
                        window.location.reload();
                    }
                });
            });
        });

        // ì´ë¯¸ í™œì„±í™”ëœ ì„œë¹„ìŠ¤ ì›Œì»¤ê°€ ë°”ë€Œë©´(ìƒˆ ë²„ì „) ìƒˆë¡œê³ ì¹¨
        navigator.serviceWorker.addEventListener("controllerchange", () => {
          window.location.reload();
        });
      }
    </script>

    <title>Obsidian Protocol Map Tool v61 (Final Complete)</title>
    <style>
        
        /* --- ìŠ¤íƒ€ì¼: ì‚¬ìš©ì ì›ë³¸ + 1.5ë°° í¬ê¸° + ëª¨ë°”ì¼ ëŒ€ì‘ --- */
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #1e1e1e;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column; /* ì„¸ë¡œë¡œ ìˆœì„œëŒ€ë¡œ ìŒ“ìŒ */
            overflow: hidden; /* ì „ì²´ í˜ì´ì§€ ìŠ¤í¬ë¡¤ì€ ë§‰ìŒ */
            user-select: none;
            touch-action: manipulation;
        }

        .main-area {
            flex: 1; /* ìƒë‹¨/í•˜ë‹¨ UIë¥¼ ì œì™¸í•œ ë‚¨ì€ ê³µê°„ì„ ì „ë¶€ ì‚¬ìš© */
            width: 100%;
            overflow: auto; /* ì¤‘ìš”: ë§µì´ ì»¤ì§€ë©´ ì—¬ê¸°ì„œ ìŠ¤í¬ë¡¤ ë°œìƒ */
            display: flex;
            justify-content: center; /* ë§µ ê°€ë¡œ ì¤‘ì•™ */
            align-items: center;     /* ë§µ ì„¸ë¡œ ì¤‘ì•™ */
            background: #111;
            position: relative;
            touch-action: pan-x pan-y pinch-zoom; /* ë§µ ë“œë˜ê·¸ ì´ë™ í—ˆìš© */
            padding: 20px;
            box-sizing: border-box;
        }

        .ui-header {
            width: 100%;
            background-color: #252525;
            padding: 8px 0;
            border-bottom: 1px solid #333;
            z-index: 100;
            display: flex;
            justify-content: center;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            flex-shrink: 0; /* ë†’ì´ ê³ ì • */
        }

        .controls { 
            display: flex; gap: 6px; 
            padding: 0 15px;
            align-items: center;
            flex-wrap: nowrap;
        }

        .bottom-ui {
            width: 100%;
            background-color: #1e1e1e;
            border-top: 1px solid #333;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-shrink: 0; /* ë†’ì´ ê³ ì • */
            z-index: 100;
            /* ì•„ì´í° í•˜ë‹¨ í™ˆë°” ì˜ì—­ ëŒ€ì‘ */
            padding-bottom: max(10px, env(safe-area-inset-bottom));
        }

       #info-panel {
            text-align: center;
            background: #2d2d2d;
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid #444;
            width: 95%;
            max-width: 600px;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            transition: 0.3s;
        }
        #info-panel.edit-mode { border-color: #009688; background-color: #004d40; }
        #info-panel.sim-mode { border-color: #9c27b0; background-color: #4a148c; }
        #info-panel.range-mode { border-color: #fbc02d; background-color: #1a1a1a; }
        
        #range-text { 
            font-size: 1.4em; font-weight: bold; color: #4fc3f7; margin-bottom: 8px; 
            white-space: pre-wrap; line-height: 1.5;
            max-height: none; 
            overflow: visible;
        }
        
        #detail-text { font-size: 1.1em; color: #aaa; margin-bottom: 5px; }
        #status-text { font-size: 0.95em; color: #888; font-style: italic; margin-bottom: 10px;}

        .legend-box {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.2);
            font-size: 0.85em;
            color: #ddd;
        }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; border: 1px solid rgba(255,255,255,0.3); }
        .l-green { background-color: rgba(76, 175, 80, 0.8); }
        .l-yellow { background-color: rgba(255, 235, 59, 0.5); border: 1px dashed #fff; }
        .l-blue { background-color: rgba(33, 150, 243, 0.8); }

        button {
            padding: 8px 14px;
            background: #3a3a3a;
            color: white;
            border: 1px solid #555;
            cursor: pointer;
            border-radius: 4px;
            font-weight: 600;
            transition: all 0.2s;
        }
        button:hover { background: #505050; }
        button.active { background-color: #2e7d32; border-color: #1b5e20; }
        
        #btn-editor { background-color: #ff9800; color: #000; border-color: #f57c00; }
        #btn-editor.active { background-color: #e65100; color: white; box-shadow: 0 0 10px #ff9800; }

        #btn-sim { background-color: #9c27b0; color: white; border-color: #7b1fa2; }
        #btn-sim.active { background-color: #7b1fa2; box-shadow: 0 0 10px #9c27b0; }

        #btn-area1 { border-color: #ff5722; color: #ffab91; }
        #btn-area1.active { background-color: #d84315; color: white; box-shadow: 0 0 8px #ff5722; }
        #btn-area2 { border-color: #00bcd4; color: #80deea; }
        #btn-area2.active { background-color: #0097a7; color: white; box-shadow: 0 0 8px #00bcd4; }

        #btn-los { background-color: #00897b; color: white; border-color: #00695c; }
        #btn-los.active { background-color: #004d40; box-shadow: 0 0 10px #00897b; }

        #btn-range { background-color: #fbc02d; color: black; border-color: #f57f17; }
        #btn-range.active { background-color: #f57f17; color: white; box-shadow: 0 0 10px #fbc02d; }

        #map-selector {
            padding: 8px; border-radius: 4px; background-color: #263238;
            color: white; border: 1px solid #37474f; font-size: 0.95em;
            cursor: pointer; min-width: 150px;
        }
        #map-selector:focus { outline: none; border-color: #00bcd4; }

        #sim-controls {
            display: none; align-items: center; gap: 15px;
            margin-bottom: 15px; 
            background: #333; padding: 8px 20px;
            border-radius: 20px; border: 1px solid #555;
        }
        #sim-controls.visible { display: flex; }
        .tick-btn { width: 35px; height: 35px; border-radius: 50%; padding: 0; font-size: 1.4em; line-height: 1;}

    #grid-container {
            display: grid; 
            gap: 1px;
            background-color: #444; 
            border: 4px solid #333;
            padding: 2px; 
            border-radius: 4px;
            margin: auto; /* ì¤‘ì•™ ë°°ì¹˜ ìœ ì§€ */
        }

        /* âœ… íƒ€ì¼ í¬ê¸° 65px (1.5ë°° í™•ëŒ€) */
    .tile {
            width: min(65px, 7.8vw); 
            height: min(65px, 7.8vw);
            background-color: #fff;
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            grid-template-rows: repeat(3, 1fr);
            position: relative; 
        }
        
        .tile.area-red { background-color: rgba(255, 50, 50, 0.02) !important; box-shadow: inset 0 0 0 2px rgba(255, 50, 50, 0.3); }
        .tile.area-blue { background-color: rgba(50, 50, 255, 0.02) !important; box-shadow: inset 0 0 0 2px rgba(80, 80, 255, 0.3); }

        .subcell.sub-visible {
            background-color: rgba(76, 175, 80, 0.6) !important; 
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.15);
        }
        .subcell.in-range {
            background-color: rgba(255, 235, 59, 0.25); 
            box-shadow: inset 0 0 0 1px rgba(255, 235, 59, 0.5); 
        }
        .subcell.sub-visible.in-range {
            background-color: rgba(33, 150, 243, 0.65) !important; 
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.4);
        }

        .coord-label {
            position: absolute; top: 1px; left: 2px;
            font-size: 11px; color: #ccc; z-index: 10; pointer-events: none; font-family: monospace;
        }

        .subcell { border: 0.1px solid rgba(0,0,0,0.05); box-sizing: border-box; }
        .subcell.obs-full { background-color: #111; } 
        .subcell.obs-partial { background-color: #777; background-image: repeating-linear-gradient(45deg, #666, #666 2px, #777 2px, #777 4px); }
        .subcell.obs-weak { background-color: #009688; box-shadow: inset 0 0 2px rgba(255,255,255,0.3); }

        .tile.start::after { content: ''; position: absolute; inset: 0; background-color: rgba(33, 150, 243, 0.6); border: 2px solid #2196f3; z-index: 5; pointer-events: none;}
        
        .tile.path::before { content: ''; position: absolute; inset: 2px; background-color: rgba(255, 235, 59, 0.3); border: 2px dashed #fdd835; z-index: 4; border-radius: 4px; pointer-events: none;}
        .tile.path-tick-0::before { content: ''; position: absolute; inset: 2px; background-color: rgba(33, 150, 243, 0.4); border: 2px dashed #fdd835; z-index: 4; border-radius: 4px; pointer-events: none;}
        .tile.path-tick-1::before { content: ''; position: absolute; inset: 2px; background-color: rgba(255, 235, 59, 0.4); border: 2px dashed #fdd835; z-index: 4; border-radius: 4px; pointer-events: none;}
        .tile.path-tick-2::before { content: ''; position: absolute; inset: 2px; background-color: rgba(244, 67, 54, 0.4); border: 2px dashed #d32f2f; z-index: 4; border-radius: 4px; pointer-events: none;}
        
        .tile.target::before { content: ''; position: absolute; inset: 0; background-color: rgba(244, 67, 54, 0.5); border: 2px solid #e53935; z-index: 6; pointer-events: none;}

        #editor-panel {
            width: 320px; min-width: 320px; background: #222;
            border-left: 1px solid #444; padding: 15px;
            display: none; flex-direction: column; overflow-y: auto;
        }
        #editor-panel.visible { display: flex; }

        .editor-section { margin-bottom: 25px; }
        .editor-title { 
            font-weight: bold; margin-bottom: 10px; color: #fff; 
            border-bottom: 1px solid #555; padding-bottom: 5px; font-size: 0.95em;
        }
        
        .tool-btn {
            display: flex; align-items: center; justify-content: space-between;
            width: 100%; margin-bottom: 5px; text-align: left;
            padding: 10px; background: #333; border: 1px solid #444;
            font-size: 0.9em; cursor: pointer; color: #ccc;
        }
        .tool-btn:hover { background: #444; }
        .tool-btn.selected { background: #009688; color: white; border-color: #004d40; }
        
        .preset-group { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .preset-group button { 
            width: 100%; font-size: 0.85em; padding: 8px; cursor: pointer; 
            background: #444; color: #ddd; border: 1px solid #555;
            display: flex; align-items: center; justify-content: center; gap: 4px;
        }
        .preset-group button:hover { background: #555; }

        #io-area { margin-top: auto; border-top: 1px solid #555; padding-top: 10px; }
        #import-input {
            width: 100%; height: 50px; background: #111; color: #0f0; font-family: monospace; font-size: 0.8em;
            border: 1px solid #444; margin-bottom: 5px; resize: none;
        }
        .io-btn-group { display: flex; gap: 5px; margin-bottom: 5px;}
        .io-btn { flex: 1; padding: 10px; font-weight: bold; cursor: pointer; color: white; border: none; }
        
        #btn-export { background: #0277bd; }
        #btn-import { background: #e65100; }
        
        #save-controls { display: flex; gap: 5px; margin-bottom: 10px; }
        #btn-save-as { background: #2e7d32; flex:1; }
        #btn-delete-map { background: #c62828; flex:1; }
        
        #clear-editor-btn { width: 100%; background: #d32f2f; margin-bottom: 10px; color: white; cursor: pointer; padding:10px; border:none;}

        #grid-size-controls {
            display: flex; align-items: center; gap: 5px; background: #333; padding: 10px; border-radius: 4px;
        }
        .size-input { width: 45px; padding: 5px; background: #222; color: white; border: 1px solid #555; font-weight: bold; text-align: center;}

        /* --- ğŸ“± ëª¨ë°”ì¼ ì„¸ë¡œ ëª¨ë“œ ëŒ€ì‘ --- */
        @media screen and (orientation: portrait) {
            body { flex-direction: column; overflow-y: auto; }
            .main-area { width: 100%; height: auto; margin-right: 0; }
            .ui-header { overflow-x: auto; justify-content: flex-start; padding: 5px; }
            .bottom-ui { 
                flex-direction: column; gap: 10px; padding-bottom: 20px; min-height: 120px;
                background: #1e1e1e;
            }
            #sim-controls { width: 100%; justify-content: center; }
            #info-panel { width: 100%; margin-bottom: 20px;}
            
            /* ì—ë””í„° íŒ¨ë„: ëª¨ë°”ì¼ì—ì„œëŠ” ì•„ë˜ì—ì„œ ìœ„ë¡œ ì˜¬ë¼ì˜¤ê²Œ */
            #editor-panel {
                top: auto; bottom: 0; left: 0; right: 0; width: 100%; height: 50vh;
                border-left: none; border-top: 2px solid #444;
            }
        }
    </style>
</head>
<body>

    <div class="main-area">
        <div class="ui-header">
            <div class="controls">
                <button id="btn-hotspot" onclick="loadMap('hotspot')">Hotspot</button>
                <button id="btn-crossroads" onclick="loadMap('crossroads')">Crossroads</button>
                <button id="btn-alley" onclick="loadMap('alley')">Alley</button>
                
                <div style="width:1px; height:20px; background:#555; margin:0 5px;"></div>

                <select id="map-selector" onchange="handleMapSelect()">
                    <option value="" disabled selected>-- ì €ì¥ëœ ë§µ ì„ íƒ --</option>
                    <option value="__NEW__">&lt; ìƒˆ ë§µ ì¶”ê°€ &gt;</option>
                </select>
                
                <div style="width:1px; height:20px; background:#555; margin:0 5px;"></div>

                <button id="btn-editor" onclick="toggleEditor()">ğŸ›  ë§µ ì—ë””í„°</button>
                <button id="btn-area1" class="btn-area" onclick="toggleArea1()">Area1</button>
                <button id="btn-area2" class="btn-area" onclick="toggleArea2()">Area2</button>
                <button id="btn-sim" onclick="toggleSimulator()">ğŸ² ì‹œë®¬ë ˆì´í„°</button>
                <button id="btn-los" onclick="toggleLOS()">ğŸ‘ LOS</button>
                <button id="btn-range" onclick="toggleRangeMode()">ğŸ“ ì‚¬ê±°ë¦¬ë²”ìœ„</button>
            </div>
        </div>

        <div id="grid-container"></div>

        <div class="bottom-ui">
            <div id="sim-controls">
                <button class="tick-btn" onclick="changeVal(-1)">-</button>
                <span id="tick-display" style="font-weight:bold; color: #fff;">í‹± ê°¯ìˆ˜ : 3</span>
                <button class="tick-btn" onclick="changeVal(1)">+</button>
            </div>

            <div id="info-panel">
                <div id="range-text">ìœ„ì¹˜ ì„ íƒ</div>
                <div id="detail-text">ì¼ë°˜ ëª¨ë“œ</div>
                <div id="status-text">ì‹œì‘ ì§€ì ì„ í´ë¦­í•˜ì„¸ìš”</div>
                
                <div class="legend-box">
                    <div class="legend-item"><div class="legend-color l-green"></div><span>ì‹œì•¼</span></div>
                    <div class="legend-item"><div class="legend-color l-yellow"></div><span>ì‚¬ê±°ë¦¬</span></div>
                    <div class="legend-item"><div class="legend-color l-blue"></div><span>ê³µê²© ê°€ëŠ¥</span></div>
                </div>
            </div>
        </div>
    </div>

    <div id="editor-panel">
        
        <div class="editor-section">
            <div class="editor-title">ğŸ”„ ëŒ€ì¹­ ë³µì‚¬ ë„êµ¬ (ì ëŒ€ì¹­)</div>
            <div class="preset-group">
                <button onclick="applySymmetry('T2B')">â¬† ìƒë‹¨ â¡ í•˜ë‹¨</button>
                <button onclick="applySymmetry('B2T')">â¬‡ í•˜ë‹¨ â¡ ìƒë‹¨</button>
                <button onclick="applySymmetry('L2R')">â¬… ì¢Œì¸¡ â¡ ìš°ì¸¡</button>
                <button onclick="applySymmetry('R2L')">â¡ ìš°ì¸¡ â¡ ì¢Œì¸¡</button>
            </div>
            <div style="font-size:0.8em; color:#888; margin-top:5px; text-align:center;">* ë°˜ëŒ€í¸ì„ ì§€ìš°ê³  íšŒì „í•˜ì—¬ ë®ì–´ì”ë‹ˆë‹¤.</div>
        </div>

        <div class="editor-section">
            <div class="editor-title">ğŸ“ ë§µ í¬ê¸° ì„¤ì • (Max 40)</div>
            <div id="grid-size-controls">
                <span>W:</span> <input type="number" id="grid-width-input" class="size-input" value="12" min="5" max="40">
                <span>H:</span> <input type="number" id="grid-height-input" class="size-input" value="12" min="5" max="40">
                <button class="io-btn" style="padding: 5px 10px; flex:0;" onclick="applyGridSize()">ë³€ê²½</button>
            </div>
            <div style="font-size:0.8em; color:#888; margin-top:5px;">* ë³€ê²½ ì‹œ ê¸°ì¡´ ë°°ì¹˜ëŠ” ìœ ì§€ë©ë‹ˆë‹¤.</div>
        </div>

        <div class="editor-section">
            <div class="editor-title">ë§µ ì €ì¥ ê´€ë¦¬</div>
            <div id="current-map-name" style="color:#00bcd4; margin-bottom:5px; font-size:0.9em;">í˜„ì¬ ë§µ: (ì €ì¥ë˜ì§€ ì•ŠìŒ)</div>
            <div id="save-controls">
                <button id="btn-save-as" class="io-btn" onclick="saveMapAs()">ğŸ’¾ ì €ì¥ / ì´ë¦„ë³€ê²½</button>
                <button id="btn-delete-map" class="io-btn" onclick="deleteCurrentMap()">ğŸ—‘ ì‚­ì œ</button>
            </div>
            <textarea id="import-input" placeholder="ì½”ë“œ ë¶™ì—¬ë„£ê¸°..."></textarea>
            <div class="io-btn-group">
                <button id="btn-export" class="io-btn" onclick="exportMapCode()">ğŸ“‹ ì½”ë“œ ë³µì‚¬</button>
                <button id="btn-import" class="io-btn" onclick="importMapCode()">ğŸ“‚ ì½”ë“œ ë¶ˆëŸ¬ì˜¤ê¸°</button>
            </div>
        </div>

        <button id="clear-editor-btn" onclick="clearMapData()">âš¡ ë§µ ì´ˆê¸°í™” (ì§€ìš°ê¸°)</button>

        <div class="editor-section">
            <div class="editor-title">ê¸°ë³¸ ë„êµ¬</div>
            <button class="tool-btn selected" onclick="selectTool('ERASER')"><span>â¬œ ì§€ìš°ê°œ</span></button>
        </div>
        <div class="editor-section">
            <div class="editor-title">ë¶„ì‡„ê°€ëŠ¥ë²½ (Breakable)</div>
            <button class="tool-btn" onclick="selectTool('CUSTOM_DRAW')"><span>âœï¸ <b>ì§ì ‘ ê·¸ë¦¬ê¸° (í´ë¦­/ë“œë˜ê·¸)</b></span></button>
        </div>
        <div class="editor-section">
            <div class="editor-title">â¬› ê±´ì¶•ë¬¼ (3x3 - ì „ì²´)</div>
            <button class="tool-btn" onclick="selectTool('FULL')"><span>â¬› 3x3 ê½‰ ì°¬ ìƒì</span></button>
        </div>
        <div class="editor-section">
            <div class="editor-title">â¬› ê±´ì¶•ë¬¼ (1x3 - ë¶€ë¶„)</div>
            <div class="preset-group">
                <button onclick="selectTool('BLK_T')">â¬† ìƒë‹¨</button>
                <button onclick="selectTool('BLK_B')">â¬‡ í•˜ë‹¨</button>
                <button onclick="selectTool('BLK_L')">â¬… ì¢Œì¸¡</button>
                <button onclick="selectTool('BLK_R')">â¡ ìš°ì¸¡</button>
                <button onclick="selectTool('BLK_M_H')">â– ì¤‘ì•™(ê°€)</button>
                <button onclick="selectTool('BLK_M_V')">â˜ ì¤‘ì•™(ì„¸)</button>
            </div>
        </div>
        <div class="editor-section">
            <div class="editor-title">â–¨ ë°©ì–´ë²½ (1x2 - ë¶€ë¶„)</div>
            <div class="preset-group">
                <button onclick="selectTool('GRY_T')">â¬† ìƒë‹¨</button>
                <button onclick="selectTool('GRY_B')">â¬‡ í•˜ë‹¨</button>
                <button onclick="selectTool('GRY_L')">â¬… ì¢Œì¸¡</button>
                <button onclick="selectTool('GRY_R')">â¡ ìš°ì¸¡</button>
                <button onclick="selectTool('GRY_M_H')">â– ì¤‘ì•™(ê°€)</button>
                <button onclick="selectTool('GRY_M_V')">â˜ ì¤‘ì•™(ì„¸)</button>
            </div>
        </div>
    </div>

    <script>
        const container = document.getElementById('grid-container');
        const infoPanel = document.getElementById('info-panel');
        const rangeText = document.getElementById('range-text');
        const detailText = document.getElementById('detail-text');
        const statusText = document.getElementById('status-text');
        const editorPanel = document.getElementById('editor-panel');
        const simControls = document.getElementById('sim-controls');
        const tickDisplay = document.getElementById('tick-display');
        const importInput = document.getElementById('import-input');
        const mapSelector = document.getElementById('map-selector');
        const currentMapNameDisplay = document.getElementById('current-map-name');
        
        const widthInput = document.getElementById('grid-width-input');
        const heightInput = document.getElementById('grid-height-input');
        
        let tiles = []; 
        let isEditorMode = false;
        let isSimMode = false;
        let isRangeMode = false; 
        let isArea1Active = false; 
        let isArea2Active = false;
        let isLOSActive = false;
        let isMouseDown = false;
        let currentTool = 'ERASER'; 
        
        let currentGridWidth = 12;
        let currentGridHeight = 12;
        
        let startPoint = null;
        let isLocked = false;
        let maxTicks = 3;
        let rangeValue = 4; // Default Range
        let simSegments = []; 
        
        let lockedAxis = null; 

        let currentEditingMapName = null;

        window.addEventListener('mouseup', () => { isMouseDown = false; });

        // --- ë§µ ë°ì´í„° ---
        const defaultMaps = {
            hotspot: [
                {x:9, y:1, t:'CONTAINER', idx:[8]}, {x:7, y:2, t:'FULL'}, {x:8, y:2, t:'CONTAINER', idx:[2]}, {x:10, y:2, t:'BLK_B'},
                {x:2, y:3, t:'GRY_R'}, {x:7, y:3, t:'FULL'}, {x:2, y:4, t:'BLK_T'}, {x:5, y:4, t:'BLK_T'}, {x:6, y:4, t:'CONTAINER', idx:[2,5]},
                {x:8, y:4, t:'FULL'}, {x:9, y:4, t:'CONTAINER', idx:[7,8]}, {x:10, y:4, t:'CONTAINER', idx:[3,6]}, {x:4, y:5, t:'CONTAINER', idx:[2]},
                {x:8, y:5, t:'GRY_R'}, {x:3, y:6, t:'GRY_L'}, {x:7, y:6, t:'CONTAINER', idx:[6]}, {x:1, y:7, t:'CONTAINER', idx:[2,5]},
                {x:2, y:7, t:'CONTAINER', idx:[0,1]}, {x:3, y:7, t:'FULL'}, {x:5, y:7, t:'CONTAINER', idx:[3,6]}, {x:6, y:7, t:'BLK_B'},
                {x:9, y:7, t:'BLK_B'}, {x:4, y:8, t:'FULL'}, {x:9, y:8, t:'GRY_L'}, {x:1, y:9, t:'BLK_T'}, {x:3, y:9, t:'CONTAINER', idx:[0]},
                {x:4, y:9, t:'FULL'}, {x:2, y:10, t:'CONTAINER', idx:[0]}
            ],
            crossroads: [
                {x:8, y:2, t:'BLK_L'}, {x:4, y:3, t:'GRY_R'}, {x:8, y:3, t:'FULL'}, {x:9, y:3, t:'GRY_T'}, {x:0, y:4, t:'CONTAINER', idx:[7,8]},
                {x:1, y:4, t:'BLK_B'}, {x:2, y:4, t:'BLK_B'}, {x:3, y:4, t:'FULL'}, {x:4, y:4, t:'FULL'}, {x:5, y:4, t:'CONTAINER', idx:[7,8]},
                {x:6, y:4, t:'CONTAINER', idx:[5,8]}, {x:8, y:4, t:'GRY_R'}, {x:4, y:5, t:'CONTAINER', idx:[8]}, {x:7, y:6, t:'CONTAINER', idx:[0]},
                {x:3, y:7, t:'GRY_L'}, {x:5, y:7, t:'CONTAINER', idx:[0,3]}, {x:6, y:7, t:'CONTAINER', idx:[0,1]}, {x:7, y:7, t:'FULL'},
                {x:8, y:7, t:'FULL'}, {x:9, y:7, t:'BLK_T'}, {x:10, y:7, t:'BLK_T'}, {x:11, y:7, t:'CONTAINER', idx:[0,1]}, {x:2, y:8, t:'GRY_B'},
                {x:3, y:8, t:'FULL'}, {x:7, y:8, t:'GRY_L'}, {x:3, y:9, t:'BLK_R'}
            ],
            alley: [
                {x:5, y:2, t:'BLK_B'}, {x:10, y:2, t:'GRY_L'}, {x:3, y:3, t:'GRY_L'}, {x:4, y:3, t:'CONTAINER', idx:[5,8]}, {x:6, y:3, t:'CONTAINER', idx:[8]},
                {x:0, y:4, t:'BLK_T'}, {x:2, y:4, t:'CONTAINER', idx:[6,7]}, {x:4, y:4, t:'BLK_T'}, {x:6, y:4, t:'FULL'}, {x:8, y:4, t:'FULL'},
                {x:9, y:4, t:'GRY_T'}, {x:10, y:4, t:'CONTAINER', idx:[8]}, {x:3, y:5, t:'CONTAINER', idx:[5,8]}, {x:7, y:5, t:'FULL'},
                {x:11, y:5, t:'CONTAINER', idx:[0]}, {x:0, y:6, t:'CONTAINER', idx:[8]}, {x:4, y:6, t:'FULL'}, {x:8, y:6, t:'CONTAINER', idx:[0,3]},
                {x:1, y:7, t:'CONTAINER', idx:[0]}, {x:2, y:7, t:'GRY_B'}, {x:3, y:7, t:'FULL'}, {x:5, y:7, t:'FULL'}, {x:7, y:7, t:'BLK_B'},
                {x:9, y:7, t:'CONTAINER', idx:[1,2]}, {x:11, y:7, t:'BLK_B'}, {x:5, y:8, t:'CONTAINER', idx:[0]}, {x:7, y:8, t:'CONTAINER', idx:[0,3]},
                {x:8, y:8, t:'GRY_R'}, {x:1, y:9, t:'GRY_R'}, {x:6, y:9, t:'BLK_T'}
            ]
        };

        let savedMaps = {};

        function initMapStorage() {
            const stored = localStorage.getItem('obsidian_saved_maps_v2');
            if (stored) {
                try { savedMaps = JSON.parse(stored); } 
                catch(e) { console.error(e); savedMaps = {}; }
            }
            refreshMapDropdown();
        }

        function refreshMapDropdown() {
            mapSelector.innerHTML = '<option value="" disabled selected>-- ì €ì¥ëœ ë§µ ì„ íƒ --</option>';
            Object.keys(savedMaps).sort().forEach(name => {
                const opt = document.createElement('option');
                opt.value = name; opt.textContent = name;
                mapSelector.appendChild(opt);
            });
            const newOpt = document.createElement('option');
            newOpt.value = "__NEW__"; newOpt.textContent = "< ìƒˆ ë§µ ì¶”ê°€ >";
            newOpt.style.color = "#4fc3f7"; newOpt.style.fontWeight = "bold";
            mapSelector.appendChild(newOpt);
        }

        // --- ëŒ€ì¹­ ë³µì‚¬ ê¸°ëŠ¥ ---
        function applySymmetry(mode) {
            const W = currentGridWidth;
            const H = currentGridHeight;
            const halfH = Math.ceil(H / 2);
            const halfW = Math.ceil(W / 2);

            let startX = 0, endX = W, startY = 0, endY = H;

            if (mode === 'T2B') endY = halfH; 
            else if (mode === 'B2T') startY = Math.floor(H/2);
            else if (mode === 'L2R') endX = halfW;
            else if (mode === 'R2L') startX = Math.floor(W/2);

            const updates = [];

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const srcIdx = y * W + x;
                    const srcTile = tiles[srcIdx];
                    const tx = (W - 1) - x;
                    const ty = (H - 1) - y;

                    const subcells = srcTile.querySelectorAll('.subcell');
                    const cellData = [];
                    for(let i=0; i<9; i++) {
                        const cl = subcells[i].classList;
                        if(cl.contains('obs-full')) cellData.push('obs-full');
                        else if(cl.contains('obs-partial')) cellData.push('obs-partial');
                        else if(cl.contains('obs-weak')) cellData.push('obs-weak');
                        else cellData.push(null);
                    }
                    updates.push({tx, ty, cellData});
                }
            }

            updates.forEach(up => {
                const tgtIdx = up.ty * W + up.tx;
                const tgtTile = tiles[tgtIdx];
                if (!tgtTile) return;
                for(let i=0; i<9; i++) tgtTile.children[i+1].className = 'subcell';
                for(let i=0; i<9; i++) {
                    const type = up.cellData[i];
                    if (type) tgtTile.children[(8-i)+1].classList.add(type);
                }
            });
            updateLOS();
            alert("ëŒ€ì¹­ ë³µì‚¬ ì™„ë£Œ!");
        }

        // --- LOS & Range Logic ---
        function toggleLOS() {
            isLOSActive = !isLOSActive;
            const btn = document.getElementById('btn-los');
            if(isLOSActive) btn.classList.add('active');
            else btn.classList.remove('active');
            updateLOS();
        }

        // Range Mode Toggle
        function toggleRangeMode() {
            if(isEditorMode) toggleEditor();
            if(isSimMode) toggleSimulator();
            
            isRangeMode = !isRangeMode;
            const btn = document.getElementById('btn-range');
            
            if(isRangeMode) {
                btn.classList.add('active');
                simControls.classList.add('visible'); 
                infoPanel.classList.add('range-mode');
                
                tickDisplay.textContent = `ì‚¬ê±°ë¦¬ : ${rangeValue}`;
                rangeText.textContent = "ì‚¬ê±°ë¦¬ í™•ì¸ ëª¨ë“œ";
                detailText.textContent = `í˜„ì¬ ì„¤ì •ëœ ì‚¬ê±°ë¦¬: ${rangeValue}`;
                statusText.textContent = "ë§µì„ í´ë¦­í•˜ì—¬ ì‚¬ê±°ë¦¬ì™€ ì‹œì•¼ë¥¼ í™•ì¸í•˜ì„¸ìš”";
                
                resetMeasureState();
            } else {
                btn.classList.remove('active');
                simControls.classList.remove('visible');
                infoPanel.classList.remove('range-mode');
                resetMeasureState();
            }
            updateLOS(); 
        }

        // Unified update function
        function updateLOS() {
            document.querySelectorAll('.subcell').forEach(s => s.classList.remove('sub-visible', 'in-range'));
            
            let origin = null;
            if (simSegments.length > 0) {
                origin = simSegments[simSegments.length - 1].end;
            } else if (startPoint) {
                origin = startPoint;
            }

            if (isRangeMode && origin) {
                calculateRangeArea(origin);
                calculateLOS(origin); 
            } else if (isLOSActive && origin) {
                calculateLOS(origin);
            }
        }

        function calculateRangeArea(origin) {
            for(let y=0; y<currentGridHeight; y++) {
                for(let x=0; x<currentGridWidth; x++) {
                    const dist = Math.abs(x - origin.x) + Math.abs(y - origin.y);
                    if (dist <= rangeValue) {
                        const idx = y * currentGridWidth + x;
                        const tile = tiles[idx];
                        for(let i=0; i<9; i++) {
                            tile.children[i+1].classList.add('in-range');
                        }
                    }
                }
            }
        }

        function calculateLOS(origin) {
            const tileX = origin.x * 3;
            const tileY = origin.y * 3;
            const inset = 0.01;
            const originPoints = [
                {x: tileX + 1.5, y: tileY + 1.5},
                {x: tileX + inset, y: tileY + inset},
                {x: tileX + 3 - inset, y: tileY + inset},
                {x: tileX + inset, y: tileY + 3 - inset},
                {x: tileX + 3 - inset, y: tileY + 3 - inset}
            ];

            const blockers = [];
            for(let y=0; y<currentGridHeight; y++) {
                for(let x=0; x<currentGridWidth; x++) {
                    const idx = y * currentGridWidth + x;
                    const tile = tiles[idx];
                    for(let i=0; i<9; i++) {
                        if(tile.children[i+1].classList.contains('obs-full')) {
                            blockers.push({
                                x: x * 3 + (i % 3),
                                y: y * 3 + Math.floor(i / 3),
                                w: 1, h: 1,
                                tx: x, ty: y 
                            });
                        }
                    }
                }
            }

            const gridW = currentGridWidth * 3;
            const gridH = currentGridHeight * 3;

            for (let gy = 0; gy < gridH; gy++) {
                for (let gx = 0; gx < gridW; gx++) {
                    const tx = Math.floor(gx / 3);
                    const ty = Math.floor(gy / 3);
                    const tileIdx = ty * currentGridWidth + tx;
                    const tile = tiles[tileIdx];
                    const subIdx = (gy % 3) * 3 + (gx % 3);
                    
                    if (!tile || tile.children[subIdx + 1].classList.contains('obs-full')) continue;

                    const tInset = 0.1;
                    const targetPoints = [
                        {x: gx + 0.5, y: gy + 0.5},
                        {x: gx + tInset, y: gy + tInset},
                        {x: gx + 1-tInset, y: gy + tInset},
                        {x: gx + tInset, y: gy + 1-tInset},
                        {x: gx + 1-tInset, y: gy + 1-tInset}
                    ];
                    
                    let isVisible = false;
                    
                    outerCheck:
                    for (let op of originPoints) {
                        for (let tp of targetPoints) {
                            if (!isRayBlocked(op.x, op.y, tp.x, tp.y, blockers, origin)) {
                                isVisible = true;
                                break outerCheck;
                            }
                        }
                    }

                    if (isVisible) {
                        tile.children[subIdx + 1].classList.add('sub-visible');
                    }
                }
            }
        }

        function isRayBlocked(x0, y0, x1, y1, blockers, startTile) {
            const tSubX = Math.floor(x1);
            const tSubY = Math.floor(y1);

            for (let b of blockers) {
                // ëª©í‘œ ì§€ì  ìì²´ëŠ” ê°€ë¦¬ì§€ ì•ŠìŒ
                if(b.x === tSubX && b.y === tSubY) continue;

                if(lineIntersectsBox(x0, y0, x1, y1, b.x, b.y, 1, 1)) {
                    return true;
                }
            }
            return false;
        }

        function lineIntersectsBox(x1, y1, x2, y2, bx, by, bw, bh) {
            const minX = bx;
            const minY = by;
            const maxX = bx + bw;
            const maxY = by + bh;

            const dx = x2 - x1;
            const dy = y2 - y1;
            
            let t0 = 0.0;
            let t1 = 1.0;

            const p = [-dx, dx, -dy, dy];
            const q = [x1 - minX, maxX - x1, y1 - minY, maxY - y1];

            for(let i=0; i<4; i++) {
                if(p[i] === 0) {
                    if(q[i] < 0) return false; 
                } else {
                    const t = q[i] / p[i];
                    if(p[i] < 0) {
                        if(t > t1) return false;
                        if(t > t0) t0 = t;
                    } else {
                        if(t < t0) return false;
                        if(t < t1) t1 = t;
                    }
                }
            }
            return t0 <= t1;
        }

        // --- Area ë¡œì§ ---
        function toggleArea1() {
            if(isArea2Active) toggleArea2();
            isArea1Active = !isArea1Active;
            const btn = document.getElementById('btn-area1');
            if(isArea1Active) btn.classList.add('active'); else btn.classList.remove('active');
            updateAreaOverlay();
        }

        function toggleArea2() {
            if(isArea1Active) toggleArea1();
            isArea2Active = !isArea2Active;
            const btn = document.getElementById('btn-area2');
            if(isArea2Active) btn.classList.add('active'); else btn.classList.remove('active');
            updateAreaOverlay();
        }

        function updateAreaOverlay() {
            tiles.forEach(t => { t.classList.remove('area-red', 'area-blue'); });
            
            for(let y=0; y<currentGridHeight; y++) {
                for(let x=0; x<currentGridWidth; x++) {
                    const idx = y * currentGridWidth + x;
                    const tile = tiles[idx];
                    if(!tile) continue;

                    if (isArea1Active) {
                        if (x >= 0 && x <= 4 && y >= 0 && y <= 2) tile.classList.add('area-red');
                        if (x >= 7 && x <= 11 && y >= 9 && y <= 11) tile.classList.add('area-blue');
                    }
                    if (isArea2Active) {
                        if (y >= 0 && y <= 1 && x >= 0 && x <= 11) tile.classList.add('area-red');
                        if (y >= 10 && y <= 11 && x >= 0 && x <= 11) tile.classList.add('area-blue');
                    }
                }
            }
        }

        // --- ì‹œë®¬ë ˆì´í„° / ì¸¡ì • ë¡œì§ ---
        function toggleSimulator() {
            if(isEditorMode) toggleEditor(); 
            if(isRangeMode) toggleRangeMode(); 

            isSimMode = !isSimMode;
            const btn = document.getElementById('btn-sim');

            if(isSimMode) {
                btn.classList.add('active'); simControls.classList.add('visible'); infoPanel.classList.add('sim-mode');
                resetSimState(); 
                rangeText.textContent = "ì‹œë®¬ë ˆì´í„° ëŒ€ê¸°";
                detailText.textContent = "ì‹œì‘ ì§€ì ì„ í´ë¦­í•˜ì„¸ìš”";
                statusText.textContent = `í‹± 1 ì´ë™ì„ ì‹œì‘í•˜ì„¸ìš” (ì´ ${maxTicks}í‹±)`;
                tickDisplay.textContent = `í‹± ê°¯ìˆ˜ : ${maxTicks}`; 
            } else {
                btn.classList.remove('active'); simControls.classList.remove('visible'); infoPanel.classList.remove('sim-mode');
                resetMeasureState(); 
            }
            updateLOS();
        }

        function resetSimState() {
            startPoint = null;
            simSegments = [];
            lockedAxis = null; 
            clearVisuals();
            rangeText.textContent = "ì‹œë®¬ë ˆì´í„° ëŒ€ê¸°";
            statusText.textContent = `í‹± 1 ì´ë™ì„ ì‹œì‘í•˜ì„¸ìš” (ì´ ${maxTicks}í‹±)`;
            updateLOS();
        }

        // Unified Change Function
        function changeVal(delta) {
            if (isSimMode) {
                maxTicks += delta; if(maxTicks < 1) maxTicks = 1;
                tickDisplay.textContent = `í‹± ê°¯ìˆ˜ : ${maxTicks}`;
                resetSimState();
                rangeText.textContent = "ë¦¬ì…‹ë¨";
                statusText.textContent = `í‹± ê°¯ìˆ˜ ë³€ê²½ë¨. ë‹¤ì‹œ ì‹œì‘í•˜ì„¸ìš”.`;
            } else if (isRangeMode) {
                rangeValue += delta; if(rangeValue < 1) rangeValue = 1;
                tickDisplay.textContent = `ì‚¬ê±°ë¦¬ : ${rangeValue}`;
                detailText.textContent = `í˜„ì¬ ì„¤ì •ëœ ì‚¬ê±°ë¦¬: ${rangeValue}`;
                updateLOS(); 
            }
        }

        function handleSimClick(x, y) {
            if (!startPoint) {
                startPoint = { x, y };
                lockedAxis = null; 
                const idx = y * currentGridWidth + x;
                if(tiles[idx]) tiles[idx].classList.add('start');
                statusText.textContent = `í‹± 1 ëª©í‘œë¥¼ ì„ íƒí•˜ì„¸ìš”`;
                updateLOS();
                return;
            }

            if (simSegments.length < maxTicks) {
                let lastPoint = (simSegments.length === 0) ? startPoint : simSegments[simSegments.length-1].end;
                const dist = Math.abs(x - lastPoint.x) + Math.abs(y - lastPoint.y);
                
                let currentAxis = lockedAxis;
                if (!currentAxis) {
                    currentAxis = (Math.abs(x - lastPoint.x) > Math.abs(y - lastPoint.y)) ? 'x' : 'y';
                }

                simSegments.push({ start: lastPoint, end: {x, y}, dist: dist, axis: currentAxis });
                lockedAxis = null; 

                if (simSegments.length === maxTicks) {
                    statusText.textContent = "ëª¨ë“  í‹± ì´ë™ ì™„ë£Œ! (í´ë¦­í•˜ì—¬ ë¦¬ì…‹)";
                } else {
                    statusText.textContent = `í‹± ${simSegments.length + 1} ëª©í‘œë¥¼ ì„ íƒí•˜ì„¸ìš”`;
                }
                
                handleSimHover(x, y); 
                updateLOS(); 
                return;
            } 
            resetSimState();
        }

        function handleSimHover(tx, ty) {
            if (!startPoint) return;

            clearVisuals();
            const startIdx = startPoint.y * currentGridWidth + startPoint.x;
            if(tiles[startIdx]) tiles[startIdx].classList.add('start');

            let totalDist = 0;
            let infoString = "";
            const colorMap = ["íŒŒë‘", "ë…¸ë‘", "ë¹¨ê°•"];

            simSegments.forEach((seg, idx) => {
                drawPathWithAxis(seg.start, seg.end, idx, seg.axis || 'x'); 
                totalDist += seg.dist;
                const colorName = colorMap[idx % 3]; 
                infoString += `<span style="font-size:0.6em; color:#ccc">T${idx+1}(${colorName}):</span> ${seg.dist}  `;
            });

            if (simSegments.length < maxTicks) {
                let currentStart = (simSegments.length === 0) ? startPoint : simSegments[simSegments.length-1].end;
                const targetIdx = ty * currentGridWidth + tx;
                if(tiles[targetIdx]) tiles[targetIdx].classList.add('target');
                
                const currentIdx = simSegments.length;
                
                if (lockedAxis === null && (tx !== currentStart.x || ty !== currentStart.y)) {
                    if (Math.abs(tx - currentStart.x) > Math.abs(ty - currentStart.y)) lockedAxis = 'x';
                    else lockedAxis = 'y';
                }
                if (tx === currentStart.x && ty === currentStart.y) lockedAxis = null;

                // âœ… ìˆ˜ì •ëœ ë³€ìˆ˜ ìˆœì„œ (ë²„ê·¸ í•´ê²°)
                let cx, cy;
                if (lockedAxis === 'y') { cx = currentStart.x; cy = ty; } else { cx = tx; cy = currentStart.y; }

                drawPathWithAxis(currentStart, {x: tx, y: ty}, currentIdx, lockedAxis);
                
                const currDist = Math.abs(tx - currentStart.x) + Math.abs(ty - currentStart.y);
                const colorName = colorMap[currentIdx % 3]; 
                infoString += `<span style="font-size:0.6em; color:#fff">T${currentIdx+1}(${colorName}):</span> <b>${currDist}</b>`;
                totalDist += currDist;
            }

            rangeText.innerHTML = infoString;
            detailText.textContent = `ì´ ì´ë™ ê±°ë¦¬: ${totalDist}`;
        }

        function clearVisuals() {
            tiles.forEach(t => {
                t.classList.remove('target');
                t.classList.remove('start');
                t.classList.remove('path'); 
                for(let i=0; i<3; i++) t.classList.remove(`path-tick-${i}`);
            });
        }

        function getLPathCells(p1, p2, axis) {
            let cells = [];
            let cx, cy;
            if (axis === 'y') { cx = p1.x; cy = p2.y; } else { cx = p2.x; cy = p1.y; }

            let xDir = cx > p1.x ? 1 : -1;
            let yDir = cy > p1.y ? 1 : -1;
            
            for (let i = 1; i <= Math.abs(cx - p1.x); i++) cells.push({x: p1.x + i * xDir, y: p1.y});
            for (let i = 1; i <= Math.abs(cy - p1.y); i++) cells.push({x: cx, y: p1.y + i * yDir});

            xDir = p2.x > cx ? 1 : -1;
            yDir = p2.y > cy ? 1 : -1;

            for (let i = 1; i <= Math.abs(p2.x - cx); i++) cells.push({x: cx + i * xDir, y: cy});
            for (let i = 1; i <= Math.abs(p2.y - cy); i++) cells.push({x: cx, y: cy + i * yDir});
            
            return cells;
        }

        function drawPathWithAxis(p1, p2, tickIdx, axis) {
            const cells = getLPathCells(p1, p2, axis || 'x');
            const pathClass = `path-tick-${tickIdx % 3}`;
            cells.forEach(c => {
                const idx = c.y * currentGridWidth + c.x;
                if (tiles[idx]) tiles[idx].classList.add(pathClass);
            });
        }

        // --- ê·¸ë¦¬ë“œ ìƒì„± ë° ë³€ê²½ ---
        function createGrid() {
            // âœ… [íƒ€ì¼ í¬ê¸° 65pxë¡œ í™•ëŒ€ ìœ ì§€]
            container.style.gridTemplateColumns = `repeat(${currentGridWidth}, 65px)`;
            container.style.gridTemplateRows = `repeat(${currentGridHeight}, 65px)`;
            container.innerHTML = '';
            tiles = [];

            for (let y = 0; y < currentGridHeight; y++) {
                for (let x = 0; x < currentGridWidth; x++) {
                    const tile = document.createElement('div');
                    tile.classList.add('tile');
                    tile.dataset.x = x; tile.dataset.y = y;
                    
                    const label = document.createElement('span');
                    label.classList.add('coord-label');
                    label.textContent = `${x},${y}`;
                    tile.appendChild(label);
                    
                    for (let i = 0; i < 9; i++) {
                        const sub = document.createElement('div');
                        sub.classList.add('subcell');
                        sub.dataset.idx = i; 
                        tile.appendChild(sub);
                    }
                    
                    tile.addEventListener('mousedown', (e) => {
                        isMouseDown = true; 
                        if (isEditorMode) handleEditorClick(e, x, y);
                        else if (isSimMode) handleSimClick(x, y);
                        else handleMeasureClick(x, y);
                    });
                    
                    tile.addEventListener('mouseenter', (e) => {
                        if (isEditorMode && isMouseDown) handleEditorClick(e, x, y);
                        else if (isSimMode) handleSimHover(x, y);
                        else if (!isEditorMode) handleMeasureHover(x, y);
                    });

                    container.appendChild(tile);
                    tiles.push(tile);
                }
            }
            updateAreaOverlay();
            updateLOS();
        }

        function applyGridSize() {
            const newW = parseInt(widthInput.value);
            const newH = parseInt(heightInput.value);
            if(isNaN(newW) || newW < 5 || newW > 40 || isNaN(newH) || newH < 5 || newH > 40) {
                alert("5 ~ 40 ì‚¬ì´ì˜ ê°’ì„ ì…ë ¥í•˜ì„¸ìš”."); return;
            }
            const currentData = getMapDataFromScreen();
            currentGridWidth = newW;
            currentGridHeight = newH;
            createGrid();
            currentData.forEach(data => {
                if(data.x < currentGridWidth && data.y < currentGridHeight) {
                    const index = data.y * currentGridWidth + data.x;
                    renderTileObject(tiles[index], data);
                }
            });
        }

        function handleEditorClick(e, x, y) {
            const index = y * currentGridWidth + x;
            const tile = tiles[index];
            const target = e.target;
            if (currentTool === 'CUSTOM_DRAW') {
                if (target.classList.contains('subcell')) {
                    target.classList.add('obs-weak'); 
                    target.classList.remove('obs-full', 'obs-partial');
                }
                return;
            }
            tile.querySelectorAll('.subcell').forEach(c => c.className = 'subcell');
            tile.querySelector('.coord-label').style.color = '#ccc';
            if (currentTool === 'ERASER') return;
            renderTileObject(tile, { t: currentTool });
        }

        function handleMapSelect() {
            const selected = mapSelector.value;
            if (!selected) return;
            if (selected === "__NEW__") {
                if(confirm("í™”ë©´ì„ ì´ˆê¸°í™”í•˜ê³  ìƒˆ ë§µì„ ë§Œë“œì‹œê² ìŠµë‹ˆê¹Œ?")) {
                    clearMapData(true); 
                    currentEditingMapName = null;
                    currentMapNameDisplay.textContent = "í˜„ì¬ ë§µ: (ìƒˆ ë§µ - ì €ì¥ë˜ì§€ ì•ŠìŒ)";
                    mapSelector.value = "";
                    toggleEditor(); 
                } else { mapSelector.value = ""; }
            } else {
                if (savedMaps[selected]) loadCustomMap(selected);
            }
        }

        function loadCustomMap(name) {
            if (isEditorMode || isSimMode || isRangeMode) resetAllModes();
            currentEditingMapName = name;
            currentMapNameDisplay.textContent = `í˜„ì¬ ë§µ: ${name}`;
            const mapDataObj = savedMaps[name];
            let tilesData = [];
            if (mapDataObj.width && mapDataObj.height && Array.isArray(mapDataObj.tiles)) {
                currentGridWidth = mapDataObj.width;
                currentGridHeight = mapDataObj.height;
                tilesData = mapDataObj.tiles;
            } else if (Array.isArray(mapDataObj)) {
                tilesData = mapDataObj;
                let maxX = 0, maxY = 0;
                tilesData.forEach(d => { if(d.x > maxX) maxX = d.x; if(d.y > maxY) maxY = d.y; });
                currentGridWidth = Math.max(12, maxX + 1);
                currentGridHeight = Math.max(12, maxY + 1);
            }
            widthInput.value = currentGridWidth; 
            heightInput.value = currentGridHeight;
            createGrid();
            tilesData.forEach(data => {
                if(data.x < currentGridWidth && data.y < currentGridHeight) {
                    const index = data.y * currentGridWidth + data.x;
                    if(tiles[index]) renderTileObject(tiles[index], data);
                }
            });
            document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
        }

        function saveMapAs() {
            const tilesData = getMapDataFromScreen();
            if (tilesData.length === 0 && !confirm("ë¹ˆ ë§µì…ë‹ˆë‹¤. ì €ì¥í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;
            let newName = prompt("ì €ì¥í•  ë§µì˜ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:", currentEditingMapName || "");
            if (newName === null) return; 
            newName = newName.trim();
            if (newName === "") { alert("ì´ë¦„ì„ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤."); return; }
            if (savedMaps[newName] && newName !== currentEditingMapName) {
                if(!confirm(`'${newName}' ë§µì´ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤. ë®ì–´ì”Œìš°ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
            }
            const mapObj = { width: currentGridWidth, height: currentGridHeight, tiles: tilesData };
            savedMaps[newName] = mapObj;
            localStorage.setItem('obsidian_saved_maps_v2', JSON.stringify(savedMaps));
            currentEditingMapName = newName;
            refreshMapDropdown();
            mapSelector.value = newName; 
            currentMapNameDisplay.textContent = `í˜„ì¬ ë§µ: ${newName}`;
            alert("ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!");
        }

        function deleteCurrentMap() {
            if (!currentEditingMapName || !savedMaps[currentEditingMapName]) {
                alert("ì‚­ì œí•  ë§µì´ ì„ íƒë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì €ì¥ë˜ì§€ ì•Šì€ ë§µì…ë‹ˆë‹¤."); return;
            }
            if(confirm(`ì •ë§ë¡œ '${currentEditingMapName}' ë§µì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                delete savedMaps[currentEditingMapName];
                localStorage.setItem('obsidian_saved_maps_v2', JSON.stringify(savedMaps));
                refreshMapDropdown();
                clearMapData(true);
                currentEditingMapName = null;
                currentMapNameDisplay.textContent = "í˜„ì¬ ë§µ: (ì‚­ì œë¨)";
                alert("ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");
            }
        }

        function getMapDataFromScreen() {
            const exportArray = [];
            for (let y = 0; y < currentGridHeight; y++) {
                for (let x = 0; x < currentGridWidth; x++) {
                    const idx = y * currentGridWidth + x;
                    const tile = tiles[idx];
                    const subcells = tile.querySelectorAll('.subcell');
                    const fullCount = Array.from(subcells).filter(c => c.classList.contains('obs-full')).length;
                    if (fullCount === 9) { exportArray.push({x:x, y:y, t:'FULL'}); continue; }
                    const weakIndices = [];
                    subcells.forEach((c, i) => { if (c.classList.contains('obs-weak')) weakIndices.push(i); });
                    if (weakIndices.length > 0) exportArray.push({x:x, y:y, t:'CONTAINER', idx:weakIndices});
                    
                    if (fullCount > 0 && fullCount < 9) {
                         if (subcells[0].classList.contains('obs-full') && subcells[1].classList.contains('obs-full')) exportArray.push({x:x, y:y, t:'BLK_T'});
                         else if (subcells[6].classList.contains('obs-full') && subcells[7].classList.contains('obs-full')) exportArray.push({x:x, y:y, t:'BLK_B'});
                         else if (subcells[0].classList.contains('obs-full') && subcells[3].classList.contains('obs-full')) exportArray.push({x:x, y:y, t:'BLK_L'});
                         else if (subcells[2].classList.contains('obs-full') && subcells[5].classList.contains('obs-full')) exportArray.push({x:x, y:y, t:'BLK_R'});
                         else if (subcells[3].classList.contains('obs-full') && subcells[4].classList.contains('obs-full')) exportArray.push({x:x, y:y, t:'BLK_M_H'});
                         else if (subcells[1].classList.contains('obs-full') && subcells[4].classList.contains('obs-full')) exportArray.push({x:x, y:y, t:'BLK_M_V'});
                    }
                    const partialCount = Array.from(subcells).filter(c => c.classList.contains('obs-partial')).length;
                    if (partialCount > 0) {
                         if (subcells[0].classList.contains('obs-partial') && subcells[1].classList.contains('obs-partial')) exportArray.push({x:x, y:y, t:'GRY_T'});
                         else if (subcells[6].classList.contains('obs-partial') && subcells[7].classList.contains('obs-partial')) exportArray.push({x:x, y:y, t:'GRY_B'});
                         else if (subcells[0].classList.contains('obs-partial') && subcells[3].classList.contains('obs-partial')) exportArray.push({x:x, y:y, t:'GRY_L'});
                         else if (subcells[2].classList.contains('obs-partial') && subcells[5].classList.contains('obs-partial')) exportArray.push({x:x, y:y, t:'GRY_R'});
                         else if (subcells[3].classList.contains('obs-partial') && subcells[4].classList.contains('obs-partial')) exportArray.push({x:x, y:y, t:'GRY_M_H'});
                         else if (subcells[1].classList.contains('obs-partial') && subcells[4].classList.contains('obs-partial')) exportArray.push({x:x, y:y, t:'GRY_M_V'});
                    }
                }
            }
            return exportArray;
        }

        function exportMapCode() {
            const data = getMapDataFromScreen();
            const strLines = data.map(item => {
                if(item.idx) return `{x:${item.x}, y:${item.y}, t:'${item.t}', idx:[${item.idx.join(',')}]}`;
                return `{x:${item.x}, y:${item.y}, t:'${item.t}'}`;
            });
            const codeString = `{
    width: ${currentGridWidth},
    height: ${currentGridHeight},
    tiles: [
        ${strLines.join(',\n        ')}
    ]
}`;
            navigator.clipboard.writeText(codeString).then(() => { alert("ì½”ë“œê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!"); }).catch(() => { prompt("Ctrl+C:", codeString); });
            importInput.value = codeString; 
        }

        function importMapCode() {
            const code = importInput.value;
            if (!code.trim()) { alert("ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”."); return; }
            try {
                const parsed = new Function("return " + code)();
                let tilesData = [];
                if (parsed.width && parsed.height && Array.isArray(parsed.tiles)) {
                    currentGridWidth = parsed.width;
                    currentGridHeight = parsed.height;
                    tilesData = parsed.tiles;
                } else if (Array.isArray(parsed)) {
                    tilesData = parsed;
                    let maxX = 0, maxY = 0;
                    tilesData.forEach(d => { if(d.x > maxX) maxX = d.x; if(d.y > maxY) maxY = d.y; });
                    currentGridWidth = Math.max(12, maxX + 1);
                    currentGridHeight = Math.max(12, maxY + 1);
                } else { throw new Error("ì˜¬ë°”ë¥¸ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤."); }
                widthInput.value = currentGridWidth; 
                heightInput.value = currentGridHeight;
                createGrid();
                tilesData.forEach(data => {
                    const index = data.y * currentGridWidth + data.x;
                    if (tiles[index]) renderTileObject(tiles[index], data);
                });
                alert("ë§µ ì½”ë“œë¥¼ ì ìš©í–ˆìŠµë‹ˆë‹¤.");
            } catch (e) { alert("ì½”ë“œ ì˜¤ë¥˜: " + e.message); }
        }

        function renderTileObject(tile, data) {
            const subcells = tile.querySelectorAll('.subcell');
            const type = data.t;
            if (type === 'FULL') { subcells.forEach(c => c.classList.add('obs-full')); tile.querySelector('.coord-label').style.color = '#555'; }
            else if (type === 'CONTAINER') { if (data.idx) data.idx.forEach(i => subcells[i].classList.add('obs-weak')); }
            else if (type === 'BLK_T') [0,1,2].forEach(i=>subcells[i].classList.add('obs-full'));
            else if (type === 'BLK_B') [6,7,8].forEach(i=>subcells[i].classList.add('obs-full'));
            else if (type === 'BLK_L') [0,3,6].forEach(i=>subcells[i].classList.add('obs-full'));
            else if (type === 'BLK_R') [2,5,8].forEach(i=>subcells[i].classList.add('obs-full'));
            else if (type === 'BLK_M_H') [3,4,5].forEach(i=>subcells[i].classList.add('obs-full'));
            else if (type === 'BLK_M_V') [1,4,7].forEach(i=>subcells[i].classList.add('obs-full'));
            else if (type === 'GRY_T') [0,1,2].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if (type === 'GRY_B') [6,7,8].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if (type === 'GRY_L') [0,3,6].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if (type === 'GRY_R') [2,5,8].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if (type === 'GRY_M_H') [3,4,5].forEach(i=>subcells[i].classList.add('obs-partial'));
            else if (type === 'GRY_M_V') [1,4,7].forEach(i=>subcells[i].classList.add('obs-partial'));
        }

        function toggleEditor() {
            if(isSimMode) toggleSimulator(); 
            isEditorMode = !isEditorMode;
            const btn = document.getElementById('btn-editor');
            if (isEditorMode) {
                btn.classList.add('active'); editorPanel.classList.add('visible'); infoPanel.classList.add('edit-mode');
                resetMeasureState(); rangeText.textContent = "ë§µ ì—ë””í„°"; detailText.textContent = "íƒ€ì¼ ë°°ì¹˜ / ì½”ë“œ ë³µì‚¬"; statusText.textContent = "íƒ€ì¼ í´ë¦­ (ë“œë˜ê·¸ ê°€ëŠ¥)";
            } else {
                btn.classList.remove('active'); editorPanel.classList.remove('visible'); infoPanel.classList.remove('edit-mode');
                rangeText.textContent = "ìœ„ì¹˜ ì„ íƒ"; detailText.textContent = "ì¼ë°˜ ëª¨ë“œ"; statusText.textContent = "ì‹œì‘ ì§€ì  í´ë¦­";
            }
        }

        function selectTool(toolName) {
            currentTool = toolName;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('selected'));
            document.querySelectorAll('.preset-group button').forEach(b => b.style.backgroundColor = '');
            if(event.currentTarget.classList.contains('tool-btn')) event.currentTarget.classList.add('selected');
            else event.currentTarget.style.backgroundColor = '#009688';
        }

        function clearMapData(force = false) {
            if(!force && !confirm("í˜„ì¬ ë§µì„ ëª¨ë‘ ì§€ìš°ì‹œê² ìŠµë‹ˆê¹Œ?")) return;
            tiles.forEach(tile => {
                tile.querySelectorAll('.subcell').forEach(c => c.className = 'subcell');
                tile.querySelector('.coord-label').style.color = '#ccc';
            });
        }

        function resetAllModes() {
            isEditorMode = false;
            editorPanel.classList.remove('visible');
            document.getElementById('btn-editor').classList.remove('active');
            infoPanel.classList.remove('edit-mode');
            isSimMode = false;
            simControls.classList.remove('visible');
            document.getElementById('btn-sim').classList.remove('active');
            infoPanel.classList.remove('sim-mode');
            simSegments = [];
            
            isLOSActive = false;
            document.getElementById('btn-los').classList.remove('active');
            
            // Range Mode Reset
            isRangeMode = false;
            document.getElementById('btn-range').classList.remove('active');
            infoPanel.classList.remove('range-mode');
            
            resetSimState();
            tiles.forEach(t => t.className = 'tile');
            const activeMapBtn = document.querySelector('.controls button.active');
            if(activeMapBtn && !activeMapBtn.id.includes('btn-sim') && !activeMapBtn.id.includes('btn-editor') && !activeMapBtn.id.includes('btn-area1') && !activeMapBtn.id.includes('btn-area2') && !activeMapBtn.id.includes('btn-los') && !activeMapBtn.id.includes('btn-range')) {
                loadMap(activeMapBtn.id.replace('btn-', '')); 
            }
            updateAreaOverlay(); 
        }

        function loadMap(mapName) {
            if (isEditorMode || isSimMode || isRangeMode) resetAllModes();
            if (mapName !== 'custom' && (currentGridWidth !== 12 || currentGridHeight !== 12)) {
                currentGridWidth = 12; currentGridHeight = 12;
                widthInput.value = 12; heightInput.value = 12;
                createGrid();
            }
            let mapData = defaultMaps[mapName];
            tiles.forEach(tile => {
                tile.querySelectorAll('.subcell').forEach(c => c.className = 'subcell');
                tile.querySelector('.coord-label').style.color = '#ccc';
            });
            if (mapData) {
                mapData.forEach(data => {
                    const index = data.y * currentGridWidth + data.x;
                    if (tiles[index]) renderTileObject(tiles[index], data);
                });
            }
            document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('btn-' + mapName);
            if(btn) btn.classList.add('active');
            mapSelector.value = "";
            currentEditingMapName = null;
            currentMapNameDisplay.textContent = `í˜„ì¬ ë§µ: ${mapName} (ê¸°ë³¸)`;
            
            updateAreaOverlay(); 
            updateLOS();
        }

        function resetMeasureState() {
            startPoint = null; isLocked = false;
            lockedAxis = null;
            infoPanel.classList.remove('locked');
            if(!isSimMode && !isRangeMode) {
                rangeText.textContent = "ìœ„ì¹˜ ì„ íƒ"; 
                detailText.textContent = "ì¼ë°˜ ëª¨ë“œ";
                statusText.textContent = "ì‹œì‘ ì§€ì ì„ í´ë¦­í•˜ì„¸ìš”";
            }
            tiles.forEach(t => t.classList.remove('start', 'path', 'target', 'locked'));
            updateLOS();
        }
        
        function handleMeasureClick(x, y) {
            if (!startPoint) {
                startPoint = { x, y };
                lockedAxis = null; 
                tiles[y * currentGridWidth + x].classList.add('start');
                
                if (isRangeMode) {
                    statusText.textContent = "ì‹œì‘ ì§€ì  ì„ íƒë¨. ì‚¬ê±°ë¦¬ë¥¼ ì¡°ì ˆí•˜ì„¸ìš”.";
                } else {
                    statusText.textContent = "ëª©í‘œ ì§€ì ì„ í´ë¦­í•˜ì—¬ ê³ ì •í•˜ì„¸ìš”";
                }
                
                handleMeasureHover(x, y);
                updateLOS();
                return;
            }
            if (!isLocked && !isRangeMode) {
                isLocked = true;
                infoPanel.classList.add('locked');
                statusText.textContent = "ê³ ì •ë¨ (ë‹¤ì‹œ í´ë¦­í•˜ì—¬ ì´ˆê¸°í™”)";
                tiles[y * currentGridWidth + x].classList.add('locked');
                return;
            }
            // Range mode: clicking new point resets start point
            if (isRangeMode) {
                resetMeasureState();
                startPoint = {x, y};
                tiles[y * currentGridWidth + x].classList.add('start');
                updateLOS();
                return;
            }

            if (isLocked) resetMeasureState();
        }

        function handleMeasureHover(tx, ty) {
            if (isRangeMode) return; // No hover path in range mode
            if (isLocked || !startPoint) return;
            tiles.forEach(t => { t.classList.remove('path', 'target'); });
            tiles[ty * currentGridWidth + tx].classList.add('target');
            
            const sx = startPoint.x; const sy = startPoint.y;
            
            if (lockedAxis === null && (tx !== sx || ty !== sy)) {
                if (Math.abs(tx - sx) > Math.abs(ty - sy)) lockedAxis = 'x';
                else lockedAxis = 'y';
            }
            if (tx === sx && ty === sy) lockedAxis = null;

            const cells = getLPathCells(startPoint, {x: tx, y: ty}, lockedAxis || 'x');
            cells.forEach(c => {
                const idx = c.y * currentGridWidth + c.x;
                if(tiles[idx]) tiles[idx].classList.add('path');
            });

            const distX = Math.abs(tx - sx); const distY = Math.abs(ty - sy);
            rangeText.innerHTML = `ì‚¬ê±°ë¦¬: <span style="color:white">${distX + distY}</span>`;
            detailText.textContent = `ê°€ë¡œ ${distX} + ì„¸ë¡œ ${distY}`;
        }

        createGrid();
        initMapStorage();
        loadMap('hotspot'); 

    </script>
</body>
</html>







