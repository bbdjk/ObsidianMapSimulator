<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes, orientation=landscape, viewport-fit=cover">
    
    <link rel="manifest" href="./manifest.json?v=21">
    <meta name="theme-color" content="#1e1e1e">
    <link rel="icon" href="./icon-192.png">
    <link rel="apple-touch-icon" href="./icon-192.png">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ObsidianMap">

    <script>
      if ("serviceWorker" in navigator) {
        // v= Îí§Ïóê ÏãúÍ∞ÑÏùÑ Î∂ôÏó¨ Îß§Î≤à ÏÉàÎ°úÏö¥ ÌååÏùºÎ°ú Ïù∏ÏãùÌïòÍ≤å Ìï® (Ï∫êÏãú Î∞©ÏßÄ)
        const swUrl = `./service-worker.js?v=${new Date().getTime()}`;
        navigator.serviceWorker.register(swUrl).then(reg => {
            console.log("SW Registered");
            reg.addEventListener('updatefound', () => {
                const newWorker = reg.installing;
                newWorker.addEventListener('statechange', () => {
                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                        window.location.reload();
                    }
                });
            });
        });
        navigator.serviceWorker.addEventListener("controllerchange", () => {
          window.location.reload();
        });
      }
    </script>

    <title>Obsidian Protocol Map Tool v71</title>
    <style>
        /* 2. üèóÔ∏è ÏßÄÎä•Ìòï Ïä§ÏºÄÏùºÎßÅ Î†àÏù¥ÏïÑÏõÉ ÏãúÏä§ÌÖú (Í≤πÏπ® Î∞©ÏßÄ) */
        :root {
            --tile-size: 65px;
        }

        /* [ÏÇ¨Ïö©Ïûê ÏùòÍ≤¨ Î∞òÏòÅ] Í∞ÄÎ°úÎ™®ÎìúÎäî ÎÜíÏù¥ Í∏∞Ï§Ä, ÏÑ∏Î°úÎ™®ÎìúÎäî ÎÑàÎπÑ Í∏∞Ï§Ä Ïä§ÏºÄÏùºÎßÅ */
        @media screen and (orientation: landscape) {
            :root { --tile-size: min(65px, 6.5vh); }
        }
        @media screen and (orientation: portrait) {
            :root { --tile-size: min(65px, 7.8vw); }
        }

        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            background-color: #1e1e1e;
            color: #e0e0e0;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column; /* ÏàòÏßÅ 3Îã® Íµ¨Ï°∞ Í≥†Ï†ï */
            overflow: hidden;
        }

        .ui-header {
            flex: 0 0 auto;
            background-color: #252525;
            padding: 8px 0;
            border-bottom: 1px solid #333;
            z-index: 1000;
            width: 100%;
            display: flex;
            justify-content: center;
            overflow-x: auto;
            white-space: nowrap;
            -webkit-overflow-scrolling: touch;
        }
        .controls { display: flex; gap: 6px; padding: 0 15px; align-items: center; }

        .main-area {
            flex: 1 1 auto;
            width: 100%;
            overflow: auto; 
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            touch-action: pan-x pan-y pinch-zoom;
            padding: 20px;
            box-sizing: border-box;
        }

        #grid-container {
            display: grid; gap: 1px;
            background-color: #444; border: 4px solid #333;
            padding: 2px; border-radius: 4px;
            margin: auto;
        }

        .tile {
            width: var(--tile-size);
            height: var(--tile-size);
            background-color: #fff;
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            grid-template-rows: repeat(3, 1fr);
            position: relative;
            cursor: crosshair;
        }

        .bottom-ui {
            flex: 0 0 auto;
            background-color: #1e1e1e;
            border-top: 1px solid #333;
            padding: 12px 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 1000;
            padding-bottom: max(12px, env(safe-area-inset-bottom));
        }

        #info-panel {
            background: #2d2d2d;
            padding: 15px 25px;
            border-radius: 8px;
            border: 1px solid #444;
            width: 90%;
            max-width: 650px;
            text-align: center;
        }

        /* --- ÏõêÎ≥∏ Ìö®Í≥ºÎì§ Î≥¥Ï°¥ --- */
        #range-text { font-size: 1.4em; font-weight: bold; color: #4fc3f7; margin-bottom: 5px; white-space: pre-wrap; }
        #detail-text { font-size: 1.1em; color: #aaa; margin-bottom: 5px; }
        #status-text { font-size: 0.95em; color: #888; font-style: italic; margin-bottom: 10px; }
        
        .legend-box { display: flex; justify-content: center; gap: 15px; margin-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px; font-size: 0.85em; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; border: 1px solid rgba(255,255,255,0.3); }
        .l-green { background-color: rgba(76, 175, 80, 0.8); }
        .l-yellow { background-color: rgba(255, 235, 59, 0.5); border: 1px dashed #fff; }
        .l-blue { background-color: rgba(33, 150, 243, 0.8); }

        button { padding: 8px 14px; background: #3a3a3a; color: white; border: 1px solid #555; border-radius: 4px; font-weight: 600; white-space: nowrap; cursor: pointer; transition: all 0.2s; }
        button:hover { background: #505050; }
        button.active { background-color: #2e7d32; border-color: #1b5e20; }
        #btn-editor { background-color: #ff9800; color: #000; border-color: #f57c00; }
        #btn-editor.active { background-color: #e65100; color: white; box-shadow: 0 0 10px #ff9800; }
        #btn-sim { background-color: #9c27b0; color: white; border-color: #7b1fa2; }
        #btn-range { background-color: #fbc02d; color: black; border-color: #f57f17; }

        .subcell { border: 0.1px solid rgba(0,0,0,0.05); box-sizing: border-box; }
        .subcell.obs-full { background-color: #111; } 
        .subcell.obs-partial { background-color: #777; background-image: repeating-linear-gradient(45deg, #666, #666 2px, #777 2px, #777 4px); }
        .subcell.obs-weak { background-color: #009688; box-shadow: inset 0 0 2px rgba(255,255,255,0.3); }
        .subcell.sub-visible { background-color: rgba(76, 175, 80, 0.6) !important; }
        .subcell.in-range { background-color: rgba(255, 235, 59, 0.25); }
        .subcell.sub-visible.in-range { background-color: rgba(33, 150, 243, 0.65) !important; }

        .tile.start::after { content: ''; position: absolute; inset: 0; background-color: rgba(33, 150, 243, 0.6); border: 2px solid #2196f3; z-index: 5; pointer-events: none; }
        .tile.target::before { content: ''; position: absolute; inset: 0; background-color: rgba(244, 67, 54, 0.5); border: 2px solid #e53935; z-index: 6; pointer-events: none; }
        .tile.path::before { content: ''; position: absolute; inset: 2px; background-color: rgba(255, 235, 59, 0.3); border: 2px dashed #fdd835; z-index: 4; pointer-events: none; }
        .tile.path-tick-0::before { background-color: rgba(33, 150, 243, 0.4); }
        .tile.path-tick-1::before { background-color: rgba(255, 235, 59, 0.4); }
        .tile.path-tick-2::before { background-color: rgba(244, 67, 54, 0.4); border: 2px dashed #d32f2f; }

        .coord-label { position: absolute; top: 1px; left: 2px; font-size: 11px; color: #ccc; z-index: 10; pointer-events: none; font-family: monospace; }

        #editor-panel {
            position: fixed; right: 0; top: 0; height: 100%; width: 320px;
            background: #222; border-left: 1px solid #444; padding: 15px;
            display: none; flex-direction: column; overflow-y: auto; z-index: 2000;
        }
        #editor-panel.visible { display: flex; }
        .editor-section { margin-bottom: 25px; }
        .editor-title { font-weight: bold; margin-bottom: 10px; color: #fff; border-bottom: 1px solid #555; padding-bottom: 5px; font-size: 0.95em; }
        .tool-btn { display: flex; align-items: center; justify-content: space-between; width: 100%; margin-bottom: 5px; text-align: left; padding: 10px; background: #333; border: 1px solid #444; font-size: 0.9em; cursor: pointer; color: #ccc; }
        .tool-btn.selected { background: #009688; color: white; border-color: #004d40; }
        .preset-group { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .preset-group button { width: 100%; font-size: 0.85em; padding: 8px; background: #444; color: #ddd; border: 1px solid #555; }
        .io-btn { padding: 10px; font-weight: bold; cursor: pointer; color: white; border: none; flex: 1; }
        #import-input { width: 100%; height: 50px; background: #111; color: #0f0; font-family: monospace; font-size: 0.8em; border: 1px solid #444; margin-bottom: 5px; resize: none; }
        .size-input { width: 45px; padding: 5px; background: #222; color: white; border: 1px solid #555; text-align: center; }

        @media screen and (orientation: portrait) {
            .ui-header { justify-content: flex-start; }
            #editor-panel { width: 100%; height: 50vh; top: auto; bottom: 0; border-left: none; border-top: 2px solid #444; }
        }
    </style>
</head>
<body>

    <div class="ui-header">
        <div class="controls">
            <button id="btn-hotspot" onclick="loadMap('hotspot')">Hotspot</button>
            <button id="btn-crossroads" onclick="loadMap('crossroads')">Crossroads</button>
            <button id="btn-alley" onclick="loadMap('alley')">Alley</button>
            <div style="width:1px; height:20px; background:#555; margin:0 5px;"></div>
            <select id="map-selector" onchange="handleMapSelect()" style="padding:8px; background:#263238; color:white; border-radius:4px; border:1px solid #37474f;">
                <option value="" disabled selected>Ï†ÄÏû•Îêú Îßµ</option>
                <option value="__NEW__">+ ÏÉà Îßµ</option>
            </select>
            <div style="width:1px; height:20px; background:#555; margin:0 5px;"></div>
            <button id="btn-editor" onclick="toggleEditor()">üõ† Îßµ ÏóêÎîîÌÑ∞</button>
            <button id="btn-area1" onclick="toggleArea1()">Area1</button>
            <button id="btn-area2" onclick="toggleArea2()">Area2</button>
            <button id="btn-sim" onclick="toggleSimulator()">üé≤ ÏãúÎÆ¨Î†àÏù¥ÌÑ∞</button>
            <button id="btn-los" onclick="toggleLOS()">üëÅ LOS</button>
            <button id="btn-range" onclick="toggleRangeMode()">üìè ÏÇ¨Í±∞Î¶¨</button>
        </div>
    </div>

    <div class="main-area">
        <div id="grid-container"></div>
    </div>

    <div class="bottom-ui">
        <div id="sim-controls" style="display:none; align-items:center; gap:15px; margin-bottom:12px; background:#333; padding:8px 20px; border-radius:20px;">
            <button class="tick-btn" onclick="changeVal(-1)" style="width:35px; height:35px; border-radius:50%; font-size:1.4em;">-</button>
            <span id="tick-display" style="font-weight:bold;">Ìã± Í∞ØÏàò : 3</span>
            <button class="tick-btn" onclick="changeVal(1)" style="width:35px; height:35px; border-radius:50%; font-size:1.4em;">+</button>
        </div>

        <div id="info-panel">
            <div id="range-text">ÏúÑÏπò ÏÑ†ÌÉù</div>
            <div id="detail-text">ÏùºÎ∞ò Î™®Îìú</div>
            <div id="status-text">ÏãúÏûë ÏßÄÏ†êÏùÑ ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî</div>
            <div class="legend-box">
                <div class="legend-item"><div class="legend-color l-green"></div>ÏãúÏïº</div>
                <div class="legend-item"><div class="legend-color l-yellow"></div>ÏÇ¨Í±∞Î¶¨</div>
                <div class="legend-item"><div class="legend-color l-blue"></div>Í≥µÍ≤©Í∞ÄÎä•</div>
            </div>
        </div>
    </div>

    <div id="editor-panel">
        <button onclick="toggleEditor()" style="background:#444; margin-bottom:15px; border:none;">‚ùå Îã´Í∏∞</button>
        <div class="editor-section">
            <div class="editor-title">üîÑ ÎåÄÏπ≠ Î≥µÏÇ¨ ÎèÑÍµ¨ (Ï†êÎåÄÏπ≠)</div>
            <div class="preset-group">
                <button onclick="applySymmetry('T2B')">‚¨Ü ÏÉÅÎã® ‚û° ÌïòÎã®</button>
                <button onclick="applySymmetry('B2T')">‚¨á ÌïòÎã® ‚û° ÏÉÅÎã®</button>
                <button onclick="applySymmetry('L2R')">‚¨Ö Ï¢åÏ∏° ‚û° Ïö∞Ï∏°</button>
                <button onclick="applySymmetry('R2L')">‚û° Ïö∞Ï∏° ‚û° Ï¢åÏ∏°</button>
            </div>
        </div>
        <div class="editor-section">
            <div class="editor-title">üìê Îßµ ÌÅ¨Í∏∞ ÏÑ§Ï†ï</div>
            <div style="display:flex; align-items:center; gap:5px; background:#333; padding:10px; border-radius:4px;">
                <span>W:</span> <input type="number" id="grid-width-input" class="size-input" value="12" min="5" max="40">
                <span>H:</span> <input type="number" id="grid-height-input" class="size-input" value="12" min="5" max="40">
                <button style="padding:5px 10px;" onclick="applyGridSize()">Î≥ÄÍ≤Ω</button>
            </div>
        </div>
        <div class="editor-section">
            <div class="editor-title">Îßµ Ï†ÄÏû• Í¥ÄÎ¶¨</div>
            <div id="current-map-name" style="color:#00bcd4; margin-bottom:5px; font-size:0.9em;">ÌòÑÏû¨ Îßµ: (Ï†ÄÏû•ÎêòÏßÄ ÏïäÏùå)</div>
            <div style="display:flex; gap:5px; margin-bottom:10px;">
                <button style="background:#2e7d32; flex:1;" onclick="saveMapAs()">üíæ Ï†ÄÏû•</button>
                <button style="background:#c62828; flex:1;" onclick="deleteCurrentMap()">üóë ÏÇ≠Ï†ú</button>
            </div>
            <textarea id="import-input" placeholder="ÏΩîÎìú Î∂ôÏó¨ÎÑ£Í∏∞..."></textarea>
            <div style="display:flex; gap:5px;">
                <button style="background:#0277bd; flex:1;" onclick="exportMapCode()">üìã Î≥µÏÇ¨</button>
                <button style="background:#e65100; flex:1;" onclick="importMapCode()">üìÇ Î∂àÎü¨Ïò§Í∏∞</button>
            </div>
        </div>
        <button id="clear-editor-btn" onclick="clearMapData()" style="width:100%; background:#d32f2f; color:white; padding:10px; border:none; margin-top:10px;">‚ö° Îßµ Ï¥àÍ∏∞Ìôî</button>
        <div class="editor-section" style="margin-top:20px;">
            <div class="editor-title">Í∏∞Î≥∏ ÎèÑÍµ¨</div>
            <button class="tool-btn selected" onclick="selectTool('ERASER')">‚¨ú ÏßÄÏö∞Í∞ú</button>
            <button class="tool-btn" onclick="selectTool('CUSTOM_DRAW')">‚úèÔ∏è ÏßÅÏ†ë Í∑∏Î¶¨Í∏∞</button>
            <button class="tool-btn" onclick="selectTool('FULL')">‚¨õ 3x3 ÏÉÅÏûê</button>
            <div class="preset-group" style="margin-top:10px;">
                <button onclick="selectTool('BLK_T')">‚¨Ü ÏÉÅÎã®Î≤Ω</button>
                <button onclick="selectTool('BLK_B')">‚¨á ÌïòÎã®Î≤Ω</button>
                <button onclick="selectTool('BLK_L')">‚¨Ö Ï¢åÏ∏°Î≤Ω</button>
                <button onclick="selectTool('BLK_R')">‚û° Ïö∞Ï∏°Î≤Ω</button>
                <button onclick="selectTool('BLK_M_H')">‚ûñ Ï§ëÏïô(Í∞Ä)</button>
                <button onclick="selectTool('BLK_M_V')">‚ùò Ï§ëÏïô(ÏÑ∏)</button>
            </div>
        </div>
    </div>

    <script>
        const container = document.getElementById('grid-container');
        const infoPanel = document.getElementById('info-panel');
        const rangeText = document.getElementById('range-text');
        const detailText = document.getElementById('detail-text');
        const statusText = document.getElementById('status-text');
        const editorPanel = document.getElementById('editor-panel');
        const simControls = document.getElementById('sim-controls');
        const tickDisplay = document.getElementById('tick-display');
        const importInput = document.getElementById('import-input');
        const mapSelector = document.getElementById('map-selector');
        const currentMapNameDisplay = document.getElementById('current-map-name');
        const widthInput = document.getElementById('grid-width-input');
        const heightInput = document.getElementById('grid-height-input');
        
        let tiles = []; 
        let isEditorMode = false; let isSimMode = false; let isRangeMode = false; 
        let isArea1Active = false; let isArea2Active = false;
        let isLOSActive = false; let isMouseDown = false; let currentTool = 'ERASER'; 
        let currentGridWidth = 12; let currentGridHeight = 12;
        let startPoint = null; let isLocked = false; let maxTicks = 3; let rangeValue = 4; 
        let simSegments = []; let lockedAxis = null; let savedMaps = {};

        window.addEventListener('mouseup', () => { isMouseDown = false; });

        const defaultMaps = {
            hotspot: [{x:9, y:1, t:'CONTAINER', idx:[8]}, {x:7, y:2, t:'FULL'}, {x:8, y:2, t:'CONTAINER', idx:[2]}, {x:10, y:2, t:'BLK_B'}, {x:2, y:3, t:'GRY_R'}, {x:7, y:3, t:'FULL'}, {x:2, y:4, t:'BLK_T'}, {x:5, y:4, t:'BLK_T'}, {x:6, y:4, t:'CONTAINER', idx:[2,5]}, {x:8, y:4, t:'FULL'}, {x:9, y:4, t:'CONTAINER', idx:[7,8]}, {x:10, y:4, t:'CONTAINER', idx:[3,6]}, {x:4, y:5, t:'CONTAINER', idx:[2]}, {x:8, y:5, t:'GRY_R'}, {x:3, y:6, t:'GRY_L'}, {x:7, y:6, t:'CONTAINER', idx:[6]}, {x:1, y:7, t:'CONTAINER', idx:[2,5]}, {x:2, y:7, t:'CONTAINER', idx:[0,1]}, {x:3, y:7, t:'FULL'}, {x:5, y:7, t:'CONTAINER', idx:[3,6]}, {x:6, y:7, t:'BLK_B'}, {x:9, y:7, t:'BLK_B'}, {x:4, y:8, t:'FULL'}, {x:9, y:8, t:'GRY_L'}, {x:1, y:9, t:'BLK_T'}, {x:3, y:9, t:'CONTAINER', idx:[0]}, {x:4, y:9, t:'FULL'}, {x:2, y:10, t:'CONTAINER', idx:[0]}],
            crossroads: [{x:8, y:2, t:'BLK_L'}, {x:4, y:3, t:'GRY_R'}, {x:8, y:3, t:'FULL'}, {x:9, y:3, t:'GRY_T'}, {x:0, y:4, t:'CONTAINER', idx:[7,8]}, {x:1, y:4, t:'BLK_B'}, {x:2, y:4, t:'BLK_B'}, {x:3, y:4, t:'FULL'}, {x:4, y:4, t:'FULL'}, {x:5, y:4, t:'CONTAINER', idx:[7,8]}, {x:6, y:4, t:'CONTAINER', idx:[5,8]}, {x:8, y:4, t:'GRY_R'}, {x:4, y:5, t:'CONTAINER', idx:[8]}, {x:7, y:6, t:'CONTAINER', idx:[0]}, {x:3, y:7, t:'GRY_L'}, {x:5, y:7, t:'CONTAINER', idx:[0,3]}, {x:6, y:7, t:'CONTAINER', idx:[0,1]}, {x:7, y:7, t:'FULL'}, {x:8, y:7, t:'FULL'}, {x:9, y:7, t:'BLK_T'}, {x:10, y:7, t:'BLK_T'}, {x:11, y:7, t:'CONTAINER', idx:[0,1]}, {x:2, y:8, t:'GRY_B'}, {x:3, y:8, t:'FULL'}, {x:7, y:8, t:'GRY_L'}, {x:3, y:9, t:'BLK_R'}],
            alley: [{x:5, y:2, t:'BLK_B'}, {x:10, y:2, t:'GRY_L'}, {x:3, y:3, t:'GRY_L'}, {x:4, y:3, t:'CONTAINER', idx:[5,8]}, {x:6, y:3, t:'CONTAINER', idx:[8]}, {x:0, y:4, t:'BLK_T'}, {x:2, y:4, t:'CONTAINER', idx:[6,7]}, {x:4, y:4, t:'BLK_T'}, {x:6, y:4, t:'FULL'}, {x:8, y:4, t:'FULL'}, {x:9, y:4, t:'GRY_T'}, {x:10, y:4, t:'CONTAINER', idx:[8]}, {x:3, y:5, t:'CONTAINER', idx:[5,8]}, {x:7, y:5, t:'FULL'}, {x:11, y:5, t:'CONTAINER', idx:[0]}, {x:0, y:6, t:'CONTAINER', idx:[8]}, {x:4, y:6, t:'FULL'}, {x:8, y:6, t:'CONTAINER', idx:[0,3]}, {x:1, y:7, t:'CONTAINER', idx:[0]}, {x:2, y:7, t:'GRY_B'}, {x:3, y:7, t:'FULL'}, {x:5, y:7, t:'FULL'}, {x:7, y:7, t:'BLK_B'}, {x:9, y:7, t:'CONTAINER', idx:[1,2]}, {x:11, y:7, t:'BLK_B'}, {x:5, y:8, t:'CONTAINER', idx:[0]}, {x:7, y:8, t:'CONTAINER', idx:[0,3]}, {x:8, y:8, t:'GRY_R'}, {x:1, y:9, t:'GRY_R'}, {x:6, y:9, t:'BLK_T'}]
        };

        function initMapStorage() {
            const stored = localStorage.getItem('obsidian_saved_maps_v2');
            if (stored) { try { savedMaps = JSON.parse(stored); } catch(e) { savedMaps = {}; } }
            refreshMapDropdown();
        }

        function refreshMapDropdown() {
            mapSelector.innerHTML = '<option value="" disabled selected>Ï†ÄÏû•Îêú Îßµ</option>';
            Object.keys(savedMaps).sort().forEach(name => {
                const opt = document.createElement('option'); opt.value = name; opt.textContent = name; mapSelector.appendChild(opt);
            });
            const newOpt = document.createElement('option'); newOpt.value = "__NEW__"; newOpt.textContent = "+ ÏÉà Îßµ"; mapSelector.appendChild(newOpt);
        }

        function createGrid() {
            container.style.gridTemplateColumns = `repeat(${currentGridWidth}, 1fr)`;
            container.style.gridTemplateRows = `repeat(${currentGridHeight}, 1fr)`;
            container.innerHTML = ''; tiles = [];
            for (let y = 0; y < currentGridHeight; y++) {
                for (let x = 0; x < currentGridWidth; x++) {
                    const tile = document.createElement('div'); tile.className = 'tile';
                    tile.dataset.x = x; tile.dataset.y = y;
                    const label = document.createElement('span'); label.className = 'coord-label'; label.textContent = `${x},${y}`;
                    tile.appendChild(label);
                    for (let i = 0; i < 9; i++) {
                        const sub = document.createElement('div'); sub.className = 'subcell'; tile.appendChild(sub);
                    }
                    tile.addEventListener('mousedown', (e) => {
                        isMouseDown = true; 
                        if (isEditorMode) handleEditorClick(e, x, y);
                        else if (isSimMode) handleSimClick(x, y);
                        else handleMeasureClick(x, y);
                    });
                    tile.addEventListener('mouseenter', (e) => {
                        if (isEditorMode && isMouseDown) handleEditorClick(e, x, y);
                        else if (isSimMode) handleSimHover(x, y);
                        else if (!isEditorMode) handleMeasureHover(x, y);
                    });
                    container.appendChild(tile); tiles.push(tile);
                }
            }
            updateAreaOverlay(); updateLOS();
        }

        function applySymmetry(mode) {
            const W = currentGridWidth; const H = currentGridHeight;
            let startX = 0, endX = W, startY = 0, endY = H;
            if (mode === 'T2B') endY = Math.ceil(H / 2);
            else if (mode === 'B2T') startY = Math.floor(H / 2);
            else if (mode === 'L2R') endX = Math.ceil(W / 2);
            else if (mode === 'R2L') startX = Math.floor(W / 2);
            const updates = [];
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const srcIdx = y * W + x; const srcTile = tiles[srcIdx];
                    const tx = (W - 1) - x; const ty = (H - 1) - y;
                    const subcells = srcTile.querySelectorAll('.subcell');
                    const cellData = [];
                    for(let i=0; i<9; i++) {
                        const cl = subcells[i].classList;
                        if(cl.contains('obs-full')) cellData.push('obs-full');
                        else if(cl.contains('obs-partial')) cellData.push('obs-partial');
                        else if(cl.contains('obs-weak')) cellData.push('obs-weak');
                        else cellData.push(null);
                    }
                    updates.push({tx, ty, cellData});
                }
            }
            updates.forEach(up => {
                const tgtIdx = up.ty * W + up.tx; const tgtTile = tiles[tgtIdx]; if (!tgtTile) return;
                for(let i=0; i<9; i++) tgtTile.children[i+1].className = 'subcell';
                for(let i=0; i<9; i++) { const type = up.cellData[i]; if (type) tgtTile.children[(8-i)+1].classList.add(type); }
            });
            updateLOS(); alert("ÎåÄÏπ≠ Î≥µÏÇ¨ ÏôÑÎ£å!");
        }

        function applyGridSize() {
            const newW = parseInt(widthInput.value); const newH = parseInt(heightInput.value);
            if(isNaN(newW) || newW < 5 || newW > 40 || isNaN(newH) || newH < 5 || newH > 40) return;
            const currentData = getMapDataFromScreen();
            currentGridWidth = newW; currentGridHeight = newH;
            createGrid();
            currentData.forEach(data => {
                if(data.x < currentGridWidth && data.y < currentGridHeight) renderTileObject(tiles[data.y * currentGridWidth + data.x], data);
            });
        }

        function updateLOS() {
            document.querySelectorAll('.subcell').forEach(s => s.classList.remove('sub-visible', 'in-range'));
            let origin = (simSegments.length > 0) ? simSegments[simSegments.length - 1].end : (startPoint || null);
            if (origin) {
                if (isRangeMode) calculateRangeArea(origin);
                if (isLOSActive || isRangeMode) calculateLOS(origin);
            }
        }

        function calculateRangeArea(origin) {
            for(let y=0; y<currentGridHeight; y++) {
                for(let x=0; x<currentGridWidth; x++) {
                    const dist = Math.abs(x - origin.x) + Math.abs(y - origin.y);
                    if (dist <= rangeValue) {
                        const idx = y * currentGridWidth + x;
                        if(tiles[idx]) for(let i=0; i<9; i++) tiles[idx].children[i+1].classList.add('in-range');
                    }
                }
            }
        }

        function calculateLOS(origin) {
            const tileX = origin.x * 3; const tileY = origin.y * 3;
            const originPoints = [{x: tileX+1.5, y: tileY+1.5}, {x: tileX+0.1, y: tileY+0.1}, {x: tileX+2.9, y: tileY+0.1}, {x: tileX+0.1, y: tileY+2.9}, {x: tileX+2.9, y: tileY+2.9}];
            const blockers = [];
            tiles.forEach((t, idx) => {
                const tx = idx % currentGridWidth; const ty = Math.floor(idx / currentGridWidth);
                for(let i=0; i<9; i++) if(t.children[i+1].classList.contains('obs-full')) blockers.push({x: tx*3+(i%3), y: ty*3+Math.floor(i/3)});
            });
            const gridW = currentGridWidth*3; const gridH = currentGridHeight*3;
            for (let gy=0; gy<gridH; gy++) {
                for (let gx=0; gx<gridW; gx++) {
                    const tx = Math.floor(gx/3); const ty = Math.floor(gy/3);
                    const tile = tiles[ty * currentGridWidth + tx];
                    if (!tile || tile.children[(gy%3)*3+(gx%3)+1].classList.contains('obs-full')) continue;
                    let visible = false;
                    for (let op of originPoints) if (!isRayBlocked(op.x, op.y, gx+0.5, gy+0.5, blockers)) { visible = true; break; }
                    if (visible) tile.children[(gy%3)*3+(gx%3)+1].classList.add('sub-visible');
                }
            }
        }

        function isRayBlocked(x0, y0, x1, y1, blockers) {
            for (let b of blockers) if (lineIntersectsBox(x0, y0, x1, y1, b.x, b.y, 1, 1)) return true;
            return false;
        }

        function lineIntersectsBox(x1, y1, x2, y2, bx, by, bw, bh) {
            let dx = x2 - x1, dy = y2 - y1;
            let tmin = -Infinity, tmax = Infinity;
            if (dx !== 0) { let t1 = (bx - x1) / dx, t2 = (bx + bw - x1) / dx; tmin = Math.max(tmin, Math.min(t1, t2)); tmax = Math.min(tmax, Math.max(t1, t2)); }
            else if (x1 < bx || x1 > bx + bw) return false;
            if (dy !== 0) { let t1 = (by - y1) / dy, t2 = (by + bh - y1) / dy; tmin = Math.max(tmin, Math.min(t1, t2)); tmax = Math.min(tmax, Math.max(t1, t2)); }
            else if (y1 < by || y1 > by + bh) return false;
            return tmax >= tmin && tmax >= 0 && tmin <= 1;
        }

        function toggleSimulator() { isSimMode = !isSimMode; isRangeMode = false; isEditorMode = false; document.getElementById('btn-sim').classList.toggle('active', isSimMode); simControls.style.display = isSimMode ? 'flex' : 'none'; resetMeasureState(); }
        function toggleRangeMode() { isRangeMode = !isRangeMode; isSimMode = false; isEditorMode = false; document.getElementById('btn-range').classList.toggle('active', isRangeMode); simControls.style.display = isRangeMode ? 'flex' : 'none'; resetMeasureState(); }
        function toggleLOS() { isLOSActive = !isLOSActive; document.getElementById('btn-los').classList.toggle('active'); updateLOS(); }
        function toggleEditor() { isEditorMode = !isEditorMode; editorPanel.classList.toggle('visible'); document.getElementById('btn-editor').classList.toggle('active'); }
        function toggleArea1() { isArea1Active = !isArea1Active; document.getElementById('btn-area1').classList.toggle('active'); updateAreaOverlay(); }
        function toggleArea2() { isArea2Active = !isArea2Active; document.getElementById('btn-area2').classList.toggle('active'); updateAreaOverlay(); }

        function updateAreaOverlay() {
            tiles.forEach(t => t.classList.remove('area-red', 'area-blue'));
            for(let y=0; y<currentGridHeight; y++) {
                for(let x=0; x<currentGridWidth; x++) {
                    const tile = tiles[y * currentGridWidth + x]; if(!tile) continue;
                    if (isArea1Active) { if (x <= 4 && y <= 2) tile.classList.add('area-red'); if (x >= 7 && y >= 9) tile.classList.add('area-blue'); }
                    if (isArea2Active) { if (y <= 1) tile.classList.add('area-red'); if (y >= 10) tile.classList.add('area-blue'); }
                }
            }
        }

        function changeVal(n) {
            if(isSimMode) { maxTicks = Math.max(1, maxTicks + n); tickDisplay.innerText = `Ìã± Í∞ØÏàò : ${maxTicks}`; resetSimState(); }
            else if(isRangeMode) { rangeValue = Math.max(1, rangeValue + n); tickDisplay.innerText = `ÏÇ¨Í±∞Î¶¨ : ${rangeValue}`; updateLOS(); }
        }

        function handleMeasureClick(x, y) {
            if (!startPoint) { startPoint = { x, y }; tiles[y * currentGridWidth + x].classList.add('start'); updateLOS(); }
            else if (!isLocked) { isLocked = true; tiles[y * currentGridWidth + x].classList.add('target'); }
            else resetMeasureState();
        }

        function handleMeasureHover(tx, ty) {
            if (isLocked || !startPoint) return;
            tiles.forEach(t => t.classList.remove('path', 'target'));
            const sx = startPoint.x, sy = startPoint.y;
            tiles[ty * currentGridWidth + tx].classList.add('target');
            const dx = Math.abs(tx - sx), dy = Math.abs(ty - sy);
            const cells = getLPathCells(startPoint, {x: tx, y: ty}, (dx > dy) ? 'x' : 'y');
            cells.forEach(c => { const idx = c.y * currentGridWidth + c.x; if(tiles[idx]) tiles[idx].classList.add('path'); });
            rangeText.innerHTML = `ÏÇ¨Í±∞Î¶¨: <span style="color:white">${dx + dy}</span>`;
            detailText.innerText = `Í∞ÄÎ°ú ${dx} + ÏÑ∏Î°ú ${dy}`;
        }

        function getLPathCells(p1, p2, axis) {
            let cells = []; let cx, cy;
            if (axis === 'y') { cx = p1.x; cy = p2.y; } else { cx = p2.x; cy = p1.y; }
            let xDir = cx > p1.x ? 1 : -1; let yDir = cy > p1.y ? 1 : -1;
            for (let i = 1; i <= Math.abs(cx - p1.x); i++) cells.push({x: p1.x + i * xDir, y: p1.y});
            for (let i = 1; i <= Math.abs(cy - p1.y); i++) cells.push({x: cx, y: p1.y + i * yDir});
            xDir = p2.x > cx ? 1 : -1; yDir = p2.y > cy ? 1 : -1;
            for (let i = 1; i <= Math.abs(p2.x - cx); i++) cells.push({x: cx + i * xDir, y: cy});
            for (let i = 1; i <= Math.abs(p2.y - cy); i++) cells.push({x: cx, y: cy + i * yDir});
            return cells;
        }

        function handleSimClick(x, y) {
            if (!startPoint) { startPoint = {x, y}; tiles[y*currentGridWidth+x].classList.add('start'); updateLOS(); return; }
            if (simSegments.length < maxTicks) {
                let last = simSegments.length === 0 ? startPoint : simSegments[simSegments.length-1].end;
                simSegments.push({start: last, end: {x, y}, dist: Math.abs(x-last.x)+Math.abs(y-last.y)});
                if(simSegments.length === maxTicks) statusText.textContent = "Ïù¥Îèô ÏôÑÎ£å! (ÌÅ¥Î¶≠ Ïãú Î¶¨ÏÖã)";
                updateLOS();
            } else resetSimState();
        }

        function handleSimHover(tx, ty) {
            if (!startPoint || simSegments.length >= maxTicks) return;
            tiles.forEach(t => t.classList.remove('path', 'target', 'start'));
            tiles[startPoint.y * currentGridWidth + startPoint.x].classList.add('start');
            simSegments.forEach((s, i) => drawPath(s.start, s.end, i));
            let last = simSegments.length === 0 ? startPoint : simSegments[simSegments.length-1].end;
            drawPath(last, {x: tx, y: ty}, simSegments.length);
            tiles[ty * currentGridWidth + tx].classList.add('target');
        }

        function drawPath(p1, p2, idx) {
            const cells = getLPathCells(p1, p2, (Math.abs(p2.x-p1.x) > Math.abs(p2.y-p1.y)) ? 'x' : 'y');
            cells.forEach(c => { const tile = tiles[c.y * currentGridWidth + c.x]; if(tile) tile.classList.add(`path-tick-${idx % 3}`); });
        }

        function resetSimState() { startPoint = null; simSegments = []; tiles.forEach(t => { t.classList.remove('start','path','target','path-tick-0','path-tick-1','path-tick-2'); }); updateLOS(); }
        function resetMeasureState() { startPoint = null; isLocked = false; tiles.forEach(t => t.classList.remove('start','target','path')); updateLOS(); }

        function loadMap(name) {
            const data = defaultMaps[name]; if(!data) return;
            tiles.forEach(t => { for(let i=0; i<9; i++) t.children[i+1].className = 'subcell'; t.querySelector('.coord-label').style.color = '#ccc'; });
            data.forEach(d => renderTileObject(tiles[d.y * currentGridWidth + d.x], d));
            document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-'+name)?.classList.add('active'); updateLOS();
        }

        function handleMapSelect() { const sel = mapSelector.value; if (sel === "__NEW__") { clearMapData(true); currentEditingMapName = null; } else if (savedMaps[sel]) loadCustomMap(sel); }
        function loadCustomMap(name) { const obj = savedMaps[name]; currentGridWidth = obj.width; currentGridHeight = obj.height; createGrid(); obj.tiles.forEach(d => renderTileObject(tiles[d.y * currentGridWidth + d.x], d)); currentEditingMapName = name; currentMapNameDisplay.innerText = `ÌòÑÏû¨ Îßµ: ${name}`; }
        function saveMapAs() { const name = prompt("Ïù¥Î¶Ñ ÏûÖÎ†•", currentEditingMapName || ""); if(!name) return; savedMaps[name] = {width: currentGridWidth, height: currentGridHeight, tiles: getMapDataFromScreen()}; localStorage.setItem('obsidian_saved_maps_v2', JSON.stringify(savedMaps)); refreshMapDropdown(); }
        function deleteCurrentMap() { if(!currentEditingMapName) return; delete savedMaps[currentEditingMapName]; localStorage.setItem('obsidian_saved_maps_v2', JSON.stringify(savedMaps)); refreshMapDropdown(); clearMapData(true); }

        function handleEditorClick(e, x, y) {
            const tile = tiles[y * currentGridWidth + x]; const target = e.target;
            if (currentTool === 'CUSTOM_DRAW' && target.classList.contains('subcell')) { target.classList.add('obs-weak'); return; }
            for(let i=0; i<9; i++) tile.children[i+1].className = 'subcell';
            if (currentTool !== 'ERASER') renderTileObject(tile, { t: currentTool });
        }

        function renderTileObject(tile, data) {
            const subs = tile.querySelectorAll('.subcell'); const type = data.t;
            if (type === 'FULL') subs.forEach(s => s.classList.add('obs-full'));
            else if (type === 'BLK_T') [0,1,2].forEach(i=>subs[i+1].classList.add('obs-full'));
            else if (type === 'BLK_B') [6,7,8].forEach(i=>subs[i+1].classList.add('obs-full'));
            else if (type === 'BLK_L') [0,3,6].forEach(i=>subs[i+1].classList.add('obs-full'));
            else if (type === 'BLK_R') [2,5,8].forEach(i=>subs[i+1].classList.add('obs-full'));
            else if (type === 'BLK_M_H') [3,4,5].forEach(i=>subs[i+1].classList.add('obs-full'));
            else if (type === 'BLK_M_V') [1,4,7].forEach(i=>subs[i+1].classList.add('obs-full'));
            else if (type === 'CONTAINER' && data.idx) data.idx.forEach(i => subs[i+1].classList.add('obs-weak'));
        }

        function getMapDataFromScreen() {
            const arr = [];
            for(let i=0; i<tiles.length; i++) {
                const x = i % currentGridWidth, y = Math.floor(i / currentGridWidth);
                const subs = tiles[i].querySelectorAll('.subcell');
                const fulls = Array.from(subs).filter(s => s.classList.contains('obs-full'));
                if(fulls.length === 9) arr.push({x, y, t:'FULL'});
                else {
                    const weaks = Array.from(subs).map((s, idx) => s.classList.contains('obs-weak') ? idx : null).filter(idx => idx !== null);
                    if(weaks.length > 0) arr.push({x, y, t:'CONTAINER', idx:weaks});
                }
            }
            return arr;
        }

        function clearMapData(f) { if(!f && !confirm("ÏßÄÏö∞Í∏∞?")) return; tiles.forEach(t => { for(let i=0; i<9; i++) t.children[i+1].className = 'subcell'; }); }
        function selectTool(t) { currentTool = t; document.querySelectorAll('.tool-btn').forEach(b => b.classList.toggle('selected', b.innerText.includes(t))); }

        initMapStorage();
        createGrid();
        loadMap('hotspot');
    </script>
</body>
</html>
